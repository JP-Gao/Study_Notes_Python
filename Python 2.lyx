#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[BoldFont,SlantFont,CJKnumber,fallback]{xeCJK}%使用TexLive自带的xeCJK宏包，并启用加粗、斜体、CJK数字和备用字体选项
\setCJKmainfont{Songti SC}%设置中文衬线字体,若没有该字体,请替换该字符串为系统已有的中文字体,下同
\setCJKsansfont{STXihei}%中文无衬线字体
\setCJKmonofont{SimHei}%中文等宽字体
%中文断行和弹性间距在XeCJK中自动处理了
%\XeTeXlinebreaklocale “zh”%中文断行
%\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt%左右弹性间距
\usepackage{indentfirst}%段落首行缩进

%%%%%%%%%%%
\usepackage{color}
\usepackage{xcolor}
% \definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\usepackage{listings}
\lstset{breaklines}%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题
\lstset{language= R, %用于设置语言为C++
  %背景框
  framexleftmargin=10mm,
  frame=none,
  %背景色
  %backgroundcolor=\color[rgb]{1,1,0.76},
  backgroundcolor=\color[RGB]{245,245,244},
  %样式
  keywordstyle=\bf\color{blue},
  identifierstyle=\bf,
  numberstyle=\color[RGB]{0,192,192},
  commentstyle=\it\color[RGB]{0,96,96},
  stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},
  %显示空格
  showstringspaces=false,
  xleftmargin=2em, %边距
  xrightmargin=2em, 
  aboveskip=1em
}


%%%%%%%%%%%%

\usepackage[multidot]{grffile}
\setlength{\parindent}{2em}%缩进两个字符

\usepackage[BoldFont,SlantFont,CJKnumber,fallback]{xeCJK}%使用TexLive自带的xeCJK宏包，并启用加粗、斜体、CJK数字和备用字体选项
\setCJKmainfont{Songti SC}%设置中文衬线字体,若没有该字体,请替换该字符串为系统已有的中文字体,下同
\setCJKsansfont{STXihei}%中文无衬线字体
\setCJKmonofont{SimHei}%中文等宽字体
%中文断行和弹性间距在XeCJK中自动处理了
%\XeTeXlinebreaklocale “zh”%中文断行
%\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt%左右弹性间距
\usepackage{indentfirst}%段落首行缩进

%%%%%%%%%%%
\usepackage{color}
\usepackage{xcolor}
% \definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\usepackage{listings}
\lstset{breaklines}%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题
\lstset{language= R, %用于设置语言为C++
  %背景框
  framexleftmargin=10mm,
  frame=none,
  %背景色
  %backgroundcolor=\color[rgb]{1,1,0.76},
  backgroundcolor=\color[RGB]{245,245,244},
  %样式
  keywordstyle=\bf\color{blue},
  identifierstyle=\bf,
  numberstyle=\color[RGB]{0,192,192},
  commentstyle=\it\color[RGB]{0,96,96},
  stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},
  %显示空格
  showstringspaces=false,
  xleftmargin=2em, %边距
  xrightmargin=2em, 
  aboveskip=1em
}


%%%%%%%%%%%%

\usepackage[multidot]{grffile}
\setlength{\parindent}{2em}%缩进两个字符
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding utf8
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 0
\use_package cancel 0
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 0
\use_package mhchem 0
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes true
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author -445235034 "yangguodaxia" 
\author 16419249 "v660271" 
\end_header

\begin_body

\begin_layout Title
Python 2: MAIN
\end_layout

\begin_layout Author
Fan Yang
\begin_inset Foot
status open

\begin_layout Plain Layout
2014
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
未央
\end_layout

\begin_layout Standard
python warning
\end_layout

\begin_layout Standard
print without quote
\end_layout

\begin_layout Subsection
scope of __int__
\end_layout

\begin_layout Standard
Both ways aren't correct or incorrect, they are just two different kind
 of class elements:
\end_layout

\begin_layout Standard
Elements outside the __init__ method are static elements, it means, they
 belong to the class.
\end_layout

\begin_layout Standard
Elements inside the __init__ method are elements of the object (self), they
 don't belong to the class.
\end_layout

\begin_layout Standard
You'll see it more clearly with some code:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class MyClass:
\end_layout

\begin_layout Plain Layout

    static_elem = 123
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def __init__(self):
\end_layout

\begin_layout Plain Layout

        self.object_elem = 456
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Initial values of both elements
\end_layout

\begin_layout Plain Layout

>>> print c1.static_elem, c1.object_elem 
\end_layout

\begin_layout Plain Layout

123 456
\end_layout

\begin_layout Plain Layout

>>> print c2.static_elem, c2.object_elem
\end_layout

\begin_layout Plain Layout

123 456
\end_layout

\begin_layout Plain Layout

# Nothing new so far ...
\end_layout

\begin_layout Plain Layout

# Let's try changing the static element
\end_layout

\begin_layout Plain Layout

MyClass.static_elem = 999
\end_layout

\begin_layout Plain Layout

>>> print c1.static_elem, c1.object_elem
\end_layout

\begin_layout Plain Layout

999 456
\end_layout

\begin_layout Plain Layout

>>> print c2.static_elem, c2.object_elem
\end_layout

\begin_layout Plain Layout

999 456
\end_layout

\begin_layout Plain Layout

# Now, let's try changing the object element
\end_layout

\begin_layout Plain Layout

c1.object_elem = 888
\end_layout

\begin_layout Plain Layout

>>> print c1.static_elem, c1.object_elem
\end_layout

\begin_layout Plain Layout

999 888
\end_layout

\begin_layout Plain Layout

>>> print c2.static_elem, c2.object_elem
\end_layout

\begin_layout Plain Layout

999 456	
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As you can see, when we changed the class element, it changed for both objects.
 But, when we changed the object element, the other object remained unchanged.
\end_layout

\begin_layout Subsection
parse_arguments()
\end_layout

\begin_layout Subsection
is or ==
\end_layout

\begin_layout Standard
is will return True if two variables point to the same object, == if the
 objects referred to by the variables are equal.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> a = [1, 2, 3]
\end_layout

\begin_layout Plain Layout

>>> b = a
\end_layout

\begin_layout Plain Layout

>>> b is a 
\end_layout

\begin_layout Plain Layout

True
\end_layout

\begin_layout Plain Layout

>>> b == a
\end_layout

\begin_layout Plain Layout

True
\end_layout

\begin_layout Plain Layout

>>> b = a[:]
\end_layout

\begin_layout Plain Layout

>>> b is a
\end_layout

\begin_layout Plain Layout

False
\end_layout

\begin_layout Plain Layout

>>> b == a
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
define method outside class
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class MyClass(object):
\end_layout

\begin_layout Plain Layout

    pass
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def func(self):
\end_layout

\begin_layout Plain Layout

    print "func"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

MyClass.myMethod = func
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can define the function and the class in different modules if you want,
 but I'd advise against defining the class in one module then importing
 it in another and adding methods to it dynamically (as in my second example),
 because then you'd have surprisingly different behaviour from the class
 depending on whether or not another module has been imported.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Subsection
duplicate columns
\end_layout

\begin_layout Subsection
re.groups()
\end_layout

\begin_layout Standard
only when pattern contains(...), it will then generate groups
\end_layout

\begin_layout Standard
(...): Matches whatever regular expression is inside the parentheses, and indicates
 the start and end of a group; the contents of a group can be retrieved
 after a match has been performed, and can be matched later in the string
 with the 
\backslash
number special sequence, described below.
 To match the literals '(' or ')', use 
\backslash
( or 
\backslash
), or enclose them inside a character class: [(] [)].
 
\end_layout

\begin_layout Part
I/O and System
\end_layout

\begin_layout Section
File Path
\end_layout

\begin_layout Subsection
path name conventions
\end_layout

\begin_layout Itemize
When setting a folder:
\family typewriter
 os.chdir('/Users/yangguodaxia/Dropbox')
\family default
, note that must stating with / 
\change_inserted -445235034 1462506035
to denote a root folder.
\change_unchanged

\end_layout

\begin_deeper
\begin_layout Itemize
worng: no / to begin with:
\family typewriter
os.chdir('Users/yangguodaxia/Dropbox/')
\end_layout

\end_deeper
\begin_layout Itemize
When reading files
\end_layout

\begin_layout Itemize
you 'd better to use / not
\backslash
 in file name
\end_layout

\begin_deeper
\begin_layout Itemize
if you did use
\backslash
:
\end_layout

\begin_deeper
\begin_layout Itemize
for numbers, you have to put double backslash
\backslash

\backslash

\end_layout

\begin_layout Itemize

\backslash
t is wrong,
\backslash

\backslash
t is correct
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
sys.executable: where the python interpretor locates
\end_layout

\begin_layout Subsection
The System Path: where the module install
\end_layout

\begin_layout Standard
See more detail at the sys.path section
\end_layout

\begin_layout Standard
To show the system path
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

import sys
\end_layout

\begin_layout Plain Layout

sys.path # it is a list
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To change the system path, just change the sys.path
\end_layout

\begin_layout Subsection
Working directory
\end_layout

\begin_layout Standard
your working directory might be in /usr/home and be created by a mkdir command i
n a shell window or file explorer GUI specific to your platform
\end_layout

\begin_layout Section
sys.path: How does python find packages?
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import site; site.getsitepackages() ['/usr/local/lib/python2.7/dist-packages',
 '/usr/lib/python2.7/dist-packages']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
(or just first item with site.getsitepackages()[0])
\end_layout

\begin_layout Subsection
sys.path
\end_layout

\begin_layout Standard
Python imports work by searching the directories listed in sys.path.
\end_layout

\begin_layout Standard
Using my default Ubuntu 14.04 Python:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

> import sys
\end_layout

\begin_layout Plain Layout

> print '
\backslash
n'.join(sys.path)
\end_layout

\begin_layout Plain Layout

/usr/lib/python2.7
\end_layout

\begin_layout Plain Layout

/usr/lib/python2.7/plat-x86_64-linux-gnu
\end_layout

\begin_layout Plain Layout

/usr/lib/python2.7/lib-tk
\end_layout

\begin_layout Plain Layout

/usr/lib/python2.7/lib-old
\end_layout

\begin_layout Plain Layout

/usr/lib/python2.7/lib-dynload
\end_layout

\begin_layout Plain Layout

/usr/local/lib/python2.7/dist-packages
\end_layout

\begin_layout Plain Layout

/usr/lib/python2.7/dist-packages
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
How sys.path gets populated
\end_layout

\begin_layout Standard
As the docs explain, sys.path is populated using the current working directory, f
ollowed by directories listed in your PYTHONPATH environment variable, followed
 by installation-dependent default paths, which are controlled by the site
 module.
\end_layout

\begin_layout Standard
You can read more about sys.path in the Python docs.
\end_layout

\begin_layout Standard
Assuming your PYTHONPATH environment variable is not set, sys.path will consist o
f the current working directory plus any manipulations made to it by the site
 module.
\end_layout

\begin_layout Standard
The site module is automatically imported when you start Python, you can read
 more about how it manipulates your sys.path in the Python docs.
\end_layout

\begin_layout Subsection
You can manipulate sys.path using list[]
\end_layout

\begin_layout Subsection
The module __file__ attribute to see where the module is in your filesystem:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

> import numpy
\end_layout

\begin_layout Plain Layout

> numpy.__file__
\end_layout

\begin_layout Plain Layout

'/usr/local/lib/python2.7/dist-packages/numpy/__init__.pyc'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, the Python docs state that:
\end_layout

\begin_layout Standard
The file attribute is not present for C modules that are statically linked into
 the interpreter; for extension modules loaded dynamically from a shared library
, it is the pathname of the shared library file.
\end_layout

\begin_layout Standard
So, for example this doesn't work:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

> import sys
\end_layout

\begin_layout Plain Layout

> sys.__file__
\end_layout

\begin_layout Plain Layout

Traceback (most recent call last):
\end_layout

\begin_layout Plain Layout

File "stdin>", line 1, in module>
\end_layout

\begin_layout Plain Layout

AttributeError: 'module' object has no attribute '__file__'
\end_layout

\end_inset


\end_layout

\begin_layout Section
Start
\end_layout

\begin_layout Subsection
Launch Options
\end_layout

\begin_layout Standard
assign all common functions, vars , imported modules on the top of global
 envirorment
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from attach_load_first import *
\end_layout

\end_inset


\end_layout

\begin_layout Section
Storage
\end_layout

\begin_layout Subsection
Pickle: store the Python object in file
\end_layout

\begin_layout Standard
# File content is always a string
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

f = open('data.txt')
\end_layout

\begin_layout Plain Layout

text = f.read()
\end_layout

\begin_layout Plain Layout

text.split()
\end_layout

\begin_layout Plain Layout

['Hello', 'world']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But we can use pickle to store the Python object in file and without worrying ab
out formats.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# Useful to store arbitrary objects to a file. Not safe or fast!
\end_layout

\begin_layout Plain Layout

In [1]: import pickle
\end_layout

\begin_layout Plain Layout

In [2]: l = [1, None, 'Stan']
\end_layout

\begin_layout Plain Layout

In [3]: pickle.dump(l, file('test.pkl', 'w'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [4]: pickle.load(file('test.pkl')) O
\end_layout

\begin_layout Plain Layout

ut[4]: [1, None, 'Stan']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
USE rb (byte) format when use pickle!
\end_layout

\begin_layout Subsection
JSON Format
\end_layout

\begin_layout Standard
See P343.
\end_layout

\begin_layout Standard
JSON is a newer and emerging data interchange format, which is both programming-
language-neutral and supported by a variety of systems. MongoDB, for instance,
 stores data in a JSON document database (using a binary JSON format).
\end_layout

\begin_layout Subsection
File Context Managers
\end_layout

\begin_layout Standard
More efficient garbage collection tool.
\end_layout

\begin_layout Subsection
Store as Packed Binary Data : struct
\end_layout

\begin_layout Standard
Transform any data to binary string.
\end_layout

\begin_layout Section
PythonAnywhere
\end_layout

\begin_layout Itemize
install packages: Just run
\begin_inset ERT
status open

\begin_layout Plain Layout

pip2.7 install --user pyodbc
\end_layout

\end_inset

(adjusting the Python version as required) to get the Python package.
\end_layout

\begin_layout Section
OS and Directory
\end_layout

\begin_layout Standard
http://www.scipy-lectures.org/intro/language/standard_library.html#os-module-operat
ing-system-functionality
\end_layout

\begin_layout Standard
implemented by
\family typewriter
os. modual
\end_layout

\begin_layout Subsection
Directory and file manipulation
\end_layout

\begin_layout Itemize
Current directory:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [17]: os.getcwd()
\end_layout

\begin_layout Plain Layout

Out[17]: '/Users/cburns/src/scipy2009/scipy_2009_tutorial/source'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Set working directory
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

os.chdir('path')
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
List a directory:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [31]: os.listdir(os.curdir)
\end_layout

\begin_layout Plain Layout

Out[31]:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

['.index.rst.swo',
\end_layout

\begin_layout Plain Layout

'.python_language.rst.swp',
\end_layout

\begin_layout Plain Layout

'.view_array.py.swp',
\end_layout

\begin_layout Plain Layout

'_static',
\end_layout

\begin_layout Plain Layout

'_templates',
\end_layout

\begin_layout Plain Layout

'basic_types.rst',
\end_layout

\begin_layout Plain Layout

'conf.py',
\end_layout

\begin_layout Plain Layout

'control_flow.rst',
\end_layout

\begin_layout Plain Layout

'debugging.rst',
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Make a directory:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [32]: os.mkdir('junkdir')
\end_layout

\begin_layout Plain Layout

In [33]: 'junkdir' in os.listdir(os.curdir) Out[33]: True
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Rename the directory:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [36]: os.rename('junkdir', 'foodir')
\end_layout

\begin_layout Plain Layout

In [37]: 'junkdir' in os.listdir(os.curdir) Out[37]: False
\end_layout

\begin_layout Plain Layout

In [38]: 'foodir' in os.listdir(os.curdir) Out[38]: True
\end_layout

\begin_layout Plain Layout

In [41]: os.rmdir('foodir')
\end_layout

\begin_layout Plain Layout

In [42]: 'foodir' in os.listdir(os.curdir) Out[42]: False
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Delete a file:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [44]: fp = open('junk.txt', 'w')
\end_layout

\begin_layout Plain Layout

In [45]: fp.close()
\end_layout

\begin_layout Plain Layout

In [46]: 'junk.txt' in os.listdir(os.curdir) Out[46]: True
\end_layout

\begin_layout Plain Layout

In [47]: os.remove('junk.txt')
\end_layout

\begin_layout Plain Layout

In [48]: 'junk.txt' in
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
current file's path
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

print("This file path, relative to os.getcwd()")
\end_layout

\begin_layout Plain Layout

print(__file__ + "
\backslash
n")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print("This file full path (following symlinks)")
\end_layout

\begin_layout Plain Layout

full_path = os.path.realpath(__file__)
\end_layout

\begin_layout Plain Layout

print(full_path + "
\backslash
n")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print("This file directory and name")
\end_layout

\begin_layout Plain Layout

path, filename = os.path.split(full_path)
\end_layout

\begin_layout Plain Layout

print(path + ' --> ' + filename + "
\backslash
n")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print("This file directory only")
\end_layout

\begin_layout Plain Layout

print(os.path.dirname(full_path))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
os.path: path manipulations
\end_layout

\begin_layout Standard
os.path provides common operations on pathnames.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [70]: fp = open('junk.txt', 'w')
\end_layout

\begin_layout Plain Layout

In [71]: fp.close()
\end_layout

\begin_layout Plain Layout

In [72]: a = os.path.abspath('junk.txt')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [73]: a
\end_layout

\begin_layout Plain Layout

Out[73]: '/Users/cburns/src/scipy2009/scipy_2009_tutorial/source/junk.txt'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [74]: os.path.split(a)
\end_layout

\begin_layout Plain Layout

Out[74]: ('/Users/cburns/src/scipy2009/scipy_2009_tutorial/source',
\end_layout

\begin_layout Plain Layout

'junk.txt')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [78]: os.path.dirname(a)
\end_layout

\begin_layout Plain Layout

Out[78]: '/Users/cburns/src/scipy2009/scipy_2009_tutorial/source'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [79]: os.path.basename(a)
\end_layout

\begin_layout Plain Layout

Out[79]: 'junk.txt'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [80]: os.path.splitext(os.path.basename(a))
\end_layout

\begin_layout Plain Layout

Out[80]: ('junk', '.txt')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [84]: os.path.exists('junk.txt')
\end_layout

\begin_layout Plain Layout

Out[84]: True
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [86]: os.path.isfile('junk.txt')
\end_layout

\begin_layout Plain Layout

Out[86]: True
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [87]: os.path.isdir('junk.txt')
\end_layout

\begin_layout Plain Layout

Out[87]: False
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [88]: os.path.expanduser('~/local')
\end_layout

\begin_layout Plain Layout

Out[88]: '/Users/cburns/local'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [92]: os.path.join(os.path.expanduser('~'), 'local', 'bin')
\end_layout

\begin_layout Plain Layout

Out[92]: '/Users/cburns/local/bin'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
shutil: high-level file operations
\end_layout

\begin_layout Standard
The shutil provides useful file operations:
\end_layout

\begin_layout Itemize
shutil.rmtree: Recursively delete a directory tree.
\end_layout

\begin_layout Itemize
shutil.move: Recursively move a file or directory to another location.
\end_layout

\begin_layout Itemize
shutil.copy: Copy files or directories.
\end_layout

\begin_layout Subsection
glob: Pattern matching on files
\end_layout

\begin_layout Standard
The glob module provides convenient file pattern matching.
\end_layout

\begin_layout Standard
Find all files ending in .txt:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [18]: import glob
\end_layout

\begin_layout Plain Layout

In [19]: glob.glob('*.txt')
\end_layout

\begin_layout Plain Layout

Out[19]: ['holy_grail.txt', 'junk.txt', 'newfile.txt']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
sys module: system-specific information
\end_layout

\begin_layout Standard
System-specific information related to the Python interpreter.
\end_layout

\begin_layout Standard
Which version of python are you running and where is it installed:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [117]: sys.platform
\end_layout

\begin_layout Plain Layout

Out[117]: 'darwin'
\end_layout

\begin_layout Plain Layout

In [118]: sys.version
\end_layout

\begin_layout Plain Layout

Out[118]: '2.5.2 (r252:60911, Feb 22 2008, 07:57:53)
\backslash
n
\end_layout

\begin_layout Plain Layout

[GCC 4.0.1 (Apple Computer, Inc. build 5363)]'
\end_layout

\begin_layout Plain Layout

In [119]: sys.prefix
\end_layout

\begin_layout Plain Layout

Out[119]: '/Library/Frameworks/Python.framework/Versions/2.5'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
List of command line arguments passed to a Python script:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [100]: sys.argv
\end_layout

\begin_layout Plain Layout

Out[100]: ['/Users/cburns/local/bin/ipython']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
sys.path is a list of strings that specifies the search path for modules. Initiali
zed from PYTHONPATH:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [121]: sys.path
\end_layout

\begin_layout Plain Layout

Out[121]:
\end_layout

\begin_layout Plain Layout

['',
\end_layout

\begin_layout Plain Layout

'/Users/cburns/local/bin',
\end_layout

\begin_layout Plain Layout

'/Users/cburns/local/lib/python2.5/site-packages/grin-1.1-py2.5.egg',
\end_layout

\begin_layout Plain Layout

'/Users/cburns/local/lib/python2.5/site-packages/argparse-0.8.0-py2.5.egg',
\end_layout

\begin_layout Plain Layout

'/Users/cburns/local/lib/python2.5/site-packages/urwid-0.9.7.1-py2.5.egg',
\end_layout

\begin_layout Plain Layout

'/Users/cburns/local/lib/python2.5/site-packages/yolk-0.4.1-py2.5.egg',
\end_layout

\begin_layout Plain Layout

'/Users/cburns/local/lib/python2.5/site-packages/virtualenv-1.2-py2.5.egg',
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
NOT FINISHED
\end_layout

\begin_layout Standard
http://www.scipy-lectures.org/intro/language/standard_library.html#os-module-operat
ing-system-functionality
\end_layout

\begin_layout Section
Print
\end_layout

\begin_layout Subsection
print() multiple strings
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

print ("player's choice: ", player_choice)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
结果带括号 和引号
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

print "player's choice: ", player_choice
\end_layout

\end_inset


\end_layout

\begin_layout Standard
结果无括号or 引号
\end_layout

\begin_layout Subsection
print behavior in function
\end_layout

\begin_layout Standard
If no print() in function, then not show up in Console, even if that object is
 the result of function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def f(**args): print(args)
\end_layout

\begin_layout Plain Layout

>>> f(a=1, b=2)
\end_layout

\begin_layout Plain Layout

{'a': 1, 'b': 2}
\end_layout

\begin_layout Plain Layout

>>> def f(**args): args
\end_layout

\begin_layout Plain Layout

>>> f(a=1, b=2)
\end_layout

\begin_layout Plain Layout

>>>
\end_layout

\end_inset


\end_layout

\begin_layout Section
input/output data
\end_layout

\begin_layout Subsection
from csv
\end_layout

\begin_layout Standard
pandas.read_csv('examples/brain_size.csv', sep=';', na_values=".")
\end_layout

\begin_layout Standard
They can take a number of arguments:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
filepath_or_buffer: Either a path to a file (a str, pathlib.Path, or py._path.local.
LocalPath), URL (including http, ftp, and S3 locations), or any object with a
 read method (such as an open file or StringIO).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
sep or delimiter: A delimiter / separator to split fields on. With sep=None,
 read_csv will try to infer the delimiter automatically in some cases by
 “sniffing”. The separator may be specified as a regular expression; for
 instance you may use ‘|
\backslash
s*’ to indicate a pipe plus arbitrary whitespace.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
delim_whitespace: Parse whitespace-delimited (spaces or tabs) file (much faster
 than using a regular expression)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
compression: decompress 'gzip' and 'bz2' formats on the fly. Set to 'infer'
 (the default) to guess a format based on the file extension.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
dialect: string or csv.Dialect instance to expose more ways to specify the file
 format
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
dtype: A data type name or a dict of column name to data type. If not specified,
 data types will be inferred. (Unsupported with engine='python')
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
header: row number(s) to use as the column names, and the start of the data. Defa
ults to 0 if no names passed, otherwise None. Explicitly pass header=0 to
 be able to replace existing names. The header can be a list of integers
 that specify row locations for a multi-index on the columns E.g. [0,1,3]. Interven
ing rows that are not specified will be skipped (e.g. 2 in this example are
 skipped). Note that this parameter ignores commented lines and empty lines
 if skip_blank_lines=True (the default), so header=0 denotes the first line
 of data rather than the first line of the file.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
header = None means the original data has no header.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
skip_blank_lines: whether to skip over blank lines rather than interpreting them
 as NaN values
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
skiprows: A collection of numbers for rows in the file to skip. Can also
 be an integer to skip the first n rows
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
index_col: column number, column name, or list of column numbers/names, to
 use as the index (row labels) of the resulting DataFrame. By default, it
 will number the rows without using any column, unless there is one more
 data column than there are headers, in which case the first column is taken
 as the index.0
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
names: List of column names to use as column names. To replace header existing
 in file, explicitly pass header=0.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
na_values: optional string or list of strings to recognize as NaN (missing value
s), either in addition to or in lieu of the default set.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
true_values: list of strings to recognize as True
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
false_values: list of strings to recognize as False
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
keep_default_na: whether to include the default set of missing values in additio
n to the ones specified in na_values
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
parse_dates: if True then index will be parsed as dates (False by default). You
 can specify more complicated options to parse a subset of columns or a
 combination of columns into a single date column (list of ints or names, list
 of lists, or dict) [1, 2, 3] -> try parsing columns 1, 2, 3 each as a separate
 date column [[1, 3]] -> combine columns 1 and 3 and parse as a single date
 column {‘foo’ : [1, 3]} -> parse columns 1, 3 as date and call result ‘foo’
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
keep_date_col: if True, then date component columns passed into parse_dates will
 be retained in the output (False by default).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
date_parser: function to use to parse strings into datetime objects. If parse_dat
es is True, it defaults to the very robust dateutil.parser. Specifying this
 implicitly sets parse_dates as True. You can also use functions from community
 supported date converters from date_converters.py
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
dayfirst: if True then uses the DD/MM international/European date format (This
 is False by default)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
thousands: specifies the thousands separator. If not None, this character
 will be stripped from numeric dtypes. However, if it is the first character
 in a field, that column will be imported as a string. In the PythonParser,
 if not None, then parser will try to look for it in the output and parse
 relevant data to numeric dtypes. Because it has to essentially scan through
 the data again, this causes a significant performance hit so only use if
 necessary.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
lineterminator : string (length 1), default None, Character to break file into
 lines. Only valid with C parser
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
quotechar : string, The character to used to denote the start and end of a
 quoted item. Quoted items can include the delimiter and it will be ignored.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
quoting : int, Controls whether quotes should be recognized. Values are taken
 from csv.QUOTE_* values. Acceptable values are 0, 1, 2, and 3 for QUOTE_MINIMAL,
 QUOTE_ALL, QUOTE_NONNUMERIC and QUOTE_NONE, respectively.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
skipinitialspace : boolean, default False, Skip spaces after delimiter
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
escapechar : string, to specify how to escape quoted data
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
comment: Indicates remainder of line should not be parsed. If found at the
 beginning of a line, the line will be ignored altogether. This parameter
 must be a single character. Like empty lines, fully commented lines are
 ignored by the parameter header but not by skiprows. For example, if comment=’#’
, parsing ‘#emptyn1,2,3na,b,c’ with header=0 will result in ‘1,2,3’ being
 treated as the header.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
nrows: Number of rows to read out of the file. Useful to only read a small
 portion of a large file
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
iterator: If True, return a TextFileReader to enable reading a file into memory
 piece by piece
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
chunksize: An number of rows to be used to “chunk” a file into pieces. Will
 cause an TextFileReader object to be returned. More on this below in the
 section on iterating and chunking
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
skip_footer: number of lines to skip at bottom of file (default 0) (Unsupported 
with engine='c')
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
converters: a dictionary of functions for converting values in certain columns, 
where keys are either integers or column labels
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
encoding: a string representing the encoding to use for decoding unicode data,
 e.g. 'utf-8` or 'latin-1'. Full list of Python standard encodings
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
verbose: show number of NA values inserted in non-numeric columns
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
squeeze: if True then output with only one column is turned into Series
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
error_bad_lines: if False then any lines causing an error will be skipped bad
 lines
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
usecols: a subset of columns to return, results in much faster parsing time and
 lower memory usage.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
mangle_dupe_cols: boolean, default True, then duplicate columns will be specifie
d as ‘X.0’...’X.N’, rather than ‘X’...’X’
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
tupleize_cols: boolean, default False, if False, convert a list of tuples to
 a multi-index of columns, otherwise, leave the column index as a list of
 tuples
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
float_precision : string, default None. Specifies which converter the C engine
 should use for floating-point values. The options are None for the ordinary
 converter, ‘high’ for the high-precision converter, and ‘round_trip’ for
 the round-trip converter.
\end_layout

\begin_layout Subsection
read_excel
\end_layout

\begin_layout Itemize
io : string, file-like object, pandas ExcelFile, or xlrd workbook. The string
 could be a URL. Valid URL schemes include http, ftp, s3, and file. For file
 URLs, a host is expected. For instance, a local file could be file://localhost/p
ath/to/workbook.xlsx
\end_layout

\begin_layout Itemize
sheetname : string, int, mixed list of strings/ints, or None, default 0
\end_layout

\begin_deeper
\begin_layout Standard
Strings are used for sheet names, Integers are used in zero-indexed sheet positi
ons.
\end_layout

\begin_layout Standard
Lists of strings/integers are used to request multiple sheets.
\end_layout

\begin_layout Standard
Specify None to get all sheets.
\end_layout

\begin_layout Standard
str|int -> DataFrame is returned. list|None -> Dict of DataFrames is returned,
 with keys representing sheets.
\end_layout

\begin_layout Standard
Available Cases
\end_layout

\begin_layout Standard
Defaults to 0 -> 1st sheet as a DataFrame
\end_layout

\begin_layout Standard
1 -> 2nd sheet as a DataFrame
\end_layout

\begin_layout Standard
“Sheet1” -> 1st sheet as a DataFrame
\end_layout

\begin_layout Standard
[0,1,”Sheet5”] -> 1st, 2nd & 5th sheet as a dictionary of DataFrames
\end_layout

\begin_layout Standard
None -> All sheets as a dictionary of DataFrames
\end_layout

\end_deeper
\begin_layout Itemize
header : int, list of ints, default 0
\end_layout

\begin_deeper
\begin_layout Standard
Row (0-indexed) to use for the column labels of the parsed DataFrame. If
 a list of integers is passed those row positions will be combined into a
 MultiIndex
\end_layout

\end_deeper
\begin_layout Itemize
skiprows : list-like
\end_layout

\begin_deeper
\begin_layout Standard
Rows to skip at the beginning (0-indexed)
\end_layout

\end_deeper
\begin_layout Itemize
skip_footer : int, default 0
\end_layout

\begin_deeper
\begin_layout Standard
Rows at the end to skip (0-indexed)
\end_layout

\end_deeper
\begin_layout Itemize
index_col : int, list of ints, default None
\end_layout

\begin_deeper
\begin_layout Standard
Column (0-indexed) to use as the row labels of the DataFrame. Pass None if
 there is no such column. If a list is passed, those columns will be combined
 into a MultiIndex
\end_layout

\end_deeper
\begin_layout Itemize
converters : dict, default None
\end_layout

\begin_deeper
\begin_layout Standard
Dict of functions for converting values in certain columns. Keys can either
 be integers or column labels, values are functions that take one input
 argument, the Excel cell content, and return the transformed content.
\end_layout

\end_deeper
\begin_layout Itemize
parse_cols : int or list, default None
\end_layout

\begin_deeper
\begin_layout Standard
If None then parse all columns,
\end_layout

\begin_layout Standard
If int then indicates last column to be parsed
\end_layout

\begin_layout Standard
If list of ints then indicates list of column numbers to be parsed
\end_layout

\begin_layout Standard
If string then indicates comma separated list of column names and column ranges
 (e.g. “A:E” or “A,C,E:F”)
\end_layout

\end_deeper
\begin_layout Itemize
na_values : list-like, default None
\end_layout

\begin_deeper
\begin_layout Standard
List of additional strings to recognize as NA/NaN
\end_layout

\end_deeper
\begin_layout Subsection
DataFrame.to_csv()
\end_layout

\begin_layout Standard
Writing to CSV format
\end_layout

\begin_layout Standard
The Series and DataFrame objects have an instance method to_csv which allows sto
ring the contents of the object as a comma-separated-values file. The function
 takes a number of arguments. Only the first is required.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
path_or_buf: A string path to the file to write or a StringIO
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
sep : Field delimiter for the output file (default ”,”)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
na_rep: A string representation of a missing value (default ‘’)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
float_format: Format string for floating point numbers
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
cols: Columns to write (default None)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
header: Whether to write out the column names (default True)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
index: whether to write row (index) names (default True)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
index_label: Column label(s) for index column(s) if desired. If None (default),
 and header and index are True, then the index names are used. (A sequence
 should be given if the DataFrame uses MultiIndex).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
mode : Python write mode, default ‘w’
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
encoding: a string representing the encoding to use if the contents are non-ASCI
I, for python versions prior to 3
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
line_terminator: Character sequence denoting line end (default ‘
\backslash
n’)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
quoting: Set quoting rules as in csv module (default csv.QUOTE_MINIMAL)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
quotechar: Character used to quote fields (default ‘”’)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
doublequote: Control quoting of quotechar in fields (default True)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
escapechar: Character used to escape sep and quotechar when appropriate (default
 None)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
chunksize: Number of rows to write at a time
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
tupleize_cols: If False (default), write as a list of tuples, otherwise write
 in an expanded line format suitable for read_csv
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
date_format: Format string for datetime objects
\end_layout

\begin_layout Part
Debug and Help
\end_layout

\begin_layout Section
Common Bugs for R users
\end_layout

\begin_layout Itemize
forget
\series bold
colon
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset


\series default
 in def, class, lambda
\end_layout

\begin_layout Section
Debug
\end_layout

\begin_layout Subsection

\series bold
Exceptions vs Error: fatal bug
\end_layout

\begin_layout Itemize

\series bold
Error is a fatal bug, exception is not fatal
\end_layout

\begin_layout Itemize
both
\series bold
exception and Error are named with suffix Error in python
\end_layout

\begin_layout Itemize
Even if a statement or expression is syntactically correct, it may cause an
 error when an attempt is made to execute it. Errors detected during execution
 are called
\emph on
exceptions
\emph default
 and are not unconditionally fatal
\end_layout

\begin_layout Itemize
You don't name each class with 'Class' in name and each variable with '_variable
' in name.
 The same name you don't name exception using the word 'Exception'.
 The name should tell something about the meaning of the object.
 'Error' is the meaning of most of the exceptions.
\end_layout

\begin_layout Itemize
Not all Exceptions are Errors.
 SystemExit, KeyboardInterrupt, StopIteration, GeneratorExit are all exceptions
 and not errors.
 The word 'Error' in actual errors shows the difference.
\end_layout

\begin_layout Itemize
Because exceptions should be classes, the class naming convention applies
 here.
 However, you should use the suffix "Error" on your exception names (if
 the exception actually is an error).
\end_layout

\begin_layout Itemize
'Error' is shorter than 'Exception'.
 Than can save a few characters in the code width with no loss in meaning.
 That makes some difference.
\end_layout

\begin_layout Subsection
error handling
\end_layout

\begin_layout Standard
They are processed by four statements we'll study in this part, note that
 the
\family typewriter
\series bold
try
\family default
 must be companioned with either
\family typewriter
except
\family default
 or
\family typewriter
finally
\family default
 or both
\end_layout

\begin_layout Itemize
try/except: ¨Catch and recover from exceptions raised by Python, or by you. 
\end_layout

\begin_layout Itemize
try/finally:¨: Perform cleanup actions, whether exceptions occur or not. 
\end_layout

\begin_layout Itemize
raise: Trigger an exception manually in your code. 
\end_layout

\begin_layout Itemize
assert: Conditionally trigger an exception in your code. 
\end_layout

\begin_layout Itemize
with/as:¨Implement context managers in Python 2.6, 3.0, and later (optional in
 2.5). 
\end_layout

\begin_layout Subsection
try + except + else: Error handling & Continuing
\end_layout

\begin_layout Subsection
argument of exception
\end_layout

\begin_layout Itemize
When errors happen, if not in
\family typewriter
 try/exception
\family default
, then python will invoke the default exception handler, which simply prints
 the standard error message.
\end_layout

\begin_layout Itemize
If you don't want the default exception behavior, wrap the call in a
\family typewriter
try statement
\family default
 to catch exceptions yourself:
\end_layout

\begin_layout Itemize
An exception can have an argument:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

except ExceptionType, exception_assigment:
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
OR
\begin_inset ERT
status open

\begin_layout Plain Layout

except ExceptionType as exception_assigment:
\end_layout

\end_inset

 where you can assign the Exception to a type.
\end_layout

\end_deeper
\begin_layout Standard
Basic Syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

try:
\end_layout

\begin_layout Plain Layout

   You do your operations here;
\end_layout

\begin_layout Plain Layout

   ......................
\end_layout

\begin_layout Plain Layout

except ExceptionI:
\end_layout

\begin_layout Plain Layout

   If there is ExceptionI, then execute this block.
\end_layout

\begin_layout Plain Layout

except ExceptionII:
\end_layout

\begin_layout Plain Layout

   If there is ExceptionII, then execute this block.
\end_layout

\begin_layout Plain Layout

   ......................
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

   If there is no exception then execute this block.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
catch and store a general error
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

try:
\end_layout

\begin_layout Plain Layout

    z = x/y
\end_layout

\begin_layout Plain Layout

except Exception as e:
\end_layout

\begin_layout Plain Layout

    print(e)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

integer division or modulo by zero
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try:
\end_layout

\begin_layout Plain Layout

    z = x/y
\end_layout

\begin_layout Plain Layout

except:
\end_layout

\begin_layout Plain Layout

    pass
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
store an error:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

(x,y) = (5,0)
\end_layout

\begin_layout Plain Layout

try:
\end_layout

\begin_layout Plain Layout

    z = x/y
\end_layout

\begin_layout Plain Layout

except ZeroDivisionError as e:
\end_layout

\begin_layout Plain Layout

    z = e
\end_layout

\begin_layout Plain Layout

# representation: "<exceptions.ZeroDivisionError instance at 0x817426c>"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print z
\end_layout

\begin_layout Plain Layout

# output: "integer division or modulo by zero"
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
catch a specific error type.
\end_layout

\begin_deeper
\begin_layout Itemize
ValueError
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# if enter a numeric value which is allowed in int(), the pass and "break"
 the loop
\end_layout

\begin_layout Plain Layout

# if enter a non-numeric value, then directly go to the "except" and then
 keep looping.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while True:
\end_layout

\begin_layout Plain Layout

    try:
\end_layout

\begin_layout Plain Layout

        x = int(raw_input('Please enter a number: '))
\end_layout

\begin_layout Plain Layout

        break
\end_layout

\begin_layout Plain Layout

    except ValueError:
\end_layout

\begin_layout Plain Layout

        print('That was no valid number.
 Try again...')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Please enter a number: M
\end_layout

\begin_layout Plain Layout

That was no valid number.
 Try again...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Please enter a number: 1
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
AttributeError
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def print_sorted(collection):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    try:
\end_layout

\begin_layout Plain Layout

        collection.sort()
\end_layout

\begin_layout Plain Layout

    except:
\end_layout

\begin_layout Plain Layout

        pass
\end_layout

\begin_layout Plain Layout

        print("AttributeError has passed here")
\end_layout

\begin_layout Plain Layout

    print(collection)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print_sorted([1, 3, 2])
\end_layout

\begin_layout Plain Layout

# no result
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [[1, 2, 3]18]:
\end_layout

\begin_layout Plain Layout

print_sorted(set((1, 3, 2)))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

exception has passed here
\end_layout

\begin_layout Plain Layout

set([1, 2, 3])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print_sorted('132')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

exception has passed here
\end_layout

\begin_layout Plain Layout

132
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
try + finally / try + except + finally
\end_layout

\begin_layout Itemize
finally is to execute code in the end no matter what.
\end_layout

\begin_layout Itemize
if not using finally, any thing after exception will not be run. 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [10]: try:
\end_layout

\begin_layout Plain Layout

   ....:     x = int(raw_input('Please enter a number: '))
\end_layout

\begin_layout Plain Layout

   ....: finally:
\end_layout

\begin_layout Plain Layout

   ....:     print('Thank you for your input')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Please enter a number: a
\end_layout

\begin_layout Plain Layout

Thank you for your input
\end_layout

\begin_layout Plain Layout

---------------------------------------------------------------------------
\end_layout

\begin_layout Plain Layout

ValueError: invalid literal for int() with base 10: 'a'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
try + except + finally
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

try:
\end_layout

\begin_layout Plain Layout

    z = x/y
\end_layout

\begin_layout Plain Layout

except Exception as e:
\end_layout

\begin_layout Plain Layout

    print(e)
\end_layout

\begin_layout Plain Layout

finally:
\end_layout

\begin_layout Plain Layout

    print('finally')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

integer division or modulo by zero
\end_layout

\begin_layout Plain Layout

finally
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Biuld-in Exceptions
\end_layout

\begin_layout Standard
https://docs.python.org/2/library/exceptions.html
\end_layout

\begin_layout Itemize
exception ValueError
\end_layout

\begin_deeper
\begin_layout Itemize
Raised when a built-in operation or function receives an argument that has the
 right type but an inappropriate value, and the situation is not described by
 a more precise exception such as IndexError.
\end_layout

\end_deeper
\begin_layout Itemize
exception AttributeError
\end_layout

\begin_deeper
\begin_layout Itemize
Raised when an attribute reference (see Attribute references) or assignment fail
s. (When an object does not support attribute references or attribute assignments
 at all, TypeError is raised.)
\end_layout

\end_deeper
\begin_layout Subsection
raise statement: Cause an exception
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

rase EXCEPTION('words')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For biuld-in exceptions, the constructor takes one argument, an error message—th
at is, a string explaining why the exception was raised.
 The resulting instance makes that message available as an attribute named
 .message.
 Example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> try:
\end_layout

\begin_layout Plain Layout

...
     raise ValueError('The day is too frabjous.')
\end_layout

\begin_layout Plain Layout

...
 except ValueError as x:
\end_layout

\begin_layout Plain Layout

...
     pass
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

>>> type(x)
\end_layout

\begin_layout Plain Layout

<type 'exceptions.ValueError'>
\end_layout

\begin_layout Plain Layout

>>> x.message
\end_layout

\begin_layout Plain Layout

'The day is too frabjous.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create your own exceptions, write a class that inherits from Exception
 and passes its argument to the parent constructor, as in this example.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> class VocationError(Exception):
\end_layout

\begin_layout Plain Layout

...
     def __init__(self, mismatch):
\end_layout

\begin_layout Plain Layout

...
         Exception.__init__(self, mismatch)
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

>>> try:
\end_layout

\begin_layout Plain Layout

...
     print "And now, the Vocational Guidance Counsellor Sketch."
\end_layout

\begin_layout Plain Layout

...
     raise VocationError("Does not have proper hat")
\end_layout

\begin_layout Plain Layout

...
     print "This print statement will not be reached."
\end_layout

\begin_layout Plain Layout

...
 except VocationError as problem:
\end_layout

\begin_layout Plain Layout

...
     print "Vocation problem: {0}".format(problem)
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

And now, the Vocational Guidance Counsellor Sketch.
\end_layout

\begin_layout Plain Layout

Vocation problem: Does not have proper hat
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OR
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class MyException(Exception):
\end_layout

\begin_layout Plain Layout

    def __init__(self, message):
\end_layout

\begin_layout Plain Layout

        Exception.__init__(self, message)
\end_layout

\begin_layout Plain Layout

        self.message = message
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
assert statement
\end_layout

\begin_layout Standard
When it encounters an assert statement, Python evaluates the accompanying
 expression, which is hopefully true.
 If the expression is false, Python raises an AssertionError exception.
\end_layout

\begin_layout Standard
If the assertion fails, Python uses ArgumentExpression as the argument for
 the AssertionError.
 AssertionError exceptions can be caught and handled like any other exception
 using the try-except statement, but if not handled, they will terminate
 the program and produce a traceback.
\end_layout

\begin_layout Itemize
syntax: assert (True_or_False),
\begin_inset Quotes eld
\end_inset

words here
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def KelvinToFahrenheit(Temperature):
\end_layout

\begin_layout Plain Layout

    assert (Temperature >= 0),"Colder than absolute zero!"
\end_layout

\begin_layout Plain Layout

    return ((Temperature-273)*1.8)+32
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print KelvinToFahrenheit(273)
\end_layout

\begin_layout Plain Layout

32.0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print int(KelvinToFahrenheit(505.78))
\end_layout

\begin_layout Plain Layout

451
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print KelvinToFahrenheit(-5)
\end_layout

\begin_layout Plain Layout

AssertionError: Colder than absolute zero!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Help
\end_layout

\begin_layout Subsection

\series bold
docstrings: .__doc__
\end_layout

\begin_layout Standard
when you type help(foo), it will show up.
 It is the explanation of an function.
\end_layout

\begin_layout Itemize
User-define for your own function:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

def foo():
\end_layout

\begin_layout Plain Layout

	""" docstrings """
\end_layout

\begin_layout Plain Layout

	code
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Built-in docstrings: Helps for packages, functions\SpecialChar \ldots{}
.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

print(int.__doc__)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# int(x[, base]) -  integer
\end_layout

\begin_layout Plain Layout

# Convert a string or number to an integer, if possible. A floating point
 argument will be truncated towards zero (this does not include a ...more text
 omitted... 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
The help Function
\end_layout

\begin_layout Standard
Only type the beginning of the function’s name and use tab completion to display
 the matching functions.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [204]: help np.v
\end_layout

\begin_layout Plain Layout

    np.vander np.vdot np.version np.void0 np.vstack
\end_layout

\begin_layout Plain Layout

    np.var np.vectorize np.void np.vsplit
\end_layout

\begin_layout Plain Layout

In [204]: help np.vander
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
help(...)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> help(sys)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Help on built-in module sys:
\end_layout

\begin_layout Plain Layout

NAME
\end_layout

\begin_layout Plain Layout

sys
\end_layout

\begin_layout Plain Layout

MODULE REFERENCE
\end_layout

\begin_layout Plain Layout

http://docs.python.org/3.3/library/sys
\end_layout

\begin_layout Plain Layout

...more omitted...
\end_layout

\begin_layout Plain Layout

DESCRIPTION
\end_layout

\begin_layout Plain Layout

This module
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
search completed function: In Ipython, the magical function %psearch search for
 objects matching patterns. This is useful if, for example, one does not
 know the exact name of a function.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [3]: import numpy as np
\end_layout

\begin_layout Plain Layout

In [4]: %psearch np.diag*
\end_layout

\begin_layout Plain Layout

np.diag
\end_layout

\begin_layout Plain Layout

np.diagflat
\end_layout

\begin_layout Plain Layout

np.diagonal
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Part
Files
\end_layout

\begin_layout Itemize
File objects are Python code's main interface to external files on your computer.
 They can be used to read and write text memos, audio clips, Excel documents, sa
ved email messages, and whatever else you happen to have stored on your machine.
\end_layout

\begin_layout Itemize
they're not numbers, sequences, or mappings, and they don't respond to expressio
n operators; they export only methods for common file-processing tasks.
\end_layout

\begin_layout Itemize
Depending on the operating system the file was created on, line endings are
 different. 
\end_layout

\begin_deeper
\begin_layout Itemize
On UNIX-like platforms it's
\backslash
n,
\end_layout

\begin_layout Itemize
Macs before OS X used
\backslash
r, and Windows uses
\backslash
r
\backslash
n. 
\end_layout

\begin_layout Itemize
So that Lines[i] == searchquery will not match for Mac or Windows line endings. f
ile.readline() can deal with all three, but because it keeps whatever line ending
s were there at the end of the line, the comparison will fail. This is solved
 by using str.strip(), which will strip the string of all whitespace at the
 beginning and the end, and compare a search pattern without the line ending
 to that:
\end_layout

\end_deeper
\begin_layout Itemize
output = open(r'C:
\backslash
spam', 'w') ---- Create output file ('w' means write)
\end_layout

\begin_layout Itemize
input = open('data', 'r') ---- Create input file ('r' means read)
\end_layout

\begin_layout Itemize
input = open('data') ---- Same as prior line ('r' is the default)
\end_layout

\begin_layout Itemize
aString = input.read() ---- Read entire file into a single string
\end_layout

\begin_layout Itemize
aString = input.read(N) Read up to next N characters (or bytes) ---- into
 a string
\end_layout

\begin_layout Itemize
aString = input.readline() ---- Read next line (including
\backslash
n newline) into a string
\end_layout

\begin_layout Itemize
aList = input.readlines() ---- Read entire file into list of line strings
 (with
\backslash
n)
\end_layout

\begin_layout Itemize
output.write(aString) ---- Write a string of characters (or bytes) into file
\end_layout

\begin_layout Itemize
output.writelines(aList) ---- Write all line strings in a list into file
\end_layout

\begin_layout Itemize
output.close() ---- Manual close (done for you when file is collected)
\end_layout

\begin_layout Itemize
output.flush() ---- Flush output buffer to disk without closing
\end_layout

\begin_layout Itemize
anyFile.seek(N) ---- Change file position to offset N for next operation
\end_layout

\begin_layout Itemize
for line in open('data') ----: use line File iterators read line by line
\end_layout

\begin_layout Itemize
open('f.txt', encoding='latin-1') ---- Python 3.X Unicode text files (str
 strings)
\end_layout

\begin_layout Itemize
open('f.bin', 'rb') ---- Python 3.X bytes files (bytes strings)
\end_layout

\begin_layout Itemize
codecs.open('f.txt', encoding='utf8') ---- Python 2.X Unicode text files (unicode
 strings)
\end_layout

\begin_layout Itemize
open('f.bin', 'rb') ---- Python 2.X bytes files (str strings)
\end_layout

\begin_layout Section
Open and Read
\end_layout

\begin_layout Subsection
Open and Create
\end_layout

\begin_layout Standard
# Make a new file in output mode ('w' is write)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

f = open('data.txt', 'w')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To read back what you just wrote, reopen the file in 'r' processing mod.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

open
\begin_inset Quotes erd
\end_inset

 serves as a link to a file residing on your machine.
\end_layout

\begin_layout Subsection
Second Argument in Open
\end_layout

\begin_layout Standard
Is processing mode:
\end_layout

\begin_layout Itemize
'r' to open for text input (the default). 
\end_layout

\begin_layout Itemize
'w' to create and open for text output. 
\end_layout

\begin_layout Itemize
'a' to open for appending text to the end (e.g., for adding to logfiles). The
 processing mode argument can specify additional options:
\end_layout

\begin_layout Itemize
b to the mode string allows for binary data (end-of-line translations and 3.X
 Unicode encodings are turned off). 
\end_layout

\begin_layout Itemize
'r+' is the canonical mode for reading and writing at the same time. This
 is not different from using the fopen() system call since file()/open() is
 just a tiny wrapper around this operating system call. 
\end_layout

\begin_layout Subsection
get text of: open(file_path).read()
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> f = open('data.txt')
\end_layout

\begin_layout Plain Layout

>>> text = f.read() 
\end_layout

\begin_layout Plain Layout

>>> text
\end_layout

\begin_layout Plain Layout

'Hello
\backslash
nworld
\backslash
n'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Read# Remove end-of-line
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> f = open('data.txt')
\end_layout

\begin_layout Plain Layout

>>> text = f.read() 
\end_layout

\begin_layout Plain Layout

>>> text
\end_layout

\begin_layout Plain Layout

'Hello
\backslash
nworld
\backslash
n'
\end_layout

\begin_layout Plain Layout

>>> print(text)
\end_layout

\begin_layout Plain Layout

Hello
\end_layout

\begin_layout Plain Layout

world
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Bytes and Text file in 3.o
\end_layout

\begin_layout Itemize
Text files represent content as normal str strings, perform Unicode encoding and
 decoding automatically, and perform end-of-line translation by default. 
\end_layout

\begin_layout Itemize
Binary files represent content as a special bytes string type and allow programs
 to access file content unaltered. 
\end_layout

\begin_layout Standard
If you need to handle internationalized applications or byte-oriented data, thou
gh, the distinction in 3.X impacts your code (usually for the better).
\end_layout

\begin_layout Subsection
file.readline() and deal with line end character `
\backslash
n'
\end_layout

\begin_layout Standard
Line read from file is always character.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

file.readline() # Run first time, read the first line
\end_layout

\begin_layout Plain Layout

file.readline() # Run second time, read the second line
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> line = F.readline()
\end_layout

\begin_layout Plain Layout

>>> line
\end_layout

\begin_layout Plain Layout

'Spam
\backslash
n'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
# Remove end-of-line
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> line.rstrip()
\end_layout

\begin_layout Plain Layout

'Spam'
\end_layout

\end_inset

# Returns empty string at end-of-file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> f.readline()
\end_layout

\begin_layout Plain Layout

''
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
For loop in file
\end_layout

\begin_layout Standard
P452
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

file = open('test.txt')
\end_layout

\begin_layout Plain Layout

while True:
\end_layout

\begin_layout Plain Layout

	line = file.readline() # Read line by line
\end_layout

\begin_layout Plain Layout

	if not line: break
\end_layout

\begin_layout Plain Layout

	print(line.rstrip()) # Line already has a
\backslash
n
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

file = open('test.txt', 'rb')
\end_layout

\begin_layout Plain Layout

while True:
\end_layout

\begin_layout Plain Layout

	chunk = file.read(10) # Read byte chunks: up to 10 bytes
\end_layout

\begin_layout Plain Layout

	if not chunk: break
\end_layout

\begin_layout Plain Layout

	print(chunk)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

file = open('test.txt')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

while True:
\end_layout

\begin_layout Plain Layout

	char = file.read(1) # Read by character
\end_layout

\begin_layout Plain Layout

	if not char: break # Empty string means end-of-file
\end_layout

\begin_layout Plain Layout

	print(char)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for char in open('test.txt').read():
\end_layout

\begin_layout Plain Layout

	print(char)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Read Large file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

for line in open('test.txt'): # Use iterators: best for text input
\end_layout

\begin_layout Plain Layout

print(line.rstrip())
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It works for arbitrarily large files because it doesn't load the entire file
 into memory all at once (like method
\emph on
readline
\emph default
). The iterator reads the file link by line.
\end_layout

\begin_layout Standard
So this version may also be the quickest, though I/O performance may vary per
 Python line and release.
\end_layout

\begin_layout Subsubsection
print() Read line by line for a file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

for line in open('script2.py'):
\end_layout

\begin_layout Plain Layout

... print(line.upper(), end=)
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

IMPORT SYS
\end_layout

\begin_layout Plain Layout

PRINT(SYS.PATH)
\end_layout

\begin_layout Plain Layout

X =2
\end_layout

\begin_layout Plain Layout

PRINT(X ** 32)
\end_layout

\begin_layout Plain Layout

end=
\end_layout

\end_inset


\end_layout

\begin_layout Standard
print uses end=
\begin_inset Quotes erd
\end_inset

 here to suppress adding a
\backslash
n, because line strings already have one
\end_layout

\begin_layout Section
write
\change_deleted -445235034 1463262805
 Open and Read
\change_inserted -445235034 1463262805
＝
\change_unchanged

\end_layout

\begin_layout Subsection
write to files
\end_layout

\begin_layout Standard
For text data:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> output_file = open('output.txt', 'w')
\end_layout

\begin_layout Plain Layout

>>> words = set(nltk.corpus.genesis.words('english-kjv.txt'))
\end_layout

\begin_layout Plain Layout

>>> for word in sorted(words):
\end_layout

\begin_layout Plain Layout

...
     print(word, file=output_file)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
for non text data, first transform to text
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_deleted -445235034 1463366464

 	
\change_inserted -445235034 1463366461

\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463366461

output_file = open('output.R', 'w')
\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463366461

\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463366461

print(rcode2, file=output_file)
\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463366461

output_file.close()
\end_layout

\begin_layout Plain Layout

\change_deleted -445235034 1463366461

\end_layout

\begin_layout Plain Layout

\change_deleted -445235034 1463366461

>>> len(words)
\end_layout

\begin_layout Plain Layout

\change_deleted -445235034 1463366461

2789
\end_layout

\begin_layout Plain Layout

\change_deleted -445235034 1463366461

>>> str(len(words))
\end_layout

\begin_layout Plain Layout

\change_deleted -445235034 1463366461

'2789'
\end_layout

\begin_layout Plain Layout

\change_deleted -445235034 1463366461

>>> print(str(len(words)), file=output_file)
\change_unchanged

\end_layout

\end_inset


\end_layout

\begin_layout Section
shutil 模块：高级文件操作
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import shutil
\end_layout

\begin_layout Plain Layout

import os
\end_layout

\end_inset


\end_layout

\begin_layout Standard
shutil 是 Python 中的高级文件操作模块。
\end_layout

\begin_layout Subsection
复制文件
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

with open("test.file", "w") as f:
\end_layout

\begin_layout Plain Layout

pass
\end_layout

\begin_layout Plain Layout

print "test.file" in os.listdir(os.curdir)
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
shutil.copy(src, dst) 将源文件复制到目标地址：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In [3]:
\end_layout

\begin_layout Plain Layout

shutil.copy("test.file", "test.copy.file")
\end_layout

\begin_layout Plain Layout

print "test.file" in os.listdir(os.curdir)
\end_layout

\begin_layout Plain Layout

print "test.copy.file" in os.listdir(os.curdir)
\end_layout

\begin_layout Plain Layout

True
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
如果目标地址中间的文件夹不存在则会报错：
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In [4]:
\end_layout

\begin_layout Plain Layout

try:
\end_layout

\begin_layout Plain Layout

shutil.copy("test.file", "my_test_dir/test.copy.file")
\end_layout

\begin_layout Plain Layout

except IOError as msg:
\end_layout

\begin_layout Plain Layout

print msg
\end_layout

\begin_layout Plain Layout

[Errno 2] No such file or directory: 'my_test_dir/test.copy.file'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
另外的一个函数 shutil.copyfile(src, dst) 与 shutil.copy 使用方法一致，不过只是简单复制文件的内容，并不会复制文件本身的读写可
执行权限，而 shutil.copy 则是完全复制。
\end_layout

\begin_layout Subsection
复制文件夹
\end_layout

\begin_layout Standard
将文件转移到 test_dir 文件夹：
\end_layout

\begin_layout Standard
In [5]:
\end_layout

\begin_layout Standard
os.renames("test.file", "test_dir/test.file")
\end_layout

\begin_layout Standard
os.renames("test.copy.file", "test_dir/test.copy.file")
\end_layout

\begin_layout Standard
使用 shutil.copytree 来复制文件夹：
\end_layout

\begin_layout Standard
In [6]:
\end_layout

\begin_layout Standard
shutil.copytree("test_dir/", "test_dir_copy/")
\end_layout

\begin_layout Standard
"test_dir_copy" in os.listdir(os.curdir)
\end_layout

\begin_layout Standard
Out[6]:
\end_layout

\begin_layout Standard
True
\end_layout

\begin_layout Subsection
删除非空文件夹
\end_layout

\begin_layout Standard
os.removedirs 不能删除非空文件夹：
\end_layout

\begin_layout Standard
In [7]:
\end_layout

\begin_layout Standard
try:
\end_layout

\begin_layout Standard
os.removedirs("test_dir_copy")
\end_layout

\begin_layout Standard
except Exception as msg:
\end_layout

\begin_layout Standard
print msg
\end_layout

\begin_layout Standard
[Errno 39] Directory not empty: 'test_dir_copy'
\end_layout

\begin_layout Standard
使用 shutil.rmtree 来删除非空文件夹：
\end_layout

\begin_layout Standard
In [8]:
\end_layout

\begin_layout Standard
shutil.rmtree("test_dir_copy")
\end_layout

\begin_layout Subsection
移动文件夹
\end_layout

\begin_layout Standard
shutil.move 可以整体移动文件夹，与 os.rename 功能差不多。
\end_layout

\begin_layout Standard
产生压缩文件
\end_layout

\begin_layout Standard
查看支持的压缩文件格式：
\end_layout

\begin_layout Standard
In [9]:
\end_layout

\begin_layout Standard
shutil.get_archive_formats()
\end_layout

\begin_layout Standard
Out[9]:
\end_layout

\begin_layout Standard
[('bztar', "bzip2'ed tar-file"),
\end_layout

\begin_layout Standard
('gztar', "gzip'ed tar-file"),
\end_layout

\begin_layout Standard
('tar', 'uncompressed tar file'),
\end_layout

\begin_layout Standard
('zip', 'ZIP file')]
\end_layout

\begin_layout Subsection
产生压缩文件：
\end_layout

\begin_layout Standard
shutil.make_archive(basename, format, root_dir)
\end_layout

\begin_layout Standard
In [10]:
\end_layout

\begin_layout Standard
shutil.make_archive("test_archive", "zip", "test_dir/")
\end_layout

\begin_layout Standard
Out[10]:
\end_layout

\begin_layout Standard
'/home/lijin/notes-python/11.
 useful tools/test_archive.zip'
\end_layout

\begin_layout Standard
清理生成的文件和文件夹：
\end_layout

\begin_layout Standard
In [11]:
\end_layout

\begin_layout Standard
os.remove("test_archive.zip")
\end_layout

\begin_layout Standard
shutil.rmtree("test_dir/")
\end_layout

\begin_layout Standard
This website does not host notebooks, it only renders notebooks available
 on other websites.
\end_layout

\begin_layout Section
gzip, zipfile, tarfile 模块：处理压缩文件
\end_layout

\begin_layout Part
If and Loop
\end_layout

\begin_layout Section
IF Statement
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

if test1:
\end_layout

\begin_layout Plain Layout

    statements1
\end_layout

\begin_layout Plain Layout

elif test2:
\end_layout

\begin_layout Plain Layout

    statements2
\end_layout

\begin_layout Plain Layout

else: # Optional else
\end_layout

\begin_layout Plain Layout

    statements3
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Or
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 A= 't' if 'spam' else 'f'
\end_layout

\end_inset


\end_layout

\begin_layout Section
Loop :
\end_layout

\begin_layout Subsection
while
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

while test:
\end_layout

\begin_layout Plain Layout

    statement
\end_layout

\begin_layout Plain Layout

    if test: break
\end_layout

\begin_layout Plain Layout

    if test: continue
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    statement
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Optional Parts
\end_layout

\begin_layout Itemize
break: Jumps out of the closest enclosing loop (past the entire loop statement) 
\end_layout

\begin_layout Itemize
continue: Jumps to the top of the closest enclosing loop (to the loop's header
 line)
\end_layout

\begin_layout Itemize
pass: Does nothing at all: it's an empty statement placeholder
\end_layout

\begin_layout Itemize
Loop else block: Runs if and only if the loop is exited normally (i.e., without hi
tting a break)
\end_layout

\begin_layout Standard
Example
\end_layout

\begin_layout Standard
Use Continue to skip the odd number
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x = 10
\end_layout

\begin_layout Plain Layout

while x:
\end_layout

\begin_layout Plain Layout

    x = x-1
\end_layout

\begin_layout Plain Layout

    if x % 2 != 0: continue
\end_layout

\begin_layout Plain Layout

    print(x, end=' ')
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
for
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

for target in object: statements
\end_layout

\begin_layout Plain Layout

    if test: break
\end_layout

\begin_layout Plain Layout

    if test: continue
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

    statements
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Usage of Break, Continue and Statements can be found in `While'
\end_layout

\begin_layout Subsection
break and jump (continue)
\end_layout

\begin_layout Standard
break out of enclosing for/while loop:
\end_layout

\begin_layout Standard
>>>
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> z = 1 + 1j
\end_layout

\begin_layout Plain Layout

>>> while abs(z) 100:
\end_layout

\begin_layout Plain Layout

... if z.imag == 0:
\end_layout

\begin_layout Plain Layout

... break
\end_layout

\begin_layout Plain Layout

... z = z**2 + 1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
continue the next iteration of a loop.:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>
\end_layout

\begin_layout Plain Layout

>>> a = [1, 0, 2, 4]
\end_layout

\begin_layout Plain Layout

>>> for element in a:
\end_layout

\begin_layout Plain Layout

... if element == 0:
\end_layout

\begin_layout Plain Layout

... continue
\end_layout

\begin_layout Plain Layout

... print(1. / element)
\end_layout

\begin_layout Plain Layout

1.0
\end_layout

\begin_layout Plain Layout

0.5
\end_layout

\begin_layout Plain Layout

0.25
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Tuple/Dictionary/List assignment in 'for' loops
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

T = [(1, 2), (3, 4), (5, 6)]
\end_layout

\begin_layout Plain Layout

for (a, b) in T: # Tuple assignment at work
\end_layout

\begin_layout Plain Layout

    print(a, b)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

1 2
\end_layout

\begin_layout Plain Layout

3 4
\end_layout

\begin_layout Plain Layout

5 6
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Python 3.X extended sequence assignment in for loops
\end_layout

\begin_layout Section
(List) Comprehensions
\end_layout

\begin_layout Standard
In short, list comprehensions apply an arbitrary expression to items in an
 iterable, rather than applying a function.
\end_layout

\begin_layout Standard
Comprehensions might run much faster than manual for loop statements (often roug
hly twice as fast) because their iterations are performed at C language speed
 inside the interpreter, rather than with manual Python code.
\end_layout

\begin_layout Standard
Enable
\emph on
 for
\emph default
 loop on any iterable object.
\end_layout

\begin_layout Subsection
Comprehension Syntax: For General Use
\end_layout

\begin_layout Standard
Syntax: [Key_output or key expression for Key in Input]
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# Create a generator of row sums
\end_layout

\begin_layout Plain Layout

G = (sum(row) for row in M)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

next(G) # iter(G) not required here
\end_layout

\begin_layout Plain Layout

6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

next(G) # Run the iteration protocol next()
\end_layout

\begin_layout Plain Layout

15
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

next(G)
\end_layout

\begin_layout Plain Layout

24
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Comprehension : Filter clauses: if
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

lines = [line.rstrip() for line in open('script2.py') if line[0] == 'p']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lines
\end_layout

\begin_layout Plain Layout

# ['print(sys.path)'
\end_layout

\begin_layout Plain Layout

# 'print(x ** 32)']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Comprehension : Nested loops: for
\end_layout

\begin_layout Standard

\change_deleted 16419249 1456943359
 
\change_unchanged

\begin_inset ERT
status open

\begin_layout Plain Layout

[x + y for x in 'abc' for y in 'lmn']
\end_layout

\begin_layout Plain Layout

# ['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
List comprehensions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

diag = [M[i][i] for i in [0, 1, 2]]
\end_layout

\begin_layout Plain Layout

diag
\end_layout

\begin_layout Plain Layout

[1, 5, 9]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

doubles = [c * 2 for c in 'spam']
\end_layout

\begin_layout Plain Layout

doubles
\end_layout

\begin_layout Plain Layout

['ss', 'pp', 'aa', 'mm']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
# Here row is a special key, which can be directly used in nesting list
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

col2 = [row[1] for row in M]
\end_layout

\begin_layout Plain Layout

col2
\end_layout

\begin_layout Plain Layout

[2, 5, 8]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
# Comprehension with condition
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 [row[1] for row in M if row[1] % 2 == 0] # Filter out odd items
\end_layout

\begin_layout Plain Layout

[2, 8]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This matrix structure works for small-scale tasks, but for more serious number
 crunching you will probably want to use one of the numeric extensions to
 Python, such as the open source NumPy and SciPy systems.
\end_layout

\begin_layout Subsection
List comprehensions for files
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

lines = [line.rstrip() for line in open('script2.py')]
\end_layout

\begin_layout Plain Layout

lines
\end_layout

\begin_layout Plain Layout

# ['import sys', 'print(sys.path)', 'x = 2', 'print(x ** 32)']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
because most of this work is done inside the Python interpreter, it is fast!
\end_layout

\begin_layout Part
Functions
\end_layout

\begin_layout Itemize

\series bold
def
\series default
 is executable code/statement. Unlike functions in compiled languages such
 as C, def is an executable statement---your function does not exist until
 Python reaches and runs the def.
\end_layout

\begin_deeper
\begin_layout Itemize
It simply assigns a name at runtime (no compile time). The code inside defs
 is not evaluated until the functions are later called.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
return
\series default
: Note By default, functions return None. Functions can optionally return
 values.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [6]: def disk_area(radius):
\end_layout

\begin_layout Plain Layout

...: return 3.14 * radius * radius
\end_layout

\begin_layout Plain Layout

...:
\end_layout

\begin_layout Plain Layout

In [8]: disk_area(1.5)
\end_layout

\begin_layout Plain Layout

Out[8]: 7.0649999999999995
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
parameters
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
Mandatory parameters (positional arguments)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [81]: def double_it(x):
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Optional parameters
\series default
 (keyword or named arguments)
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [84]: def double_it(x=2):
\end_layout

\begin_layout Plain Layout

   ....:     return x * 2
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Principles of Coding a Function
\end_layout

\begin_layout Itemize
How your functions should communicate (called
\series bold
coupling
\series default
)
\end_layout

\begin_layout Itemize
How to decompose a task into purposeful functions (known as
\series bold
cohesion
\series default
)
\end_layout

\begin_layout Standard
In general though, you should strive to minimize external dependencies in functi
ons and other program components. The more self-contained a function is,
 the easier it will be to understand, reuse, and modify.
\end_layout

\begin_layout Itemize
Coupling: use global variables only when truly necessary. Global variables
 (i.e., names in the enclosing module) are usually a poor way for functions
 to communicate
\end_layout

\begin_layout Itemize
Coupling: don't change mutable arguments unless the caller expects it. 
\end_layout

\begin_layout Itemize
Size: each function should be relatively small.
\end_layout

\begin_layout Itemize
Cohesion: each function should have a single, unified purpose. 
\end_layout

\begin_layout Subsection
function def vs lambda
\end_layout

\begin_layout Itemize

\series bold
a def won't work inside a list literal like this because it is a statement
\end_layout

\begin_layout Itemize
lambda is an expression.
\end_layout

\begin_layout Subsection
Internal Functions
\end_layout

\begin_layout Standard
In 3.X, all function
\series bold
 internals' names
\series default
have leading and trailing double underscores (
\begin_inset Quotes eld
\end_inset

__X__
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Subsection
!! Function calls vs. Method call
\end_layout

\begin_layout Standard
In Python, you can use an expression as a statement, too---that is, on a line
 by itself.
\end_layout

\begin_layout Standard
For calls to functions and methods.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

spam(eggs, ham) # Function calls
\end_layout

\begin_layout Plain Layout

spam.ham(eggs) # Method calls
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Function calls are defined outside class using
\begin_inset Quotes eld
\end_inset

def
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Itemize
Method calls are defined inside class using
\begin_inset Quotes eld
\end_inset

def
\begin_inset Quotes erd
\end_inset

 
\end_layout

\begin_layout Subsection
view/change default arguments
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

inspect.getargspec(test).defaults
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[542]: def test(a, b,c = 2):
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
     return a+c
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

...
     inspect.getargspec(test)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[512]: ArgSpec(args=['a', 'b', 'c'], varargs=None, keywords=None, defaults=(2
,))
\end_layout

\begin_layout Plain Layout

In[545]: inspect.getargspec(test).args
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[513]: ['a', 'b', 'c']
\end_layout

\begin_layout Plain Layout

In[546]: inspect.getargspec(test).defaults
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[514]: (2,)
\end_layout

\end_inset


\end_layout

\begin_layout Section
flow control
\end_layout

\begin_layout Subsection
early return / early stop
\end_layout

\begin_layout Itemize
just put return in the middle, the function will just ignore the code afterwards
\end_layout

\begin_layout Itemize
early stop is just
\family typewriter
return Nore
\family default
 or just
\family typewriter
return
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def test(a):
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    if a == 1: return 'sadasdad'
\end_layout

\begin_layout Plain Layout

    sdadasdsa
\end_layout

\begin_layout Plain Layout

    dfsdaf
\end_layout

\begin_layout Plain Layout

    dfasf
\end_layout

\begin_layout Plain Layout

    return a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

test(1)
\end_layout

\begin_layout Plain Layout

Out[52]: 'sadasdad'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
return / without return (a procedure)
\end_layout

\begin_layout Standard
Functions such as this without a return are Python's equivalent of what are
 called
\begin_inset Quotes eld
\end_inset


\series bold
procedures
\series default

\begin_inset Quotes erd
\end_inset

 in some languages. They're usually invoked as statements, and the None results
 are ignored, as they do their business without computing a useful result.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [67]: def funcname(params):
\end_layout

\begin_layout Plain Layout

   ....:     """Concise one-line sentence describing the function.
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\begin_layout Plain Layout

   ....:     Extended summary which can contain multiple paragraphs.
\end_layout

\begin_layout Plain Layout

   ....:     """
\end_layout

\begin_layout Plain Layout

   ....:     # function body
\end_layout

\begin_layout Plain Layout

   ....:     pass
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [68]: funcname?
\end_layout

\begin_layout Plain Layout

Type:           function
\end_layout

\begin_layout Plain Layout

Base Class:     type 'function'>
\end_layout

\begin_layout Plain Layout

String Form:    function funcname at 0xeaa0f0>
\end_layout

\begin_layout Plain Layout

Namespace:      Interactive
\end_layout

\begin_layout Plain Layout

File:           ipython console>
\end_layout

\begin_layout Plain Layout

Definition:     funcname(params)
\end_layout

\begin_layout Plain Layout

Docstring:
\end_layout

\begin_layout Plain Layout

    Concise one-line sentence describing the function.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Extended summary which can contain multiple paragraphs.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Scope
\end_layout

\begin_layout Subsection
python detects locals statically??
\end_layout

\begin_layout Standard

\series bold
global
\series default
 declares module-level variables that are to be assigned.
\end_layout

\begin_layout Standard

\series bold
Python detects locals statically, when it compiles the def's code, rather than
 by noticing assignments as they happen at runtime. 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>def selector():
\end_layout

\begin_layout Plain Layout

    print(X) # Does not yet exist!
\end_layout

\begin_layout Plain Layout

    X = 88 # X classified as a local name (everywhere)
\end_layout

\begin_layout Plain Layout

    # Can also happen for "import X", "def X"...
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

>> selector()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

UnboundLocalError: local variable 'X' referenced before assignment
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

You get the name usage error shown here, but the reason is
\series bold
subtle
\series default
:
\end_layout

\begin_layout Standard
Python reads and compiles this code when it's typed interactively or imported fr
om a module. While compiling, Python sees the assignment to X and decides
 that X will be a local name everywhere in the function.
\end_layout

\begin_layout Subsection
Declare global inside function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [114]: x = 5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# to change x through a function
\end_layout

\begin_layout Plain Layout

# This doesn’t work:
\end_layout

\begin_layout Plain Layout

In [117]: def setx(y):
\end_layout

\begin_layout Plain Layout

   .....:     x = y
\end_layout

\begin_layout Plain Layout

   .....:     print('x is %d' % x)
\end_layout

\begin_layout Plain Layout

   .....:
\end_layout

\begin_layout Plain Layout

   .....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [118]: setx(10)
\end_layout

\begin_layout Plain Layout

x is 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [120]: x
\end_layout

\begin_layout Plain Layout

Out[120]: 5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# This works:
\end_layout

\begin_layout Plain Layout

In [121]: def setx(y):
\end_layout

\begin_layout Plain Layout

   .....:     global x
\end_layout

\begin_layout Plain Layout

   .....:     x = y
\end_layout

\begin_layout Plain Layout

   .....:     print('x is %d' % x)
\end_layout

\begin_layout Plain Layout

   .....:
\end_layout

\begin_layout Plain Layout

   .....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [122]: setx(10)
\end_layout

\begin_layout Plain Layout

x is 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [123]: x
\end_layout

\begin_layout Plain Layout

Out[123]: 10
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Outside values change through function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def try_to_modify(x, y, z):
\end_layout

\begin_layout Plain Layout

...     x = 23
\end_layout

\begin_layout Plain Layout

...     y.append(42)
\end_layout

\begin_layout Plain Layout

...     z = [99] # new reference
\end_layout

\begin_layout Plain Layout

...     print(x)
\end_layout

\begin_layout Plain Layout

...     print(y)
\end_layout

\begin_layout Plain Layout

...     print(z)
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> a = 77    # immutable variable
\end_layout

\begin_layout Plain Layout

>>> b = [99]  # mutable variable
\end_layout

\begin_layout Plain Layout

>>> c = [28]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> try_to_modify(a, b, c)
\end_layout

\begin_layout Plain Layout

23
\end_layout

\begin_layout Plain Layout

[99, 42]
\end_layout

\begin_layout Plain Layout

[99]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> print(a)
\end_layout

\begin_layout Plain Layout

77
\end_layout

\begin_layout Plain Layout

>>> print(b) # get changed by in plance change method .append()
\end_layout

\begin_layout Plain Layout

[99, 42]
\end_layout

\begin_layout Plain Layout

>>> print(c)
\end_layout

\begin_layout Plain Layout

[28]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Argument Matching Syntax
\end_layout

\begin_layout Standard
The steps that Python internally carries out to match arguments before assignmen
t can roughly be described as follows:
\end_layout

\begin_layout Enumerate
Assign nonkeyword arguments by position.
\end_layout

\begin_layout Enumerate
Assign keyword arguments by matching names.
\end_layout

\begin_layout Enumerate
Assign extra nonkeyword arguments to *name tuple.
\end_layout

\begin_layout Enumerate
Assign extra keyword arguments to **name dictionary.
\end_layout

\begin_layout Enumerate
Assign default values to unassigned arguments in header.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Syntax
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Location
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpretation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
func(value)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Caller
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Normal argument:  matched by position
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
func(name=value)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Caller
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Keyword argument:  matched by name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
func(*iterable)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Caller
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Pass all objects in iterable as individual positional arguments
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
func(**dict)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Caller
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Pass all key/value pairs in dict as individual keyword arguments
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
def func(name)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Normal argument:  matches any passed value by position or name
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
def func(name=value)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Default argument  value, if not passed in the call
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
def func(*name)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Matches and collects remaining positional arguments  in a tuple
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
def func(**name)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Matches and collects remaining keyword arguments  in a dictionary
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
def func(*other, name)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Arguments that must be passed by keyword only in calls (3.X)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
def func(*, name=value)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Arguments that must be passed by keyword only in calls (3.X)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection

\change_inserted -445235034 1463113822
non-default argument cannot follow default argument
\end_layout

\begin_layout Subsection
*argus: Collection Arguments (tuple / dictionary): like ... in R
\end_layout

\begin_layout Standard
Using a *iterable or **dict in a call allows us to package up
\series bold
 arbitrarily many positional or keyword objects in sequences
\series default
 (and other iterables) and dictionaries, respectively, and
\series bold
 unpack them as separate, individual arguments
\series default
 when they are passed to the function.
\end_layout

\begin_layout Standard
This sort of code is convenient when you cannot predict the number of arguments 
that will be passed to a function when you write your script; you can build up
 a collection of arguments at runtime instead and call the function generically
 this way.
\end_layout

\begin_layout Standard

\series bold
Headers: Collecting arguments
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def f(*args): print(args)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Python collects all the positional arguments into a new tuple and assigns the
 variable args to that tuple.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> f()
\end_layout

\begin_layout Plain Layout

() 
\end_layout

\begin_layout Plain Layout

>>> f(1)
\end_layout

\begin_layout Plain Layout

(1,)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> f(1, 2, 3, 4)
\end_layout

\begin_layout Plain Layout

(1, 2, 3, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
*argus is an iterator
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def test_var_args(f_arg, *argv):
\end_layout

\begin_layout Plain Layout

    print "first normal arg:", f_arg
\end_layout

\begin_layout Plain Layout

    for arg in argv:
\end_layout

\begin_layout Plain Layout

        print "another arg through *argv :", arg
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

test_var_args('yasoob','python','eggs','test')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## This produces the following result:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

first normal arg: yasoob
\end_layout

\begin_layout Plain Layout

another arg through *argv : python
\end_layout

\begin_layout Plain Layout

another arg through *argv : eggs
\end_layout

\begin_layout Plain Layout

another arg through *argv : test
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def cbind(*args):
\end_layout

\begin_layout Plain Layout

    arg_list = []
\end_layout

\begin_layout Plain Layout

    for i in args:
\end_layout

\begin_layout Plain Layout

        arg_list = arg_list + [i]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    arg_list[0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    print(arg_list[1])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cbind('a','b',2)
\end_layout

\begin_layout Plain Layout

# b
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
**kwargs: pass keyworded variable length of arguments to a function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def greet_me(**kwargs):
\end_layout

\begin_layout Plain Layout

    if kwargs is not None:
\end_layout

\begin_layout Plain Layout

        for key, value in kwargs.iteritems():
\end_layout

\begin_layout Plain Layout

            print "%s == %s" %(key,value)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> greet_me(name="yasoob")
\end_layout

\begin_layout Plain Layout

name == yasoob
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Calls: Unpacking arguments
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def func(a, b, c, d): print(a, b, c, d)
\end_layout

\begin_layout Plain Layout

>>> args = (1, 2) 
\end_layout

\begin_layout Plain Layout

>>> args += (3, 4)
\end_layout

\begin_layout Plain Layout

 >>> func(*args) # Same as func(1, 2, 3, 4)
\end_layout

\begin_layout Plain Layout

12 3 4
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
**arg: convert from keywords to dictionaries,
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def f(**args): print(args)
\end_layout

\begin_layout Plain Layout

 >>> f(a=1, b=2)
\end_layout

\begin_layout Plain Layout

{'a': 1, 'b': 2}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Python 3.X Keyword-Only Arguments
\end_layout

\begin_layout Standard
keyword-only arguments must be specified after a single star, not two ---named a
rguments cannot appear after the **args arbitrary keywords form, and a **
 can't appear by itself in the arguments list.
\end_layout

\begin_layout Standard
This means that in a function header, keyword-only arguments must be coded befor
e the **args arbitrary keywords form and after the *args arbitrary positional
 form, when both are present.
\end_layout

\begin_layout Standard

\change_deleted 16419249 1456943359
    
\change_unchanged
def kwonly(a, *b, c): print(a, b, c)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def kwonly(a, *b, c): print(a, b, c)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
a may be passed by name or position,
\end_layout

\begin_layout Itemize
b collects any extra positional arguments,
\end_layout

\begin_layout Itemize
and c must be passed by keyword only.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def kwonly(a, *b, c): print(a, b, c)
\end_layout

\begin_layout Plain Layout

>>> kwonly(1, 2, c=3)
\end_layout

\begin_layout Plain Layout

1 (2,) 3 
\end_layout

\begin_layout Plain Layout

>>> kwonly(a=1, c=3)
\end_layout

\begin_layout Plain Layout

1 () 3
\end_layout

\begin_layout Plain Layout

>>> kwonly(1, 2, 3)
\end_layout

\begin_layout Plain Layout

TypeError: kwonly() missing 1 required keyword-only argument: 'c'
\end_layout

\begin_layout Plain Layout

>>> def kwonly(a, *, b, c): print(a, b, c)
\end_layout

\begin_layout Plain Layout

>>> kwonly(1, c=3, b=2) 1 23 
\end_layout

\begin_layout Plain Layout

>>> kwonly(c=3, b=2, a=1) 1 23
\end_layout

\begin_layout Plain Layout

>>> kwonly(1, 2, 3) 
\end_layout

\begin_layout Plain Layout

TypeError: kwonly() takes 1 positional argument but 3 were given
\end_layout

\end_inset


\end_layout

\begin_layout Section
Recursive Functions: call itself inside itself ??
\end_layout

\begin_layout Standard
It allows programs to traverse structures that
\series bold
have arbitrary and unpredictable shapes and depths
\series default
 --- planning travel routes, analyzing language, and crawling links on the Web,
 for example.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def mysum(L):
\end_layout

\begin_layout Plain Layout

		print(L) # Trace recursive levels
\end_layout

\begin_layout Plain Layout

		if not L: # L shorter at each level
\end_layout

\begin_layout Plain Layout

			return 0
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			return L[0] + mysum(L[1:])
\end_layout

\begin_layout Plain Layout

>>> mysum([1, 2, 3, 4, 5])
\end_layout

\begin_layout Plain Layout

[1, 2, 3, 4, 5]
\end_layout

\begin_layout Plain Layout

[2, 3, 4, 5]
\end_layout

\begin_layout Plain Layout

[3, 4, 5]
\end_layout

\begin_layout Plain Layout

[4, 5]
\end_layout

\begin_layout Plain Layout

[5]
\end_layout

\begin_layout Plain Layout

[]
\end_layout

\begin_layout Plain Layout

15
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each open level of call to the function has its own copy of the function's local
 scope on the runtime
\series bold
call stack
\series default
---here, that means L is different in each level.
\end_layout

\begin_layout Standard
[1, [2, [3, 4], 5], 6, [7, 8]] # Arbitrarily nested sublists
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def sumtree(L):
\end_layout

\begin_layout Plain Layout

    tot = 0
\end_layout

\begin_layout Plain Layout

    for x in L:
\end_layout

\begin_layout Plain Layout

        print(type(x))
\end_layout

\begin_layout Plain Layout

        if not isinstance(x, list):
\end_layout

\begin_layout Plain Layout

        # if it is a int, then run below, if it is a list, then not
\end_layout

\begin_layout Plain Layout

            tot += x
\end_layout

\begin_layout Plain Layout

            print("condition 1")
\end_layout

\begin_layout Plain Layout

            print(tot)
\end_layout

\begin_layout Plain Layout

            print("-------")
\end_layout

\begin_layout Plain Layout

        else:
\end_layout

\begin_layout Plain Layout

            print("condition 2")
\end_layout

\begin_layout Plain Layout

            tot += sumtree(x)
\end_layout

\begin_layout Plain Layout

            print("-------")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            # here it does not mean it will re-run the sumtree function
\end_layout

\begin_layout Plain Layout

            # it just means it will assign the result of sumtree(x), which is
 tot, to tot
\end_layout

\begin_layout Plain Layout

            print("Not Show up until the last")
\end_layout

\begin_layout Plain Layout

    return tot
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

L = [1, 6, [7, 8]]
\end_layout

\begin_layout Plain Layout

print(sumtree(L))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type 'int'>
\end_layout

\begin_layout Plain Layout

condition 1
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

-------
\end_layout

\begin_layout Plain Layout

type 'int'>
\end_layout

\begin_layout Plain Layout

condition 1
\end_layout

\begin_layout Plain Layout

7
\end_layout

\begin_layout Plain Layout

-------
\end_layout

\begin_layout Plain Layout

type 'list'>
\end_layout

\begin_layout Plain Layout

condition 2
\end_layout

\begin_layout Plain Layout

type 'int'>
\end_layout

\begin_layout Plain Layout

condition 1
\end_layout

\begin_layout Plain Layout

7
\end_layout

\begin_layout Plain Layout

-------
\end_layout

\begin_layout Plain Layout

type 'int'>
\end_layout

\begin_layout Plain Layout

condition 1
\end_layout

\begin_layout Plain Layout

15
\end_layout

\begin_layout Plain Layout

-------
\end_layout

\begin_layout Plain Layout

-------
\end_layout

\begin_layout Plain Layout

Not Show up until the last
\end_layout

\begin_layout Plain Layout

22
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Time Lost in Recursion
\end_layout

\begin_layout Standard
With looping statements, we don't require a fresh copy of a local scope on
 the call stack for each iteration, and we avoid the speed costs associated with
 function calls in general.
\end_layout

\begin_layout Subsection
Non-hierarchical / Very Deep structure
\end_layout

\begin_layout Standard
Neither the recursive call nor the explicit queue/stack examples in this section
 do anything about avoiding cycles---visiting a location already visited. That's
 not required here, because we're traversing strictly hierarchical list
 object trees.
\end_layout

\begin_layout Standard
Also note that standard Python limits the depth of its runtime call stack---cruc
ial to recursive call programs---to trap infinite recursion errors. To expand
 it, use the sys module:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> sys.getrecursionlimit() 
\end_layout

\begin_layout Plain Layout

1000 
\end_layout

\begin_layout Plain Layout

>>> sys.setrecursionlimit(10000)
\end_layout

\begin_layout Plain Layout

>>> help(sys.setrecursionlimit)
\end_layout

\begin_layout Plain Layout

# 1000
\end_layout

\end_inset


\end_layout

\begin_layout Section
Function Objects: Attributes and Annotations
\end_layout

\begin_layout Standard
Functions are objects!
\end_layout

\begin_layout Standard
echo is a function, stored in list below.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> schedule = [ (echo, 'Spam!'), (echo, 'Ham!') ]
\end_layout

\begin_layout Plain Layout

>>> for (func, arg) in schedule:
\end_layout

\begin_layout Plain Layout

		func(arg) # Call functions embedded in containers
\end_layout

\begin_layout Plain Layout

Spam!
\end_layout

\begin_layout Plain Layout

Ham!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Function Annotations in 3.X
\end_layout

\begin_layout Standard
Annotations are completely optional, and when present are simply attached to
 the function object's __annotations__ attribute for use by other tools.
\end_layout

\begin_layout Standard
For instance, such a tool might use annotations in the context of error testing.
\end_layout

\begin_layout Section
Decorators
\end_layout

\begin_layout Standard
Since a function or a class are objects, they can be passed around. Since
 they are mutable objects, they can be modified. The act of altering a function
 or class object after it has been constructed but before is is bound to
 its name is called decorating.
\end_layout

\begin_layout Enumerate
this is the decorator function: its argument shall be a function
\end_layout

\begin_deeper
\begin_layout Itemize
# inside it you should define a wrap function
\end_layout

\begin_deeper
\begin_layout Itemize
# that takes any argument
\end_layout

\begin_layout Itemize
# change the behavior of a function
\end_layout

\begin_layout Itemize
# return the function fn
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def decorator_foo(fn):
\end_layout

\begin_layout Plain Layout

    print("begin decratoring")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    def to_be_decorated(*args, **kwargs):
\end_layout

\begin_layout Plain Layout

	# a warp function that takes any arguments
\end_layout

\begin_layout Plain Layout

        print ("Calling %s" % (fn.func_name))
\end_layout

\begin_layout Plain Layout

		print ("behavior of %s can be changed of here" % (fn.func_name))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        for i in args:
\end_layout

\begin_layout Plain Layout

            j = i
\end_layout

\begin_layout Plain Layout

        j = j*10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        return fn(j) #pass any arguments to fn()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        # return fn(*args, **kwargs) #pass any arguments to fn()
\end_layout

\begin_layout Plain Layout

    return to_be_decorated
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
begin decorating
\end_layout

\begin_deeper
\begin_layout Enumerate
you need to first
\series bold
@decorator
\end_layout

\begin_layout Enumerate
then define the decroatee function immediately.
 Thus the decroatee will be
\series bold
decorated
\series default
 by
\series bold
decorator
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@decorator_foo
\end_layout

\begin_layout Plain Layout

# that means the function defined immedietely afterwards
\end_layout

\begin_layout Plain Layout

# will go through print_call() and
\end_layout

\begin_layout Plain Layout

# thus be decorated
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#### begin decratoring
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def will_be_logged(arg):
\end_layout

\begin_layout Plain Layout

    return arg
\end_layout

\begin_layout Plain Layout

will_be_logged("!")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

###
\end_layout

\begin_layout Plain Layout

Calling will_be_logged
\end_layout

\begin_layout Plain Layout

behavior of will_be_logged can be changed of here
\end_layout

\begin_layout Plain Layout

Out[278]: '!!!!!!!!!!'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
name, module and docstring of the original function
\end_layout

\begin_layout Standard
At the end of the day decorators are just wrapping our functions, in case
 of debugging that can be problematic since the wrapper function does not
 carry the name, module and docstring of the original function.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

will_be_logged.__name__
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[281]: 'to_be_decorated'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Fortunately Python (as of version 2.5) includes the functools module which
 contains functools.wraps.
 Wraps is a decorator for updating the attributes of the wrapping function(func_
wrapper) to those of the original function(get_text).
 This is as simple as decorating func_wrapper by @wraps(func).
 Here is the updated example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from functools import wraps
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def tags(tag_name):
\end_layout

\begin_layout Plain Layout

    def tags_decorator(func):
\end_layout

\begin_layout Plain Layout

        @wraps(func)
\end_layout

\begin_layout Plain Layout

        def func_wrapper(name):
\end_layout

\begin_layout Plain Layout

            return "<{0}>{1}</{0}>".format(tag_name, func(name))
\end_layout

\begin_layout Plain Layout

        return func_wrapper
\end_layout

\begin_layout Plain Layout

    return tags_decorator
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@tags("p")
\end_layout

\begin_layout Plain Layout

def get_text(name):
\end_layout

\begin_layout Plain Layout

    """returns some text"""
\end_layout

\begin_layout Plain Layout

    return "Hello "+name
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print get_text.__name__ # get_text
\end_layout

\begin_layout Plain Layout

print get_text.__doc__ # returns some text
\end_layout

\begin_layout Plain Layout

print get_text.__module__ # __main__
\end_layout

\end_inset


\end_layout

\begin_layout Part
Class
\end_layout

\begin_layout Itemize

\series bold
Classes
\series default
: Serve as
\series bold
instance factories
\series default
. Their attributes provide behavior---data and functions ---that is inherited by
 all the instances generated from them (e.g., a function to compute an employee's
 salary from pay and hours). 
\end_layout

\begin_deeper
\begin_layout Itemize
Created as
\begin_inset ERT
status open

\begin_layout Plain Layout

Class FirstClass(): ...
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Instances
\series default
: Represent the concrete items in a program's domain. Their attributes record
\series bold
data
\series default
 that varies per specific object (e.g., an employee's Social Security number). Ever
y instance (objects) is in certain classes. 
\end_layout

\begin_deeper
\begin_layout Itemize
Created as
\begin_inset ERT
status open

\begin_layout Plain Layout

instance = Class()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
method:
\series default
functions within a calss: In python, method belongs to classes. In R, classes
 do not have method, only functions have method. 
\end_layout

\begin_deeper
\begin_layout Itemize
Created as
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

Class FirstClass():
\end_layout

\begin_layout Plain Layout

    def method(self)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
method call
\end_layout

\begin_layout Itemize

\series bold
Attributes
\series default
 are sub-instances that the parent instance has. What kind of attribute one
 instance can have is defined by Class.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Attributes attached to instances
\series default
 pertain only to those single instances. 
\end_layout

\begin_layout Itemize
But attributes attached to classes are shared by all their subclasses and instan
ces. 
\end_layout

\end_deeper
\begin_layout Subsection
add attibutes outside 
\family typewriter
def class
\end_layout

\begin_layout Standard
Python does not allow to add attribute to default classes, but does allow
 you to ad attribute in user-defined classes
\end_layout

\begin_layout Standard
It does not enforce what attributes you can store on user-defined classes.
\end_layout

\begin_layout Subsection
add method outside 
\family typewriter
def class
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

def foo(self,...):
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class.foo = foo
\end_layout

\end_inset


\end_layout

\begin_layout Section
Basic Syntax
\end_layout

\begin_layout Subsection
assign attributes to instance, call method
\end_layout

\begin_layout Subsection
Create a class + method
\end_layout

\begin_layout Enumerate
Assignments inside
\series bold
class's def statements
\series default
 make
\series bold
class attributes.
\series default
 After running a class statement,
\series bold
class attributes
\series default
 are accessed by name qualification
\series bold
:
\emph on
object
\emph default
.
\emph on
name
\emph default
.
\change_deleted 16419249 1456943359
 
\change_unchanged

\series default
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class FirstClass:
\end_layout

\begin_layout Plain Layout

    def setdata(self,value):
\end_layout

\begin_layout Plain Layout

        self.data = value # create an attribute to the instance
\end_layout

\begin_layout Plain Layout

    def display(self):
\end_layout

\begin_layout Plain Layout

        print(self.data) # a method # has to run .setdate first!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So each time we call method
\emph on
setdata
\emph default
, we assign attribute data to
\series bold
\emph on
instance
\series default
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
Functions inside a class are usually called
\series bold
methods
\series default
. They're coded with normal
\series bold
defs
\series default
. 
\end_layout

\begin_layout Subsection
self argument in method
\end_layout

\begin_layout Standard
The first argument (normally we name it
\series bold
self
\series default
) automatically receives
\series bold
an implied instance object
\series default
 when called---the subject of the call. When a def appears inside a class
 like this, it is usually known as a method, and it automatically receives
 a special first argument---called __self__ by convention---that provides
 a handle back to the instance to be processed.
\end_layout

\begin_layout Subsection
Create instance
\end_layout

\begin_layout Standard

\series bold
Create Instance by calling a class object
\series default
 like a function to create a new
\series bold
\emph on
instance
\series default
\emph default
. Each instance object inherits class attributes and gets its own namespace. 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x = FirstClass() # Make two instances
\end_layout

\begin_layout Plain Layout

y = FirstClass() # Each is a new namespace
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Create attributes
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

## direct create
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> x.data = "New value" # set attributes     
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> x.data
\end_layout

\begin_layout Plain Layout

'New value'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## create through a method that creates an attribute
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> x.setdata("new_value") # a redundent way to set attributes
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> x.data
\end_layout

\begin_layout Plain Layout

'new_value'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

y.setdata(3.14159)
\end_layout

\begin_layout Plain Layout

# Runs: FirstClass.setdata(y, 3.14159)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Method Calls: function that use 'self'
\end_layout

\begin_layout Standard
Definition of a
\series bold
method call
\series default
: When an attribute is a function, using _
\emph on
self
\emph default
_ as argument, then it is a method call
\end_layout

\begin_layout Standard
If this I2.w reference is a function call, what it really means is
\begin_inset Quotes eld
\end_inset

call the C3.w function to process I2.
\begin_inset Quotes erd
\end_inset

 That is, Python will automatically map the call
\series bold
I2.w()
\series default
 into the call
\series bold
C3.w(I2)
\series default
, passing in the instance as the first argument to the inherited function.
\end_layout

\begin_layout Subsection
define a method outside a class ??
\end_layout

\begin_layout Standard
Even we can create a method outside the class, just specify the argument as
 an instance under that class
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def uppername(obj):
\end_layout

\begin_layout Plain Layout

    return obj.name.upper() # Still needs a self argument (obj)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
special hooks : __init__, to initialize the instance and assign attributes at
 same time
\end_layout

\begin_layout Itemize
__init__ is run when a new instance object is created: self is the new ThirdClas
s object. 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class ThirdClass(SecondClass):
\end_layout

\begin_layout Plain Layout

    def __init__(self, value):
\end_layout

\begin_layout Plain Layout

        self.data = value 
\end_layout

\begin_layout Plain Layout

    def __add__(self, other):
\end_layout

\begin_layout Plain Layout

        return ThirdClass(self.data + other)
\end_layout

\begin_layout Plain Layout

    def __str__(self):
\end_layout

\begin_layout Plain Layout

        return '[ThirdClass: %s]' % self.data
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
__init__ enables to create the instance and to assign the attribute the same
 time. 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# No need a = ThirdClass() # to create instance first
\end_layout

\begin_layout Plain Layout

>>> a = ThirdClass('abc')
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Show the inheritance of method calls from SUPER
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a.display() 
\end_layout

\begin_layout Plain Layout

Current value = "abc"
\end_layout

\end_inset


\end_layout

\begin_layout Section
Inheritance / Structure of the Class Trees
\end_layout

\begin_layout Standard
A class tree, with
\end_layout

\begin_layout Itemize
two instances at the bottom (I1 and I2),
\end_layout

\begin_layout Itemize
a class above them (C1), with attributes .x and .y
\end_layout

\begin_layout Itemize
two superclasses at the top (C2 with .x and .z and C3 with .w and .z).
\end_layout

\begin_layout Standard
All of these objects are namespaces (packages of variables).
\end_layout

\begin_layout Standard
The
\series bold
inheritance search
\series default
 is simply a search of the tree from bottom to top looking for the lowest occurr
ence of an attribute name.
\end_layout

\begin_layout Itemize
I1.x and I2.x both find x in C1 and stop because C1 is lower than C2. 
\end_layout

\begin_layout Itemize
I1.y and I2.y both find y in C1 because that's the only place y appears. 
\end_layout

\begin_layout Itemize
I1.z and I2.z both find z in C2 because C2 is further to the left than C3. 
\end_layout

\begin_layout Itemize
I2.name finds name in I2 without climbing the tree at all. Trace these searches
 through the tree in Figure 26-1 to get a feel for how inheritance searches
 work in Python. 
\end_layout

\begin_layout Standard
Because C1 redefines the attribute
\begin_inset Formula $x$
\end_inset

 lower in the tree, it effectively replaces the version above it in C2. As
 you'll see in a moment, such redefinitions are at the heart of software customi
zation in OOP---by redefining and replacing the attribute,
\series bold
C1 effectively customizes what it inherits from its superclasses.
\end_layout

\begin_layout Subsection
Coding Class Trees
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class C2: ...
 # Make class objects (ovals)
\end_layout

\begin_layout Plain Layout

class C3: ...
\end_layout

\begin_layout Plain Layout

class C1(C2, C3): ...
 # Linked to superclasses (in this order)
\end_layout

\begin_layout Plain Layout

I1 = C1() # Make instance objects (rectangles)
\end_layout

\begin_layout Plain Layout

I2 = C1() # Linked to their classes
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
a Method in sub overwrites a method in Super
\end_layout

\begin_layout Subsection
Sub-class & overwriting
\end_layout

\begin_layout Itemize
Inherit of methods from super class to sub class: An instance under sub-class is
 at the same time an instance under Super -lass. So it inherits all methods
 of super-class
\end_layout

\begin_layout Itemize
Customize/Overwrite the method of super class: if an instance is created under
 SUB, then Method under SUB will override the same method of SUPER. Searching
 order enables this overloading. 
\end_layout

\begin_layout Itemize

\series bold
Polymorphism in Python: a method will behave differently for different objects. 
\end_layout

\begin_layout Enumerate
Create a subclass: Syntax is
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

class SecondClass(FirstClass): # Inherits setdata
\end_layout

\begin_layout Plain Layout

    def display(self): # Changes display  
\end_layout

\begin_layout Plain Layout

    print('Current value = "%s"' % self.data)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
See the effect, understand the method-searching logic: Here,
\series bold
\emph on
SecondClass
\series default
\emph default
 redefines and so
\series bold
customizes
\series default
 the
\begin_inset Quotes eld
\end_inset

display
\begin_inset Quotes erd
\end_inset

 method for its instances.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> z = SecondClass()    # create an instance under the subclass
\end_layout

\begin_layout Plain Layout

 >>> z.setdata(42) # Search setdata upward. Finds setdata in FirstClass 
\end_layout

\begin_layout Plain Layout

>>> z.display() # Search method upward. Finds overridden method in SecondClass
\end_layout

\begin_layout Plain Layout

Current value = "42"
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
In coding sub-class, you can also use method in SUPER
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class Manager(Person): 
\end_layout

\begin_layout Plain Layout

    def giveRaise(self, percent, bonus=.10):
\end_layout

\begin_layout Plain Layout

        Person.giveRaise(self, percent + bonus) # Good: augment original
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\series bold
Another Example
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class Employee: # General superclass
\end_layout

\begin_layout Plain Layout

	def computeSalary(self): ...
 # Common or default behaviors
\end_layout

\begin_layout Plain Layout

	def giveRaise(self): ...
\end_layout

\begin_layout Plain Layout

	def promote(self): ...
\end_layout

\begin_layout Plain Layout

	def retire(self): ...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
if engineers have a unique salary computation rule (perhaps it's not hours times
 rate), you can replace just that one method in a subclass:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class Engineer(Employee): # Specialized subclass, inherited from class
\end_layout

\begin_layout Plain Layout

# "Employee"
\end_layout

\begin_layout Plain Layout

    def computeSalary(self): ... # Something custom here
\end_layout

\end_inset

Because the computeSalary version here appears lower in the class tree, it
 will replace (override) the general version in Employee. You then create
 instances of the kinds of employee classes that the real employees belong
 to, to get the correct behavior:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

bob = Employee()
\end_layout

\begin_layout Plain Layout

sue = Employee()
\end_layout

\begin_layout Plain Layout

tom = Engineer()
\end_layout

\begin_layout Plain Layout

# Default behaviorâ¨# Default behaviorâ¨# Custom salary calculator
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

company = [bob, sue, tom] # A composite object
\end_layout

\begin_layout Plain Layout

for emp in company:
\end_layout

\begin_layout Plain Layout

    print(emp.computeSalary()) # Run this object's version: default or custom
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Multiple Inheritance
\end_layout

\begin_layout Standard
Python supports a limited form of multiple inheritance as well. A class definitio
n with multiple base classes looks like this::
\end_layout

\begin_layout Standard
class DerivedClassName(Base1, Base2, Base3):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class DerivedClassName(Base1, Base2, Base3):
\end_layout

\begin_layout Plain Layout

   statement-1>
\end_layout

\begin_layout Plain Layout

   .
\end_layout

\begin_layout Plain Layout

   .
\end_layout

\begin_layout Plain Layout

   statement-N>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
use class itself: super(type[, object-or-type]) ??
\end_layout

\begin_layout Standard
It looks like:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class C(B):
\end_layout

\begin_layout Plain Layout

    def method(self, arg):
\end_layout

\begin_layout Plain Layout

        super(C, self).method(arg)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Return a proxy object that delegates method calls to a parent or sibling class
 of type. (即在sub-class里面引用super class). This is useful for accessing inherited
 methods that have been overridden in a class. The search order is same as
 that used by
\begin_inset ERT
status open

\begin_layout Plain Layout

getattr()
\end_layout

\end_inset

except that the type itself is skipped..
\end_layout

\begin_layout Itemize
If the second argument is omitted, the super object returned is unbound. 
\end_layout

\begin_layout Itemize
引用自己所在class的attribute）If the second argument is an object, isinstance(obj, type)
 must be true. If the second argument is a type, issubclass(type2, type)
 must be true (this is useful for classmethods).
\end_layout

\begin_layout Standard
In a class hierarchy with single inheritance,
\emph on

\begin_inset ERT
status open

\begin_layout Plain Layout

super
\end_layout

\end_inset


\emph default
 can be used to refer to parent classes without naming them explicitly, thus
 making the code more maintainable. This use closely parallels the use of
\emph on
super
\emph default
 in other programming languages.
\end_layout

\begin_layout Subsection
Abstract Superclasses
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class Super: 
\end_layout

\begin_layout Plain Layout

    def method(self):
\end_layout

\begin_layout Plain Layout

        print('in Super.method')
\end_layout

\begin_layout Plain Layout

    def delegate(self):
\end_layout

\begin_layout Plain Layout

        self.action() # a blank/undefined method
\end_layout

\begin_layout Plain Layout

class Provider(Super):
\end_layout

\begin_layout Plain Layout

    def action(self): # filling a blank
\end_layout

\begin_layout Plain Layout

        print('in Provider.action')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This
\begin_inset Quotes eld
\end_inset

filling in the blanks
\begin_inset Quotes erd
\end_inset

 sort of coding structure is typical of OOP frameworks. In a more realistic
 context, the method filled in this way might handle an event in a GUI,
 provide data to be rendered as part of a web page, process a tag's text
 in an XML file,
\end_layout

\begin_layout Standard
called an abstract superclass---a class that expects parts of its behavior to
 be provided by its subclasses.
\end_layout

\begin_layout Subsection
Polymorphism in Class Behavior
\end_layout

\begin_layout Standard
This is yet another instance of the idea of polymorphism introduced in Chapter 4
 and expanded in Chapter 16.
\series bold
 Recall that polymorphism means that the meaning of an operation depends on
 the object being operated on. 
\series default
That is, code shouldn't care about what an object is, only about what it does
 (what method it has. In other words, methods/attributes define an object,
 not vice versa.). 
\end_layout

\begin_layout Standard
Here, the method computeSalary is located by inheritance search in each object
 before it is called. The net effect is that we automatically run the correct
 version for the object being processed. Trace the code to see why.
\end_layout

\begin_layout Subsection
type.__subclasses__() : return a list of subclasses
\end_layout

\begin_layout Standard
if no subclass, then return None
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[41]: np.generic.__subclasses__()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[41]: [numpy.number, numpy.flexible, numpy.bool_, numpy.datetime64, numpy.object_]
\end_layout

\begin_layout Plain Layout

In[42]: str.__subclasses__()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[42]: 
\end_layout

\begin_layout Plain Layout

[IPython.utils.text.LSString,
\end_layout

\begin_layout Plain Layout

 numpy.string_,
\end_layout

\begin_layout Plain Layout

 multiprocessing.process.AuthenticationString]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
subdtypes: return deep structure of all subclasses
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In [339]: def subdtypes(dtype):
\end_layout

\begin_layout Plain Layout

   .....:     subs = dtype.__subclasses__()
\end_layout

\begin_layout Plain Layout

   .....:     if not subs:
\end_layout

\begin_layout Plain Layout

   .....:         return dtype
\end_layout

\begin_layout Plain Layout

   .....:     return [dtype, [subdtypes(dt) for dt in subs]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In [340]: subdtypes(np.generic)
\end_layout

\begin_layout Plain Layout

Out[340]: 
\end_layout

\begin_layout Plain Layout

[numpy.generic,
\end_layout

\begin_layout Plain Layout

 [[numpy.number,
\end_layout

\begin_layout Plain Layout

   [[numpy.integer,
\end_layout

\begin_layout Plain Layout

     [[numpy.signedinteger,
\end_layout

\begin_layout Plain Layout

       [numpy.int8,
\end_layout

\begin_layout Plain Layout

        numpy.int16,
\end_layout

\begin_layout Plain Layout

        numpy.int32,
\end_layout

\begin_layout Plain Layout

        numpy.int64,
\end_layout

\begin_layout Plain Layout

        numpy.int64,
\end_layout

\begin_layout Plain Layout

        numpy.timedelta64]],
\end_layout

\begin_layout Plain Layout

      [numpy.unsignedinteger,
\end_layout

\begin_layout Plain Layout

       [numpy.uint8,
\end_layout

\begin_layout Plain Layout

        numpy.uint16,
\end_layout

\begin_layout Plain Layout

        numpy.uint32,
\end_layout

\begin_layout Plain Layout

        numpy.uint64,
\end_layout

\begin_layout Plain Layout

        numpy.uint64]]]],
\end_layout

\begin_layout Plain Layout

    [numpy.inexact,
\end_layout

\begin_layout Plain Layout

     [[numpy.floating,
\end_layout

\begin_layout Plain Layout

       [numpy.float16, numpy.float32, numpy.float64, numpy.float128]],
\end_layout

\begin_layout Plain Layout

      [numpy.complexfloating,
\end_layout

\begin_layout Plain Layout

       [numpy.complex64, numpy.complex128, numpy.complex256]]]]]],
\end_layout

\begin_layout Plain Layout

  [numpy.flexible,
\end_layout

\begin_layout Plain Layout

   [[numpy.character, [numpy.string_, numpy.unicode_]],
\end_layout

\begin_layout Plain Layout

    [numpy.void, [numpy.record]]]],
\end_layout

\begin_layout Plain Layout

  numpy.bool_,
\end_layout

\begin_layout Plain Layout

  numpy.datetime64,
\end_layout

\begin_layout Plain Layout

  numpy.object_]]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Private Attributes
\end_layout

\begin_layout Subsection
_xx, __xx
\end_layout

\begin_layout Itemize
_Attribute: One underline in the beginning
\end_layout

\begin_deeper
\begin_layout Itemize
Python doesn't have real private methods, so one underline in the beginning of
 a method or attribute means you shouldn't access this method, because it's
 not part of the API. It's very common when using properties:
\end_layout

\end_deeper
\begin_layout Itemize
__Attribute: Two underline in the beginning
\end_layout

\begin_deeper
\begin_layout Itemize
This one causes a lot of confusion. 
\series bold
It should not be used to mark a method as private, the goal here is to avoid you
r method to be overridden by a subclass
\series default
. 
\end_layout

\begin_layout Itemize
__Attribute defined in Super-Class will never be overwritten by sub class 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class A(object):
\end_layout

\begin_layout Plain Layout

    def __method(self):
\end_layout

\begin_layout Plain Layout

        print "I'm a method in A"
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def method(self):
\end_layout

\begin_layout Plain Layout

        self.__method()
\end_layout

\begin_layout Plain Layout

     
\end_layout

\begin_layout Plain Layout

a = A()
\end_layout

\begin_layout Plain Layout

a.method()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# I'm a method in A
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class B(A):
\end_layout

\begin_layout Plain Layout

    def __method(self): # CANNOT OVERWRITE __
\end_layout

\begin_layout Plain Layout

        print "I'm a method in B"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

b = B()
\end_layout

\begin_layout Plain Layout

b.method()
\end_layout

\begin_layout Plain Layout

# I'm a method in A
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class C(A):
\end_layout

\begin_layout Plain Layout

    def method(self): # CAN OVERWRITE normal methods in SUPER
\end_layout

\begin_layout Plain Layout

        print "I'm a method in C"
\end_layout

\begin_layout Plain Layout

c = C()
\end_layout

\begin_layout Plain Layout

c.method()
\end_layout

\begin_layout Plain Layout

# I'm a method in C
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
As you can see, A.method() didn't call B.__method() as we could expect. Actually
 this is the correct behavior for __. So when you create a method starting
 with __ you're saying that you don't want anybody to override it, it will
 be accessible just from inside the own class.
\end_layout

\begin_deeper
\begin_layout Itemize
How python does it? Simple, it just renames the method. Take a look:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> a.method()
\end_layout

\begin_layout Plain Layout

I'm a method in A
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> a.__method()
\end_layout

\begin_layout Plain Layout

AttributeError: 'A' object has no attribute '__method'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> a._A__method() # python change the name of __method to _Class__method!!
\end_layout

\begin_layout Plain Layout

I'm a method in A
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you try to access a.__method() it won't work either, as I said, __method is
 just accessible inside the class itself.
\end_layout

\end_deeper
\begin_layout Subsection
__attribute__: Two underlines in the beginning and in the end
\end_layout

\begin_layout Standard
When you see a method like __this__, the rule is simple: don't call it. Why?
 Because it means it's a method python calls, not you.
\end_layout

\begin_layout Standard
即这是python自定义的function的一种内在形式，和你无关。你只需要知道这些function的外在形式即可：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> name = "igor"
\end_layout

\begin_layout Plain Layout

>>> name.__len__()
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

>>> len(name) # you only need to know this form: len(), rather than __len__
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

>>> number = 10
\end_layout

\begin_layout Plain Layout

>>> number.__add__(20)
\end_layout

\begin_layout Plain Layout

30
\end_layout

\begin_layout Plain Layout

>>> number + 20
\end_layout

\begin_layout Plain Layout

30
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is always an operator or native function that calls these magic methods. Th
e idea here is to give you the ability to override operators in your own
 classes. Sometimes it's just a hook python calls in specific situations. __init__
(), for example, is called when the object is created so you can initialize
 it. __new__() is called to build the instance, and so on...
\end_layout

\begin_layout Standard
Here's an example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class CrazyNumber(object):
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def __init__(self, n):
\end_layout

\begin_layout Plain Layout

        self.n = n
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def __add__(self, other):
\end_layout

\begin_layout Plain Layout

        return self.n - other
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def __sub__(self, other):
\end_layout

\begin_layout Plain Layout

        return self.n + other
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    def __str__(self):
\end_layout

\begin_layout Plain Layout

        return str(self.n)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

num = CrazyNumber(10)
\end_layout

\begin_layout Plain Layout

print num           # 10
\end_layout

\begin_layout Plain Layout

print num + 5       # 5
\end_layout

\begin_layout Plain Layout

print num - 20      # 30
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Use default method
\end_layout

\begin_layout Description
__init__ Constructor Object creation: X = Class(args)
\end_layout

\begin_layout Description
__del__ Destructor Object reclamation of X
\end_layout

\begin_layout Description
__add__ Operator + X + Y, X += Y if no __iadd__
\end_layout

\begin_layout Description
__or__ Operator | (bitwise OR) X | Y, X |= Y if no __ior__
\end_layout

\begin_layout Description
__repr__, __str__ Printing, conversions print(X), repr(X), str(X)
\end_layout

\begin_layout Description
__call__ Function calls X(*args, **kargs)
\end_layout

\begin_layout Description
__getattr__ Attribute fetch X.undefined
\end_layout

\begin_layout Description
__setattr__ Attribute assignment X.any = value
\end_layout

\begin_layout Description
__delattr__ Attribute deletion del X.any
\end_layout

\begin_layout Description
__getattribute__ Attribute fetch X.any
\end_layout

\begin_layout Description
__getitem__ Indexing, slicing, iteration X[key], X[i:j], for loops and other
 iterations if no
\end_layout

\begin_layout Description
__iter__
\end_layout

\begin_layout Description
__setitem__ Index and slice assignment X[key] = value, X[i:j] = iterable
\end_layout

\begin_layout Description
__delitem__ Index and slice deletion del X[key], del X[i:j]
\end_layout

\begin_layout Description
__len__ Length len(X), truth tests if no __bool__
\end_layout

\begin_layout Description
__bool__ Boolean tests bool(X), truth tests (named __nonzero__ in 2.X)
\end_layout

\begin_layout Description
__lt__,__gt__, Comparisons X < Y, X > Y, X <= Y, X >= Y, X == Y, X != Y
 (or else __cmp__ in 2.X only)
\end_layout

\begin_layout Description
__le__,__ge__,
\end_layout

\begin_layout Description
__eq__,__ne__
\end_layout

\begin_layout Description
__radd__ Right-side operators Other + X
\end_layout

\begin_layout Description
__iadd__ In-place augmented operators X += Y (or else __add__)
\end_layout

\begin_layout Description
__iter__,__next__ Iteration contexts I=iter(X), next(I); for loops, in if
 no __contains__, all comprehensions, map(F,X), othersv(__next__ is named
 next in 2.X)
\end_layout

\begin_layout Description
__contains__ Membership test item in X (any iterable)
\end_layout

\begin_layout Description
__index__ Integer value hex(X), bin(X), oct(X), O[X], O[X:] (replaces 2.X
 __oct__, __hex__)
\end_layout

\begin_layout Description
__enter__,__exit__ Context manager (Chapter 34) with obj as var:
\end_layout

\begin_layout Description
__get__,__set__, Descriptor attributes (Chapter 38) X.attr, X.attr = value,
 del X.attr
\end_layout

\begin_layout Description
__delete__
\end_layout

\begin_layout Description
__new__ Creation (Chapter 40) Object creation, before __init__
\end_layout

\begin_layout Subsection
__str__ will enable us to use the default print method as return
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

class ThirdClass(SecondClass):
\end_layout

\begin_layout Plain Layout

    def __init__(self, value):
\end_layout

\begin_layout Plain Layout

        self.data = value 
\end_layout

\begin_layout Plain Layout

    def __add__(self, other):
\end_layout

\begin_layout Plain Layout

        return ThirdClass(self.data + other)
\end_layout

\begin_layout Plain Layout

    def __str__(self):
\end_layout

\begin_layout Plain Layout

        return '[ThirdClass: %s]' % self.data
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> print(a)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[ThirdClass: abc]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
__add__ will enable us to use the default
\begin_inset Quotes eld
\end_inset

+
\begin_inset Quotes erd
\end_inset

 method as return
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> b = a + 'xyz'
\end_layout

\begin_layout Plain Layout

 >>> b.display() 
\end_layout

\begin_layout Plain Layout

Current value = "abcxyz"
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Current value = "abcxyz"
\end_layout

\begin_layout Subsection
__mul__ will enable us to use the default
\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset

 method as return
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a.mul(3) 
\end_layout

\begin_layout Plain Layout

>>> print(a)
\end_layout

\begin_layout Plain Layout

[ThirdClass: abcabcabc]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Indexing and Slicing: __getitem__ and __setitem__ Operator Overloading
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> class Indexer: 
\end_layout

\begin_layout Plain Layout

def __getitem__(self, index):
\end_layout

\begin_layout Plain Layout

    return index ** 2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> X = Indexer()
\end_layout

\begin_layout Plain Layout

>>> X[2]
\end_layout

\begin_layout Plain Layout

 4
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Python 2.X only, classes can also define __getslice__ and __setslice__ methods
 to intercept slice fetches and assignments specifically.
\end_layout

\begin_layout Subsection
Operator Overloading: Iterable Objects: __iter__ and __next__ ??
\end_layout

\begin_layout Standard

\series bold
User-Defined Iterables
\end_layout

\begin_layout Section
Intercepts Attribute
\end_layout

\begin_layout Subsection
__getattr__ : intercepts attribute names
\end_layout

\begin_layout Itemize
The __getattr__ method intercepts attribute references.
\end_layout

\begin_layout Itemize
It's called with the
\series bold
attribute name as a string
\series default
, whenever you try to qualify an instance with an
\series bold
undefined (nonexistent)
\series default
attribute name.
\end_layout

\begin_layout Itemize
It is not called if Python can find the attribute using its inheritancetree sear
ch procedure.
\end_layout

\begin_layout Itemize
In fact,
\begin_inset ERT
status open

\begin_layout Plain Layout

getattr(X,N)
\end_layout

\end_inset

is similar to
\begin_inset ERT
status open

\begin_layout Plain Layout

X.__dict__[N]
\end_layout

\end_inset

, but the former also performs an inheritance search, like X.N, while thelatter d
oes not
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> class Empty: 
\end_layout

\begin_layout Plain Layout

def __getattr__(self, attrname):
\end_layout

\begin_layout Plain Layout

if attrname == 'age':
\end_layout

\begin_layout Plain Layout

return 40
\end_layout

\begin_layout Plain Layout

else:
\end_layout

\begin_layout Plain Layout

raise AttributeError(attrname)
\end_layout

\begin_layout Plain Layout

>>> X = Empty() 
\end_layout

\begin_layout Plain Layout

>>> X.age 
\end_layout

\begin_layout Plain Layout

40 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> X.name 
\end_layout

\begin_layout Plain Layout

...error text omitted...AttributeError: name
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Here, the Empty class and its instance X have no real attributes of theirown, so
 the access to X.age gets routed to the
\begin_inset ERT
status open

\begin_layout Plain Layout

__getattr__
\end_layout

\end_inset

method;
\end_layout

\begin_layout Itemize

\series bold
self
\series default
is assigned the instance (X), and
\series bold
attrname
\series default
is assigned the undefined attribute name string ('age').The class makes
\series bold
age
\series default
look like a real attribute by returning a real value as the result of theX.age qu
alification expression (40).
\end_layout

\begin_layout Itemize

\series bold
In effect, age becomes a dynamically computed attribute---its value is formedby 
running code, not fetching an object.
\end_layout

\begin_layout Itemize
For attributes not equal to `age', it also goes through __getattr__ .__getattr__ 
will raise AttributeError.
\end_layout

\begin_layout Subsection
__setattr__ intercepts all attribute assignments.
\end_layout

\begin_layout Standard
Even defined or those in other methods, and those to names other than thatwhich 
may have triggered
\begin_inset ERT
status open

\begin_layout Plain Layout

__setattr__
\end_layout

\end_inset

in the first place.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> class Accesscontrol:
\end_layout

\begin_layout Plain Layout

	def __setattr__(self, attr, value):
\end_layout

\begin_layout Plain Layout

		if attr == 'age':
\end_layout

\begin_layout Plain Layout

			self.__dict__[attr] = value + 10 # Not self.name=val or setattr
\end_layout

\begin_layout Plain Layout

		else:
\end_layout

\begin_layout Plain Layout

			raise AttributeError(attr + ' not allowed')
\end_layout

\begin_layout Plain Layout

>>> X = Accesscontrol()
\end_layout

\begin_layout Plain Layout

>>> X.age = 40 # Calls __setattr__
\end_layout

\begin_layout Plain Layout

>>> X.age
\end_layout

\begin_layout Plain Layout

50
\end_layout

\begin_layout Plain Layout

>>> X.name = 'Bob'
\end_layout

\begin_layout Plain Layout

...text omitted...
\end_layout

\begin_layout Plain Layout

AttributeError: name not allowed
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you write
\begin_inset ERT
status open

\begin_layout Plain Layout

self.age = value + 10 # Loops
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in you class method definition, then you incur infinite recursive loops.
\end_layout

\begin_layout Itemize
If you wish to use this method, you can avoid loops by coding instance attribute
assignments as assignments to attribute dictionary keys.That is, use
\begin_inset ERT
status open

\begin_layout Plain Layout

self.__dict__['name'] = x
\end_layout

\end_inset

, not
\begin_inset ERT
status open

\begin_layout Plain Layout

self.name = x
\end_layout

\end_inset

; because you're not assigning to
\begin_inset ERT
status open

\begin_layout Plain Layout

__dict__
\end_layout

\end_inset

itself, but just change name of key.This avoids the loop:
\end_layout

\begin_layout Subsection
_delattr__
\end_layout

\begin_layout Standard
P963
\end_layout

\begin_layout Standard
A third attribute management method, __delattr__, is passed the attributename st
ring and invoke don all attribute deletions (i.e.,
\begin_inset ERT
status open

\begin_layout Plain Layout

del object.attr
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsection
named tuple
\end_layout

\begin_layout Standard
Idea behind named tuple
\end_layout

\begin_layout Standard
As you can see, named tuples are a tuple/class/dictionary
\series bold
hybrid
\series default
.They also represent a classic
\series bold
tradeoff
\series default
.In exchange for their extra utility, they require extra code (the two startuplin
es in the preceding examples that import the type and make the class),and incur
 some performance costs to work this magic.(In short, named tuples build
 new classes that extend the tuple type, insertinga property
\series bold
accessor
\series default
method for each named field that maps the name to its position---a techniquethat
 relies on advanced topics we'll explore in Part VIII,
\end_layout

\begin_layout Section
check class/attributes
\end_layout

\begin_layout Subsection
Show/Decide/Check class:
\series bold
__class__, __name
\end_layout

\begin_layout Standard

\series bold
__class__, __name
\end_layout

\begin_layout Itemize
Each instance has a built-in __class__ attribute that references the classfrom w
hich it was created
\end_layout

\begin_layout Itemize
Each __class__ has a __name__ attribute that references the name in theheader 
\end_layout

\begin_layout Itemize
So the expression
\series bold
self.__class__.__name__
\series default
fetches the name of an instance's class.
\end_layout

\begin_deeper
\begin_layout Itemize
this is how we check class
\begin_inset ERT
status open

\begin_layout Plain Layout

"pineapple".__class__.__name__ == 'str'
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

# type will not return you a string! so it cannot be used in logics
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> type(L)
\end_layout

\begin_layout Plain Layout

class 'list'>
\end_layout

\begin_layout Plain Layout

>>> type(type(L))
\end_layout

\begin_layout Plain Layout

class 'type'>
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection

\series bold
isinstance(x, class): to decide whether x is certain class
\end_layout

\begin_layout Standard
isinstance(x, bool) # to decide whether its Boolean # no need to use
\begin_inset Quotes eld
\end_inset

bool
\begin_inset Quotes erd
\end_inset

as string
\end_layout

\begin_layout Subsection
hasattr() / getattr(object, name): check attribute existence
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

hasattr(self, "classes_"):
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Return whether the object has an attribute with the given name.
\end_layout

\begin_layout Standard
(This is done by calling
\begin_inset ERT
status open

\begin_layout Plain Layout

getattr(object, name)
\end_layout

\end_inset

and catching exceptions.
\end_layout

\begin_layout Subsection
dir(instance): get instance's attributes (and method)
\end_layout

\begin_layout Itemize
It returns a list of all the attributes available for any object passedto it.Beca
use methods are function attributes, they will show up in this list.
\end_layout

\begin_layout Itemize
The dir() does not try to provide a complete output, just a reasonable approxima
tion that is useful in the interactive interpreter.
\end_layout

\begin_deeper
\begin_layout Itemize
it will not return attributes in meta class that python thinks you will not
 use them
\end_layout

\begin_layout Itemize
If the object supplies a method named __dir__, it will be used
\end_layout

\end_deeper
\begin_layout Standard
Suppose
\begin_inset Quotes eld
\end_inset

S
\begin_inset Quotes erd
\end_inset

is a string
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

dir(S)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Double underscores are genetic methods (expressions).
 Some of them are the full name of the method we usually use:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S + 'NI!'
\end_layout

\begin_layout Plain Layout

'spamNI!'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 >>> S.__add__('NI!')
\end_layout

\begin_layout Plain Layout

'spamNI!'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.__dict__: dictionary of attributes
\end_layout

\begin_layout Standard
this attribute may not be defined. If it is defined, then dict() is the same
 as .__dict__
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> class rec: pass # Empty namespace object
\end_layout

\begin_layout Plain Layout

>>> rec.name = 'Bob' # Just objects with attributes
\end_layout

\begin_layout Plain Layout

>>> rec.age = 40
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> list(rec.__dict__.keys())
\end_layout

\begin_layout Plain Layout

 ['age', '__module__', '__qualname__', '__weakref__', 'name', '__dict__','__doc_
_']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> list(name for name in rec.__dict__ if not name.startswith('__'))
\end_layout

\begin_layout Plain Layout

['age', 'name']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Inherited class attributes are attached to the class only, not copied downto ins
tances.
\end_layout

\begin_layout Standard
还可以
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

self.__dict__[attr]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.__getattr__: a complete list of attributes. Not referable, only vieable
\end_layout

\begin_layout Subsection
type.__subclasses__(): show the subclasses as list
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[554]: np.generic.__subclasses__()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[552]: [numpy.number, numpy.flexible, numpy.bool_, numpy.datetime64, numpy.object_
]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
type.__bases__ : show the parant classes as tuple
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[555]: list(np.int8.__bases__)
\end_layout

\begin_layout Plain Layout

Out[553]: [numpy.signedinteger]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Type-Specific Methods vs Generic Methods
\end_layout

\begin_layout Standard
How to use:
\end_layout

\begin_layout Standard
As a rule of thumb, Python's toolset is layered:
\end_layout

\begin_layout Itemize
Generic operations (
\emph on
Expression
\emph default
) that span multiple types show up as built-in functions or expressions(e.g., 
\begin_inset ERT
status open

\begin_layout Plain Layout

len(X)
\end_layout

\end_inset

,
\begin_inset ERT
status open

\begin_layout Plain Layout

X[0]
\end_layout

\end_inset

),
\end_layout

\begin_layout Itemize
But type-specific operations are method calls (e.g., a
\begin_inset ERT
status open

\begin_layout Plain Layout

String.upper()
\end_layout

\end_inset

).
\end_layout

\begin_deeper
\begin_layout Itemize
Type-Specific Methods
\series bold
\shape smallcaps
\emph on
are functional attributes
\end_layout

\end_deeper
\begin_layout Section
Genetic Methods: Sequence Operations, the Generic Methods
\end_layout

\begin_layout Standard
How to use:
\end_layout

\begin_layout Standard
Method(Variable)
\end_layout

\begin_layout Subsection
In place change
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L = [1, 2]
\end_layout

\begin_layout Plain Layout

 >>> L.append(3) # Correct!! Append is an in-place change
\end_layout

\begin_layout Plain Layout

>>> L [1, 2, 3]
\end_layout

\begin_layout Plain Layout

>>> L = L.append(4) # Wrong!! append returns None, not L
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Calling an in-place change operation such as
\series bold
append, sort, or reverse
\series default
on a list always changes the list in place, but these methods do not returnthe l
ist they have changed; instead, they return the None object.
\end_layout

\begin_layout Part
Metaprogramming
\end_layout

\begin_layout Subsection
assign(object, 'name') :: globals()[name] = object
\end_layout

\begin_layout Standard
If you are in function
\end_layout

\begin_layout Subsection
eval(string) as expression
\end_layout

\begin_layout Standard
A built-in function that treats a string as a piece of executable programcode (t
echnically, a string containing a Python expression):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> parts 
\end_layout

\begin_layout Plain Layout

['[1, 2, 3]', "{'a': 1, 'b': 2}
\backslash
n"]
\end_layout

\begin_layout Plain Layout

>>> eval(parts[0]) 
\end_layout

\begin_layout Plain Layout

[1, 2, 3]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Code Objects
\end_layout

\begin_layout Standard
http://late.am/post/2012/03/26/exploring-python-code-objects.html
\end_layout

\begin_layout Standard
Code objects, then, are Python objects which represent some piece of bytecode,
 along with all that it needs to execute: a declaration of the expected
 argument types and counts, a list (not dictionary! more about which later)
 of locals, information about the source code from which the bytecode was
 generated (for debugging and printing stack traces), etc -- oh, and also
 (perhaps obviously), the bytecode itself, as a str (or, in Python3, bytes).
\end_layout

\begin_layout Itemize
make a code object
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> code_str = """
\end_layout

\begin_layout Plain Layout

...
 print "Hello, world"
\end_layout

\begin_layout Plain Layout

...
 """
\end_layout

\begin_layout Plain Layout

>>> code_obj = compile(code_str, '<string>', 'exec')
\end_layout

\begin_layout Plain Layout

>>> code_obj
\end_layout

\begin_layout Plain Layout

<code object <module> at 0x1054c74b0, file "<string>", line 2>
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
execute a code object
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> code_str = """
\end_layout

\begin_layout Plain Layout

...
 print "Hello, world"
\end_layout

\begin_layout Plain Layout

...
 print "Goodbye, world"
\end_layout

\begin_layout Plain Layout

...
 """
\end_layout

\begin_layout Plain Layout

>>> code_obj = compile(code_str, '<string>', 'single')
\end_layout

\begin_layout Plain Layout

>>> exec code_obj
\end_layout

\begin_layout Plain Layout

Hello, world
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
attributes of code objects
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

dir(code_obj)
\end_layout

\begin_layout Plain Layout

# dunder attributes excluded for readability
\end_layout

\begin_layout Plain Layout

['co_argcount', 'co_cellvars', 'co_code', 'co_consts', 'co_filename',
\end_layout

\begin_layout Plain Layout

 'co_firstlineno', 'co_flags', 'co_freevars', 'co_lnotab', 'co_name',
\end_layout

\begin_layout Plain Layout

 'co_names', 'co_nlocals', 'co_stacksize', 'co_varnames']
\end_layout

\end_inset


\end_layout

\begin_layout Part
Module
\end_layout

\begin_layout Standard
It is the highest-level program organization unit, which packages programcode an
d data for reuse, and provides self- contained namespaces
\end_layout

\begin_layout Itemize
import and from Are
\series bold
Assignments
\end_layout

\begin_layout Itemize

\series bold
Big Modules are folders.It has files.py under it
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Files can also be modules, and they have seceral classes defined inside.
\end_layout

\end_deeper
\begin_layout Itemize
• import 进的variable本质是module file的attribute，所以用时为module.vairable
\end_layout

\begin_layout Itemize
A module (NAME.py) is mostly just a package of variable names, known as anamespac
e,
\end_layout

\begin_layout Itemize
The names within that package are called attributes.
\end_layout

\begin_layout Itemize
An attribute is simply a variable name that is attached to a specific object(lik
e a module).
\end_layout

\begin_layout Section

\series bold
pip
\end_layout

\begin_layout Subsection

\series bold
Install pip
\end_layout

\begin_layout Standard
OR: Python 2.7.9 and later (on the python2 series), and Python 3.4 and later includ
e pip by default.
\end_layout

\begin_layout Itemize
You need to first download pip from
\begin_inset Flex Flex:URL
status open

\begin_layout Plain Layout

https://github.com/pypa/pip/tree/master
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Then open terminal,
\series bold
cd
\series default
 to the pip folder, and write
\end_layout

\begin_layout Itemize
sudo setup.py install
\end_layout

\begin_layout Standard

\series bold
After install pip, you can install other packages using pip
\end_layout

\begin_layout Itemize
In terminal write
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

sudo pip install numpy
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
# OR to specify the path
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

sudo pip install --target=/Library/Frameworks/Python.framework/Versions/3.4/lib/py
thon3.4/site-packages numpy
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
It will download and install those packages
\begin_inset Quotes eld
\end_inset

numpy scipy matplotlib pandas
\begin_inset Quotes erd
\end_inset

 into the folder=/Users/yangguodaxia/Dropbox/Library/Tech/Python. 
\end_layout

\begin_layout Itemize
You want to put all your packages into one folder to get clear management and
 avoid path confusion. 
\end_layout

\begin_layout Subsection
list of packages installed
\end_layout

\begin_layout Standard
To list installed packages:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$ pip list
\end_layout

\begin_layout Plain Layout

docutils (0.9.1)
\end_layout

\begin_layout Plain Layout

Jinja2 (2.6)
\end_layout

\begin_layout Plain Layout

Pygments (1.5)
\end_layout

\begin_layout Plain Layout

Sphinx (1.1.2)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Show what files were installed for files SomePackage
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$ pip show --files SomePackage
\end_layout

\begin_layout Plain Layout

Name: SomePackage
\end_layout

\begin_layout Plain Layout

Version: 1.0
\end_layout

\begin_layout Plain Layout

Location: /my/env/lib/pythonx.x/site-packages
\end_layout

\begin_layout Plain Layout

Files:
\end_layout

\begin_layout Plain Layout

../somepackage/__init__.py
\end_layout

\begin_layout Plain Layout

[...]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Install modules usign pip
\end_layout

\begin_layout Itemize
online way:
\family typewriter

\begin_inset ERT
status open

\begin_layout Plain Layout

pip install PACKAGE_NAME
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
local way 1: (tested, may not work)
\end_layout

\begin_deeper
\begin_layout Enumerate
download the package to local folder X and unzip it to the folder with name PACK
AGE_NAME_VERSION
\end_layout

\begin_layout Enumerate
cd to local folder X, run the code
\begin_inset ERT
status open

\begin_layout Plain Layout

pip install -e PACKAGE_NAME_VERSION
\end_layout

\end_inset

. Essentially pip will run the setup.py file under the folder PACKAGE_NAME_VERSION
\end_layout

\begin_layout Itemize

\family typewriter
-e
\family default
means
\family typewriter
 
\family default
Install a local project in "editable" mode. 
\end_layout

\end_deeper
\begin_layout Itemize
local way 2: (tested, may work)
\end_layout

\begin_deeper
\begin_layout Enumerate
download the package to local folder X and unzip it to the folder with name PACK
AGE_NAME_VERSION
\end_layout

\begin_layout Enumerate
cd to local folder X
\backslash
PACKAGE_NAME_VERSION
\backslash
. run the code
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

sudo python setup.py install --install-scripts /usr/bin/
\end_layout

\end_inset

 where /usr/bin/ shall be the folder you want to put the package in
\end_layout

\begin_layout Enumerate
May not need the sudo
\end_layout

\begin_layout Enumerate
May not need the exact folder path. Or you can just put the disk path of
 that folder
\begin_inset ERT
status open

\begin_layout Plain Layout

sudo python setup.py install --install-scripts H:
\backslash
 
\end_layout

\end_inset

. It still magitically worked!
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
update modules
\end_layout

\begin_layout Standard
List what packages are outdated:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$ pip list --outdated
\end_layout

\begin_layout Plain Layout

SomePackage (Current: 1.0 Latest: 2.0)
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Upgrade a package: pip also performs an automatic uninstall of an old version of
 a package before upgrading to a newer version.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$ pip install --upgrade SomePackage
\end_layout

\begin_layout Plain Layout

[...]
\end_layout

\begin_layout Plain Layout

Found existing installation: SomePackage 1.0
\end_layout

\begin_layout Plain Layout

Uninstalling SomePackage:
\end_layout

\begin_layout Plain Layout

Successfully uninstalled SomePackage
\end_layout

\begin_layout Plain Layout

Running setup.py install for SomePackage
\end_layout

\begin_layout Plain Layout

Successfully installed SomePackage
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uninstall a package by pip:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$ pip uninstall SomePackage
\end_layout

\begin_layout Plain Layout

Uninstalling SomePackage:
\end_layout

\begin_layout Plain Layout

/my/env/lib/pythonx.x/site-packages/somepackage
\end_layout

\begin_layout Plain Layout

Proceed (y/n)? y
\end_layout

\begin_layout Plain Layout

Successfully uninstalled SomePackage
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Uninstall a package Manually
\end_layout

\begin_layout Standard
"You need to remove all files manually, and also undo any other stuff that insta
llation did manually.
\end_layout

\begin_layout Standard
If you don't know the list of all files, you can reinstall it with the --record 
option, and take a look at the list this produces."
\end_layout

\begin_layout Standard
examples:
\end_layout

\begin_layout Standard
python setup.py install --record files.txt to generate the list
\end_layout

\begin_layout Standard
cat files.txt | xargs rm -rf to remove the files recorded by the previous step.
\end_layout

\begin_layout Subsection
manually install packages
\end_layout

\begin_layout Enumerate
Download the package unzip it if it is zipped
\end_layout

\begin_layout Enumerate
cd into the directory containing setup.py
\end_layout

\begin_deeper
\begin_layout Enumerate
If there are any installation instructions contained in documentation contianed
 herein, read and follow the instructions
\end_layout

\end_deeper
\begin_layout Enumerate
type in python setup.py install
\end_layout

\begin_deeper
\begin_layout Itemize
You may need administrator privileges. What you do here thus depends on your
 operating system. For example in Ubuntu you would say
\family typewriter
sudo python setup.py install
\end_layout

\begin_layout Itemize
To bypass the need for administrator privileges during step 5 above you may
 be able to make use of the --user flag. In this way you can install the
 package only for the current user.
\end_layout

\end_deeper
\begin_layout Enumerate
Files will be installed into subdirectories of site.USER_BASE (written as userbas
e hereafter). This scheme installs pure Python modules and extension modules
 in the same location (also known as site.USER_SITE). Here are the values
 for UNIX, including Mac OS X:
\end_layout

\begin_layout Standard
More details can be found here: http://docs.python.org/2.7/install/index.html 
\end_layout

\begin_layout Subsection
moduale dependencies
\end_layout

\begin_layout Standard
If you’re using Python, odds are you’re going to want to use other public packag
es from PyPI or elsewhere.
\end_layout

\begin_layout Standard
Fortunately, setuptools makes it easy for us to specify those dependencies (assu
ming they are packaged correctly) and automatically install them when our
 packages is installed.
\end_layout

\begin_layout Standard
We can add some formatting spice to the funniest joke with Markdown.
\end_layout

\begin_layout Standard
In __init__.py:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from markdown import markdown
\end_layout

\begin_layout Plain Layout

def joke():
\end_layout

\begin_layout Plain Layout

    return markdown(u'Wenn ist das Nunst
\backslash
u00fcck git und Slotermeyer?'
\end_layout

\begin_layout Plain Layout

    u'Ja! ... **Beiherhund** das Oder die Flipperwaldt '
\end_layout

\begin_layout Plain Layout

    u'gersput.')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now our package depends on the markdown package. To note that in setup.py,
 we just add an install_requires keyword argument:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from setuptools import setup
\end_layout

\begin_layout Plain Layout

setup(name='funniest',
\end_layout

\begin_layout Plain Layout

    version='0.1',
\end_layout

\begin_layout Plain Layout

    description='The funniest joke in the world',
\end_layout

\begin_layout Plain Layout

    url='http://github.com/storborg/funniest',
\end_layout

\begin_layout Plain Layout

    author='Flying Circus',
\end_layout

\begin_layout Plain Layout

    author_email='flyingcircus@example.com',
\end_layout

\begin_layout Plain Layout

    license='MIT',
\end_layout

\begin_layout Plain Layout

    packages=['funniest'],
\end_layout

\begin_layout Plain Layout

    install_requires=[
\end_layout

\begin_layout Plain Layout

    'markdown',
\end_layout

\begin_layout Plain Layout

    ],
\end_layout

\begin_layout Plain Layout

    zip_safe=False)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To prove this works, we can run python setup.py develop again, and we’ll see:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

$ python setup.py develop
\end_layout

\begin_layout Plain Layout

running develop
\end_layout

\begin_layout Plain Layout

running egg_info
\end_layout

\begin_layout Plain Layout

writing requirements to funniest.egg-info/requires.txt
\end_layout

\begin_layout Plain Layout

writing funniest.egg-info/PKG-INFO
\end_layout

\begin_layout Plain Layout

writing top-level names to funniest.egg-info/top_level.txt
\end_layout

\begin_layout Plain Layout

writing dependency_links to funniest.egg-info/dependency_links.txt
\end_layout

\begin_layout Plain Layout

reading manifest file 'funniest.egg-info/SOURCES.txt'
\end_layout

\begin_layout Plain Layout

writing manifest file 'funniest.egg-info/SOURCES.txt'
\end_layout

\begin_layout Plain Layout

running build_ext
\end_layout

\begin_layout Plain Layout

Creating /.../site-packages/funniest.egg-link (link to .)
\end_layout

\begin_layout Plain Layout

funniest 0.1 is already the active version in easy-install.pth
\end_layout

\begin_layout Plain Layout

Installed /Users/scott/local/funniest
\end_layout

\begin_layout Plain Layout

Processing dependencies for funniest==0.1
\end_layout

\begin_layout Plain Layout

Searching for Markdown==2.1.1
\end_layout

\begin_layout Plain Layout

Best match: Markdown 2.1.1
\end_layout

\begin_layout Plain Layout

Adding Markdown 2.1.1 to easy-install.pth file
\end_layout

\begin_layout Plain Layout

Using /.../site-packages
\end_layout

\begin_layout Plain Layout

Finished processing dependencies for funniest==0.1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When we publish this to PyPI, calling pip install funniest or similar will also
 install markdown.
\end_layout

\begin_layout Subsection
Download Modules to Local
\end_layout

\begin_layout Standard
Python uses its tool pip to download and install packages
\end_layout

\begin_layout Itemize
Official Module List: https://pypi.python.org/pypi?%3Aaction=index
\end_layout

\begin_layout Subsection
exec to Run Module Files
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

exec(open('script1.py').read())
\end_layout

\end_inset


\end_layout

\begin_layout Section
Import
\end_layout

\begin_layout Subsection
import and from
\end_layout

\begin_layout Itemize

\series bold
import MODUAL
\series default
: Lets a client (importer) fetch a module as a whole.You have to add module name
 before the variable
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

import module1 # Get module as a whole (one or more)
\end_layout

\begin_layout Plain Layout

module1.printer('Hello world!') # Qualify to get namesâ¨
\end_layout

\begin_layout Plain Layout

# Hello world!
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
From MODUAL import ATTRIBUTE
\series default
: Allows clients to fetch particular names from a module
\end_layout

\begin_deeper
\begin_layout Standard
Because the imported name is copied into the scope where the from statementappea
rs, using that name in the script requires less typing---we can useit directly i
nstead of naming the enclosing module.In fact, we must; from doesn't assign the
 name of the module itself.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from module1 import printer # Copy out a variable (one or more)
\end_layout

\begin_layout Plain Layout

printer('Hello world!') # No need to qualify nameâ¨
\end_layout

\begin_layout Plain Layout

# Hello world!
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
from MODUAL import *:
\series default
we get copies of all names assigned at the top level of the referenced module.Her
e again, we can then use the copied name printer in our script withoutgoing thro
ugh the module name
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from module1 import * # Copy out _all_ variables
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Relative path:
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset


\begin_inset Quotes eld
\end_inset

..
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Itemize
Single point
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

means the module is in the same folder of the file
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from .base import LinearClassifierMixin, SparseCoefMixin
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Double point
\begin_inset Quotes eld
\end_inset

..
\begin_inset Quotes erd
\end_inset

means the module is in the parant folder (one level above) of the file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from ..base import BaseEstimator, RegressorMixin
\end_layout

\begin_layout Plain Layout

from ..feature_selection.from_model import _LearntSelectorMixin
\end_layout

\begin_layout Plain Layout

# it is the same as absolute import:
\end_layout

\begin_layout Plain Layout

# from sklearn.utils import (atleast2d_or_csr, check_arrays, check_random_state,c
olumn_or_1d)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
search path
\end_layout

\begin_layout Standard
When the import mymodule statement is executed, the module mymodule is searchedi
n a given list of directories.This list includes a list of installation-dependent
 default path (e.g., /usr/lib/python) as well as the list of directories specified
 by the environmentvariable PYTHONPATH.
\end_layout

\begin_layout Standard
The list of directories searched by Python is given by the sys.path variable
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [1]: import sys
\end_layout

\begin_layout Plain Layout

In [2]: sys.path
\end_layout

\begin_layout Plain Layout

Out[2]:
\end_layout

\begin_layout Plain Layout

['',
\end_layout

\begin_layout Plain Layout

'/home/varoquau/.local/bin',
\end_layout

\begin_layout Plain Layout

'/usr/lib/python2.7',
\end_layout

\begin_layout Plain Layout

'/home/varoquau/.local/lib/python2.7/site-packages',
\end_layout

\begin_layout Plain Layout

'/usr/lib/python2.7/dist-packages',
\end_layout

\begin_layout Plain Layout

'/usr/local/lib/python2.7/dist-packages',
\end_layout

\begin_layout Plain Layout

...]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Modules must be located in the search path, therefore you can:
\end_layout

\begin_layout Itemize
write your own modules within directories already defined in the searchpath (e.g.$
HOME/.local/lib/python2.7/dist-packages).You may use symbolic links (on Linux)
 to keep the code somewhere else.
\end_layout

\begin_layout Itemize
modify the environment variable PYTHONPATH to include the directories containing
the user-defined modules.
\end_layout

\begin_deeper
\begin_layout Itemize
On Linux/Unix, add the following line to a file read by the shell at startup(e.g./
etc/profile, .profile)
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

export PYTHONPATH=$PYTHONPATH:/home/emma/user_defined_modules
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
On Windows, http://support.microsoft.com/kb/310519 explains how to handleenvironme
nt variables.
\end_layout

\end_deeper
\begin_layout Itemize
or modify the sys.path variable itself within a Python script.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

import sys
\end_layout

\begin_layout Plain Layout

new_path = '/home/emma/user_defined_modules'
\end_layout

\begin_layout Plain Layout

if new_path not in sys.path:
\end_layout

\begin_layout Plain Layout

sys.path.append(new_path)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method is not very robust, however, because it makes the code lessportable 
(user-dependent path) and because you have to add the directoryto your sys.path
 each time you want to import from a module in this directory.
\end_layout

\end_deeper
\begin_layout Subsection
Module caching
\end_layout

\begin_layout Standard
Modules are cached: if you modify demo.py and re-import it in the old session,you
 will get the old one.
\end_layout

\begin_layout Standard
Solution:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [10]: reload(demo)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Python3 instead reload is not builtin, so you have to import the importlibmod
ule first and then do:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [10]: importlib.reload(demo)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Reloading modules: the User Module Deleter (UMD)
\end_layout

\begin_layout Standard
When working with Python scripts interactively, one must keep in mind that Pytho
n import a module from its source code (on disk) only when parsing the first
 corresponding import statement. During this first import, the byte code
 is generated (.pyc file) if necessary and the imported module code object
 is cached in sys.modules. Then, when re-importing the same module, this cached
 code object will be directly used even if the source code file (.py[w] file)
 has changed meanwhile.
\end_layout

\begin_layout Standard
This behavior is sometimes unexpected when working with the Python interpreter i
n interactive mode, because one must either always restart the interpreter or
 remove manually the .pyc files to be sure that changes made in imported modules
 were taken into account.
\end_layout

\begin_layout Standard
The User Module Deleter (UMD) is a Spyder console’s exclusive feature that force
s the Python interpreter to reload modules completely when executing a Python
 script.
\end_layout

\begin_layout Standard
For example, when UMD is turned on, one may test complex applications within the
 same Python interpreter without having to restart it every time (restart time
 may be relatively long when testing GUI-based applications). 
\end_layout

\begin_layout Section
Access module attributes
\end_layout

\begin_layout Subsection
Get Module namespaces: default attribute: __dict__ or dir(M).
\end_layout

\begin_layout Standard
Module namespaces can be accessed via the attribute
\series bold
__dict__
\series default
or
\series bold
dir(M)
\series default
.
\end_layout

\begin_layout Standard
Module namespaces created by imports are dictionaries; they may be accessedthrou
gh the built-in __dict__ attribute associated with module objectsand may be
 inspected with the dir function.The
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

list(module2.__dict__.keys())
\end_layout

\begin_layout Plain Layout

# ['__loader__', 'func', 'klass', '__builtins__', '__doc__', '__file__','__name_
_', 'name', '__package__', 'sys', '__initializing__', '__cached__']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The names we assigned in the module file become dictionary keys internally,so so
me of the names here reflect top-level assignments in our file.
\end_layout

\begin_layout Standard
However, Python also adds some names in the module's namespace for us; forinstan
ce,
\end_layout

\begin_layout Itemize

\series bold
__file__
\series default
gives the name of the file the module was loaded from,
\end_layout

\begin_layout Itemize

\series bold
__name__
\series default
gives its name as known to importers (without the .py extension and directorypath
).
\end_layout

\begin_layout Itemize
To see just the names your code assigns, filter out the double-underscorenames a
s we've done before, in Chapter 15's dir coverage and Chapter 17'sbuilt-in scope
 coverage:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

list(name for name in module2.__dict__.keys() if not name.startswith('__'))
\end_layout

\begin_layout Plain Layout

# ['func', 'klass', 'name', 'sys']
\end_layout

\begin_layout Plain Layout

list(name for name in module2.__dict__ if not name.startswith('__'))
\end_layout

\begin_layout Plain Layout

# ['func', 'sys', 'name', 'klass']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
if __name__ == '__main__': to see whether names in Modules
\end_layout

\begin_layout Standard
当只有在module file下才为true。若import该file，则为false，即不会run下列code。
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

if __name__ == '__main__':
\end_layout

\begin_layout Plain Layout

# When run for testing only
\end_layout

\begin_layout Plain Layout

# self-test codeâ¨
\end_layout

\begin_layout Plain Layout

bob = Person('Bob Smith') 
\end_layout

\begin_layout Plain Layout

sue = Person('Sue Jones', job='dev', pay=100000)
\end_layout

\begin_layout Plain Layout

print(bob.name, bob.pay) 
\end_layout

\begin_layout Plain Layout

print(sue.name, sue.pay)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
dir(x): get all methods of x
\end_layout

\begin_layout Subsection
access python build-in names: __builtin__.
\end_layout

\begin_layout Standard
This module provides direct access to all `built-in' identifiers of Python;for e
xample, __builtin__.open is the full name for the built-in functionopen().
\end_layout

\begin_layout Standard
This module is not normally accessed explicitly by most applications, butcan be
 useful in modules that provide objects with the same name as a built-invalue,
 but in which the built-in of that name is also needed.
\end_layout

\begin_layout Section
Name Conventions
\end_layout

\begin_layout Itemize
Names that have two leading and trailing underscores (__X__) are system-definedn
ames that have special meaning to the interpreter.
\end_layout

\begin_layout Itemize
Names that begin with two underscores and do not end with two more (__X)are loca
lized (
\begin_inset Quotes eld
\end_inset

mangled
\begin_inset Quotes erd
\end_inset

) to enclosing classes (see the discussion of pseudoprivate attributes inChapter
 31).
\end_layout

\begin_layout Itemize
The name that is just a single underscore (_) retains the resul tof thelast expr
ession when you are working interactively.
\end_layout

\begin_layout Itemize

\series bold
class
\series default
names commonly start with an uppercase letter and
\series bold
module
\series default
names with a lowercase letter.
\end_layout

\begin_layout Section
Scopes & Namespace
\end_layout

\begin_layout Subsection
‘__main__’ and module loading
\end_layout

\begin_layout Standard
Sometimes we want code to be executed when a module is run directly, butnot when
 it is imported by another module.if __name__ == '__main__' allows us to
 check whether the module is beingrun directly.
\end_layout

\begin_layout Standard
File demo2.py:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def print_b():
\end_layout

\begin_layout Plain Layout

"Prints b."
\end_layout

\begin_layout Plain Layout

print 'b'
\end_layout

\begin_layout Plain Layout

def print_a():
\end_layout

\begin_layout Plain Layout

"Prints a."
\end_layout

\begin_layout Plain Layout

print 'a'
\end_layout

\begin_layout Plain Layout

# print_b() runs on import
\end_layout

\begin_layout Plain Layout

print_b()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if __name__ == '__main__':
\end_layout

\begin_layout Plain Layout

# print_a() is only executed when the module is run directly.
\end_layout

\begin_layout Plain Layout

print_a()
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Namespace
\end_layout

\begin_layout Standard
The place (either within a function---local variable; or outside -- globalveriab
le) where you assign a name in your source code determines the namespaceit will
 live in, and hence its scope of visibility.
\end_layout

\begin_layout Standard

\series bold
Scopes: Local Variables
\end_layout

\begin_layout Standard
Local Variable is A name that is visible only to code inside the function
\emph on
def
\emph default
and that exists only while the function runs.After running the function, those
 variables get deleted.
\end_layout

\begin_layout Standard
A
\series bold
namespace
\series default
is a container for a set of identifiers (also known as symbols, names).[1][2]Name
spaces provide a level of indirection to specific identifiers, thusmaking it
 possible to distinguish between identifiers with the same exactname.
\end_layout

\begin_layout Standard
Local & Global variables are in different Namespaces.Variables in packages are
 in the namespace of that package.
\end_layout

\begin_layout Standard
By default, all names assigned inside a function are associated with thatfunctio
n's namespace,
\end_layout

\begin_layout Subsection
Cross-file name changes for a shared mutable object
\end_layout

\begin_layout Standard
changing a shared mutable object through a copied name can also change itin the
 module from which it was imported.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# in file small.py, write
\end_layout

\begin_layout Plain Layout

x =1
\end_layout

\begin_layout Plain Layout

y = [1, 2]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# import them into your main file and change x and y
\end_layout

\begin_layout Plain Layout

from small import x, y
\end_layout

\begin_layout Plain Layout

x = 42
\end_layout

\begin_layout Plain Layout

y[0] = 42 # as you didn't define y before, so we assume this y is from samll.py
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, x is not a shared mutable object, but y is.The names y in the importer and
 the importee both reference the same listobject, so changing it from one
 place changes it in the other:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import small
\end_layout

\begin_layout Plain Layout

>>> small.x 
\end_layout

\begin_layout Plain Layout

1 
\end_layout

\begin_layout Plain Layout

>>> small.y
\end_layout

\begin_layout Plain Layout

[42, 2]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Scopes of Imported Modules : mod1.mod2.attribute
\end_layout

\begin_layout Standard
凡用import，其variable永远在module name之下。
\end_layout

\begin_layout Standard
# this is a main file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def f():
\end_layout

\begin_layout Plain Layout

global X
\end_layout

\begin_layout Plain Layout

X = 99
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

X = 11
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

import moda
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

moda.f()
\end_layout

\begin_layout Plain Layout

print(X, moda.X)
\end_layout

\begin_layout Plain Layout

# 11 99
\end_layout

\end_inset


\end_layout

\begin_layout Standard
moda.f 永远无法改变真正的global variable X，只能改变modual.X
\end_layout

\begin_layout Standard
Namespace Nesting
\end_layout

\begin_layout Standard
In some sense, although imports do not nest namespaces upward, they do nestdownw
ard.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

print(mod2.mod3.X)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Packages
\end_layout

\begin_layout Standard
A directory that contains many modules is called a package.A package is a module
 with submodules (which can have submodules themselves,etc.).A special file
 called __init__.py (which may be empty) tells Python thatthe directory is
 a Python package, from which modules can be imported.
\end_layout

\begin_layout Standard
For example, scipy is a package
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [1]: import scipy
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [2]: scipy.__file__
\end_layout

\begin_layout Plain Layout

Out[2]: '/usr/lib/python2.6/dist-packages/scipy/__init__.pyc'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [3]: import scipy.version
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [4]: scipy.version.version
\end_layout

\begin_layout Plain Layout

Out[4]: '0.7.0'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [5]: import scipy.ndimage.morphology
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [6]: from scipy.ndimage import morphology
\end_layout

\end_inset


\end_layout

\begin_layout Part
技
\end_layout

\begin_layout Standard
Build-in functions are called in expressions, are passed values, and return resu
lts.
\end_layout

\begin_layout Subsection
input(...): capture what you type
\end_layout

\begin_layout Standard
input built-in function we met earlier in the book is used here for general cons
ole input---it prints its optional argument string as a prompt and returns
 the user's typed reply as a string. Use raw_input in 2.X instead, per the
 upcoming note.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> s = input("Enter some text: ")
\end_layout

\begin_layout Plain Layout

Enter some text: On an exceptionally hot evening early in July
\end_layout

\begin_layout Plain Layout

>>> print("You typed", len(word_tokenize(s)), "words.")
\end_layout

\begin_layout Plain Layout

You typed 8 words.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
zip
\end_layout

\begin_layout Subsection
id(object)
\end_layout

\begin_layout Standard
show the physical memory address of that object
\end_layout

\begin_layout Section
Ipython
\end_layout

\begin_layout Subsection
not auto ident: thus can copy code from editor to console
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In [52]: %autoindent
\end_layout

\begin_layout Plain Layout

Automatic indentation is: OFF
\end_layout

\end_inset


\end_layout

\begin_layout Section
Encoding
\end_layout

\begin_layout Standard
See p157 in Learning_Python
\end_layout

\begin_layout Standard
And P 175
\end_layout

\begin_layout Subsection
Mutable string type: bytearray
\end_layout

\begin_layout Standard
Python 3.0 and 2.6 introduced a new string type known as bytearray, which is
 mu- table and so may be changed in place. bytearray objects aren't really
 text strings; they're sequences of small, 8-bit integers. However, they
 support most of the same operations as normal strings and print as AS-
 CII characters when displayed.
\end_layout

\end_body
\end_document
