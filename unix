#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[BoldFont,SlantFont,CJKnumber,fallback]{xeCJK}%使用TexLive自带的xeCJK宏包，并启用加粗、斜体、CJK数字和备用字体选项
\setCJKmainfont{Songti SC}%设置中文衬线字体,若没有该字体,请替换该字符串为系统已有的中文字体,下同
\setCJKsansfont{STXihei}%中文无衬线字体
\setCJKmonofont{SimHei}%中文等宽字体
%中文断行和弹性间距在XeCJK中自动处理了
%\XeTeXlinebreaklocale “zh”%中文断行
%\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt%左右弹性间距
\usepackage{indentfirst}%段落首行缩进
\setlength{\parindent}{2em}%缩进两个字符
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package auto
\inputencoding utf8-plain
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 3
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "unicode=false"
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Unix Notes 
\end_layout

\begin_layout Author
Fan Yang
\end_layout

\begin_layout Date
2015 June
\end_layout

\begin_layout Section
Goal
\end_layout

\begin_layout Subsubsection

\series bold
熟悉Unix/Linux Shell和常见的命令行
\end_layout

\begin_layout Standard
如果你用windows，至少学会用虚拟机里的linux， vmware player是免费的，装个Ubuntu吧
\end_layout

\begin_layout Standard
一定要少用少用图形界面。
\end_layout

\begin_layout Itemize
学会使用man来查看帮助
\end_layout

\begin_layout Itemize
文件系统结构和基本操作 ls/chmod/chown/rm/find/ln/cat/mount/mkdir/tar/gzip \SpecialChar \ldots{}

\end_layout

\begin_layout Itemize
学会使用一些文本操作命令 sed/awk/grep/tail/less/more \SpecialChar \ldots{}

\end_layout

\begin_layout Itemize
学会使用一些管理命令 ps/top/lsof/netstat/kill/tcpdump/iptables/dd\SpecialChar \ldots{}

\end_layout

\begin_layout Itemize
了解/etc目录下的各种配置文章，学会查看/var/log下的系统日志，以及/proc下的系统运行信息
\end_layout

\begin_layout Itemize
了解正则表达式，使用正则表达式来查找文件。
\end_layout

\begin_layout Itemize
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 
\begin_inset space ~
\end_inset

 对于程序员来说Unix/Linux比Windows简单多了。（参看我四年前CSDN的博文《其实Unix很简单》）学会使用Unix/Linux你会发现图形界面在
某些时候实在是太难用了，相当地相当地降低工作效率。
\end_layout

\begin_layout Part
pandoc
\end_layout

\begin_layout Subsubsection
\begin_inset ERT
status open

\begin_layout Plain Layout

pandoc -s doc.docx -o test.tex
\end_layout

\end_inset


\end_layout

\begin_layout Standard
pandoc -s Basels.tex -o -Basels.docx
\end_layout

\begin_layout Itemize
-o output to a file
\end_layout

\begin_layout Itemize
-s By default, pandoc produces a document fragment, not a standalone document
 with a proper header and footer.
 To produce 
\series bold
a standalone document
\series default
, use the -s or --standalone flag:
\end_layout

\begin_layout Itemize
Input/Output: -f/-t The format of the input and output can be specified
 explicitly using command-line options.
 The input format can be specified using the -r/--read or -f/--from options,
 the output format using the -w/--write or -t/--to options.
 Thus, to convert hello.txt from Markdown to LaTeX, you could type:
\end_layout

\begin_deeper
\begin_layout Itemize
To convert hello.html from HTML to Markdown: 
\begin_inset ERT
status open

\begin_layout Plain Layout

pandoc -f html -t markdown hello.html
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If the input or output format is not specified explicitly, pandoc will attempt
 to guess it from the extensions of the input and output filenames.
 Thus, for example, 
\begin_inset ERT
status open

\begin_layout Plain Layout

pandoc -o hello.tex hello.txt
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Part
Unix
\end_layout

\begin_layout Section
Shell / Terminal
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

shell
\begin_inset Quotes erd
\end_inset

 is a program that takes your commands from the keyboard and gives them
 to the operating system
\end_layout

\begin_layout Itemize
On Linux the shell program is usually called bash (for Bourne Again Shell),
 but there are others
\end_layout

\begin_layout Itemize
Commands are just the names of programs
\end_layout

\begin_layout Itemize
The shell recognizes some special characters and may modify arguments before
 they are passed to the program
\end_layout

\begin_layout Standard
The behavior of the command line interface will differ slightly depending
 on the shell program that is being used.
 
\end_layout

\begin_layout Standard
Depending on the shell used, some extra behaviors can be quite nifty.
\end_layout

\begin_layout Standard
You can find out what shell you are using by the command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

echo $SHELL
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
shell script
\end_layout

\begin_layout Standard
Of course you can create a file with a list of shell commands and execute
 it like a program to perform a task.
 This is called a shell script.
 This is in fact the primary purpose of most shells, not the interactive
 command line behavior.
 
\end_layout

\begin_layout Subsection
Promt
\end_layout

\begin_layout Standard
You can change your prompt to anything:
\end_layout

\begin_layout Standard
PS1="yangguodaxia$ "
\end_layout

\begin_layout Subsection
filesystem
\end_layout

\begin_layout Itemize
The top of the filesystem is called the 
\begin_inset Quotes eld
\end_inset

root
\begin_inset Quotes erd
\end_inset

 and is denoted by a single slash 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes eld
\end_inset

 
\end_layout

\begin_layout Itemize
A path is a list of directories that lead to the location of a file (or
 directory) 
\end_layout

\begin_layout Itemize
A path can be absolute (starts with 
\begin_inset Quotes eld
\end_inset

/
\begin_inset Quotes eld
\end_inset

) or relative to the current directory
\end_layout

\begin_deeper
\begin_layout Itemize
The special names 
\begin_inset Quotes eld
\end_inset

.
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

..
\begin_inset Quotes erd
\end_inset

 are used to denote the current and parent directories respectively 
\end_layout

\end_deeper
\begin_layout Standard
Examples
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

./eclipse!
\end_layout

\begin_layout Plain Layout

/usr/bin/python
\end_layout

\begin_layout Plain Layout

../bin/yes
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
bash
\end_layout

\begin_layout Standard
Bash is the way cool shell.
 Bash will even complete the name of commands and environment variables.
 And if there are multiple completions, if you hit TAB twice bash will show
 you all the completions.
 Bash is the default user shell for most Linux systems.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

exec bash 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
#to bash mode, more user-friendly than ps
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

exec bash
\end_layout

\end_inset


\end_layout

\begin_layout Standard
/card_nonhsm2/ccar/v660271
\end_layout

\begin_layout Section
Code Structure
\end_layout

\begin_layout Standard
The components of the command line are:
\end_layout

\begin_layout Enumerate
the command; 
\end_layout

\begin_deeper
\begin_layout Itemize
Command names must be between 2 and 9 characters in length 
\end_layout

\begin_layout Itemize
Command names must be comprised of lowercase characters and digits 
\end_layout

\end_deeper
\begin_layout Enumerate
any options required by the command 
\end_layout

\begin_layout Enumerate
the command's arguments (if required).
 
\end_layout

\begin_layout Standard
For example, the general form of a UNIX command is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

command [-option(s)] [argument(s)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
NOTE: Options MUST come after the command and before any command arguments.
\end_layout

\begin_layout Standard
Options SHOULD NOT appear after 
\series bold
the main argument
\series default
(s).
 However, some options can have their own arguments!
\end_layout

\begin_layout Subsection
option (hyphen) 
\end_layout

\begin_layout Itemize
All options are preceded by a hyphen (-) 
\end_layout

\begin_layout Itemize
A double hyphen -
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
/
\end_layout

\end_inset

- may be used to indicate the end of the option list 
\end_layout

\begin_layout Subsection
Options:
\end_layout

\begin_layout Itemize
Option names must be one character in length 
\end_layout

\begin_layout Itemize
Options without arguments may be grouped after the hyphen 
\end_layout

\begin_layout Itemize
Option arguments are not optional 
\end_layout

\begin_layout Itemize
All options must precede other arguments on the command line 
\end_layout

\begin_layout Itemize
The order of the options are order independent 
\end_layout

\begin_layout Subsection
Arguments
\end_layout

\begin_layout Itemize
The first option argument, following an option, must be preceded by white
 space.
 For example 
\series bold
-o sfile
\series default
 is valid but 
\series bold
-osfile
\series default
 is illegal.
 
\end_layout

\begin_layout Itemize
If an option takes more than one argument then they must be separated by
 commas with no spaces, or if spaces are used the string must be included
 in double quotes (").
 For example, both of the following are acceptable: 
\end_layout

\begin_layout Standard
-f past,now,next and -f "past now next"
\end_layout

\begin_layout Itemize

\series bold
The order of arguments may be important
\series default
 
\end_layout

\begin_layout Subsection
Pipes:
\end_layout

\begin_layout Standard
The pipe symbol "|" is used to direct the output of one command to the input
 of another.
\end_layout

\begin_layout Standard
For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ls -l | more 
\end_layout

\end_inset

This commands takes the output of the long format directory list command
 
\end_layout

\begin_layout Standard
"ls -l" and pipes it through the more command (also known as a filter).
\end_layout

\begin_layout Standard
In this case a very long list of files can be viewed a page at a time.
\end_layout

\begin_layout Standard
du -sc * | sort -n | tail 
\end_layout

\begin_layout Standard
The command "du -sc" lists the sizes of all files and directories in the
 
\end_layout

\begin_layout Standard
current working directory.
 That is piped through "sort -n" which orders the 
\end_layout

\begin_layout Standard
output from smallest to largest size.
 Finally, that output is piped through "tail"
\end_layout

\begin_layout Standard
which displays only the last few (which just happen to be the largest) results.
\end_layout

\begin_layout Section
Jobs
\end_layout

\begin_layout Subsection
kill process_id # kill a job 
\end_layout

\begin_layout Subsection
timing of a job: 
\end_layout

\begin_layout Itemize
when you see a sas job with timing as 0, it is probably still running.
\end_layout

\begin_deeper
\begin_layout Standard
sas 20160104_Profitability_Pull_LM_D02.sas $ 
\end_layout

\end_deeper
\begin_layout Subsection
How to read output printed in console
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Output [2] #means there is an error
\end_layout

\begin_layout Plain Layout

running
\end_layout

\begin_layout Itemize

[v660271@discov2b]/card_nonhsm2/ccar/v660271$sas 20160104_Profitability_Pull_LM_
D02.sas & 
\end_layout

\begin_layout Itemize

[2] 28049620     
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ps: to see whether the process has finished.
 
\end_layout

\begin_layout Standard
Used after running long codes to check whether the code completes running.
 nohub sas sas_script.sas: sending result to the text file: nohup.out
\end_layout

\begin_layout Subsection
control+C OR control+z to stop the code running
\end_layout

\begin_layout Section
view and print
\end_layout

\begin_layout Subsection
vi : to see the log file
\end_layout

\begin_layout Subsection
cat sas.log:m Print a text file
\end_layout

\begin_layout Standard
vi print.lst: sas will print its dataset into lst files, in putty you can
 view the file directly using
\end_layout

\begin_layout Section
HTTP
\end_layout

\begin_layout Subsection
hich process is listening on which port.
\end_layout

\begin_layout Standard
Open your terminal and type as
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

lsof -i :8000
\end_layout

\end_inset


\end_layout

\begin_layout Standard
that command will list you the application used by that port with PID.
\end_layout

\begin_layout Standard
you can use netstat to see which process is listening on which port.
\end_layout

\begin_layout Standard
I use this command to have a full detail :
\end_layout

\begin_layout Standard
sudo netstat -peanut
\end_layout

\begin_layout Standard
if you need to know exactly which one is listening on port 8000 you can
 use this :
\end_layout

\begin_layout Standard
sudo netstat -peant | grep ":8000 "
\end_layout

\begin_layout Standard
There is no process that can hide from netstat.
\end_layout

\begin_layout Section
Copying and pasting text
\end_layout

\begin_layout Standard
PuTTY's copy and paste works entirely with the mouse.
 In order to copy text to the clipboard, you just click the left mouse button
 in the terminal window, and drag to select text.
 When you let go of the button, the text is 
\emph on
automatically
\emph default
 copied to the clipboard.
 You do not need to press Ctrl-C or Ctrl-Ins; in fact, if you do press Ctrl-C,
 PuTTY will send a Ctrl-C character down your session to the server where
 it will probably cause a process to be interrupted.
\end_layout

\begin_layout Subsection
Pasting
\end_layout

\begin_layout Standard

\series bold
Pasting is done using the right button
\series default
 (or the middle mouse button, if you have a three-button mouse and have
 set it up; see 
\begin_inset CommandInset href
LatexCommand href
name "section 4.10.3"
target "http://the.earth.li/~sgtatham/putty/0.52/htmldoc/Chapter4.html#4.10.3"

\end_inset

).
 When you click the right mouse button, PuTTY will read whatever is in the
 Windows Clipboard and paste it into your session, 
\emph on
exactly
\emph default
 as if it had been typed at the keyboard.
 (Therefore, be careful of pasting formatted text into an editor that does
 automatic indenting; you may find that the spaces pasted from the clipboard
 plus the spaces added by the editor add up to too many spaces and ruin
 the formatting.
 There is nothing PuTTY can do about this.)
\end_layout

\begin_layout Subsection
select a whole word
\end_layout

\begin_layout Standard
If you double-click the left mouse button, PuTTY will select a whole word.
 If you double-click, hold down the second click, and drag the mouse, PuTTY
 will select a sequence of whole words.
 (You can adjust precisely what PuTTY considers to be part of a word; see
 
\begin_inset CommandInset href
LatexCommand href
name "section 4.10.6"
target "http://the.earth.li/~sgtatham/putty/0.52/htmldoc/Chapter4.html#4.10.6"

\end_inset

.) If you 
\emph on
triple
\emph default
-click, or triple-click and drag, then PuTTY will select a whole line or
 sequence of lines.
\end_layout

\begin_layout Subsection
select a rectangular region
\end_layout

\begin_layout Standard
If you want to select a rectangular region instead of selecting to the end
 of each line, you can do this by holding down 
\series bold
Alt
\series default
 when you make your selection.
 (You can also configure rectangular selection to be the default, and then
 holding down Alt gives the normal behaviour instead.
 See 
\begin_inset CommandInset href
LatexCommand href
name "section 4.10.5"
target "http://the.earth.li/~sgtatham/putty/0.52/htmldoc/Chapter4.html#4.10.5"

\end_inset

for details.)
\end_layout

\begin_layout Standard
If you have a middle mouse button, then you can use it to adjust an existing
 selection if you selected something slightly wrong.
 (If you have configured the middle mouse button to paste, then the right
 mouse button does this instead.) Click the button on the screen, and you
 can pick up the nearest end of the selection and drag it to somewhere else.
\end_layout

\begin_layout Section
Directories
\end_layout

\begin_layout Subsection
cd
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd $STRMWORK
\end_layout

\end_inset

 Change current directory to the directory defined by the environment variable
 'STRMWORK'.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd ~bob
\end_layout

\end_inset

 Change the current directory to the user bob's home directory (if you have
 permission).
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd ..
\end_layout

\end_inset

 Change current directory to the parent directory of the current directory.
\end_layout

\begin_layout Subsection
path
\end_layout

\begin_layout Itemize
~/ relative pathname
\end_layout

\begin_deeper
\begin_layout Itemize
The above example uses a 
\series bold
relative pathname
\series default
.
 It assumes that 'papers' was an immediate subdirectory of the directory
 you started out from, i.e.
 in this example your home directory.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

cd ~/papers/syntax/swedish-word-order
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
would be more general since this will work independently of which directory
 you're currently in.
\end_layout

\begin_layout Itemize
You can also skip the ~/
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

cd papers/syntax/swedish-word-order
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
~ tilde: represent current directly
\end_layout

\begin_deeper
\begin_layout Itemize
The 
\series bold
tilda
\series default
 is an abbreviation of a complete pathname that mentions all the directories
 above your home directory
\end_layout

\end_deeper
\begin_layout Itemize
absolute pathnames.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

cd /Users/yangguodaxia/Dropbox
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Pathnames like the above
\series bold
, which start with a / (for the root directory)
\series default
, are called 
\series bold
absolute pathnames
\series default
.
\end_layout

\end_deeper
\begin_layout Subsection
Moving, renaming, and copying files:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cp file1 file2
\end_layout

\end_inset

 copy a file
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mv file1 newname 
\end_layout

\end_inset

move or rename a file
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mv file1 ~/AAA/
\end_layout

\end_inset

 move file1 into sub-directory AAA in your home directory.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rm file1 [file2 ...]
\end_layout

\end_inset

 remove or delete a file
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rm -r dir1 [dir2...] 
\end_layout

\end_inset

recursivly remove a directory and its contents BE CAREFUL!
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mkdir dir1 [dir2...]
\end_layout

\end_inset

 create directories
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mkdir -p dirpath 
\end_layout

\end_inset

create the directory dirpath, including all implied directories in the path.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

rmdir dir1 [dir2...] 
\end_layout

\end_inset

remove an empty directory
\end_layout

\begin_layout Subsection
View and Edit files
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cat filename
\end_layout

\end_inset

 Dump a file to the screen in ascii.
 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

more filename
\end_layout

\end_inset

 Progressively dump a file to the screen: 
\end_layout

\begin_deeper
\begin_layout Itemize
ENTER = one line down,
\end_layout

\begin_layout Itemize
SPACEBAR = page down 
\end_layout

\begin_layout Itemize
q=quit
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

less filename
\end_layout

\end_inset

 Like more, but you can use Page-Up too.
 Not on all systems.
 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

vi filename
\end_layout

\end_inset

 Edit a file using the vi editor.
 All UNIX systems will have vi in some form.
 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

emacs filename
\end_layout

\end_inset

 Edit a file using the emacs editor.
 Not all systems will have emacs.
 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

head filename 
\end_layout

\end_inset

Show the first few lines of a file.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

head -n filename
\end_layout

\end_inset

 Show the first n lines of a file.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

tail filename
\end_layout

\end_inset

 Show the last few lines of a file.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

tail -n filename
\end_layout

\end_inset

 Show the last n lines of a file.
\end_layout

\begin_layout Subsection
mkdir dirname: make a new directory
\end_layout

\begin_layout Subsection
ls 
\emph on
dirname
\emph default
: show all files in directly 
\end_layout

\begin_layout Standard
instead of doing
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

cd papers/syntax/swedish-word-order
\end_layout

\begin_layout Plain Layout

ls
\end_layout

\begin_layout Plain Layout

cd
\end_layout

\end_inset


\end_layout

\begin_layout Standard
you can say
\end_layout

\begin_layout Standard
ls papers/syntax/swedish-word-order
\end_layout

\begin_layout Itemize

\series bold
ls -l
\series default
 - lists your files in 'long format', which contains lots of useful information,
 e.g.
 the exact size of the file, who owns the file and who has the right to
 look at it, and when it was last modified.
 
\end_layout

\begin_layout Itemize

\series bold
ls -a
\series default
 - lists all files, including the ones whose filenames begin in a dot, which
 you do not always want to see.
 
\end_layout

\begin_layout Section
Environment variables
\end_layout

\begin_layout Standard
You can teach your shell to remember things for later using environment
 variables.
\end_layout

\begin_layout Standard
For example under the bash shell:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

export CASROOT=/usr/local/CAS3.0
\end_layout

\end_inset

 Defines the variable CASROOT with the value /usr/local/CAS3.0.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

export LD_LIBRARY_PATH=$CASROOT/Linux/lib
\end_layout

\end_inset

 Defines the variable LD_LIBRARY_PATH with the value of CASROOT with /Linux/lib
 appended, or /usr/local/CAS3.0/Linux/lib 
\end_layout

\begin_layout Standard
By prefixing 
\series bold
$
\series default
 to the variable name, you can evaluate it in any command:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

cd $CASROOT 
\end_layout

\end_inset

Changes your present working directory to the value of CASROOT
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

echo $CASROOT 
\end_layout

\end_inset

Prints out the value of CASROOT, or /usr/local/CAS3.0
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

printenv CASROOT
\end_layout

\end_inset

 Does the same thing in bash and some other shells.
 
\end_layout

\begin_layout Section
Permissions
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chmod 755 file
\end_layout

\end_inset

 Changes the permissions of file to be rwx for the owner, and rx for the
 group and the world.
 (7 = rwx = 111 binary.
 5 = r-x = 101 binary)
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chgrp user file
\end_layout

\end_inset

 Makes file belong to the group user.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chown cliff file
\end_layout

\end_inset

 Makes cliff the owner of file.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

chown -R cliff dir 
\end_layout

\end_inset

Makes cliff the owner of dir and everything in its directory tree.
 
\end_layout

\begin_layout Subsection
pwd :tells you where you currently are.
\end_layout

\begin_layout Section
files
\end_layout

\begin_layout Itemize

\series bold
more 
\emph on
filename
\series default
\emph default
 -shows the first part of a file, just as much as will fit on one screen.
 Just hit the space bar to see more or 
\series bold
q
\series default
 to quit.
 
\end_layout

\begin_layout Itemize
You can use 
\series bold
/
\emph on
pattern
\series default
\emph default
 to search for a pattern.
 
\end_layout

\begin_layout Itemize

\series bold
emacs 
\emph on
filename
\series default
\emph default
 is an editor that lets you create and edit a file.
 See the 
\begin_inset CommandInset href
LatexCommand href
name "emph{emacs   page}"
target "http://mally.stanford.edu/~sr/computing/emacs.html"

\end_inset

.
 
\end_layout

\begin_layout Itemize

\series bold
mv 
\emph on
filename1 filename2
\series default
\emph default
 moves a file (i.e.
 gives it a different name, or moves it into a different directory (see
 below) 
\end_layout

\begin_layout Itemize
cp 
\emph on
filename1 filename2
\emph default
 copies a file 
\end_layout

\begin_layout Itemize

\series bold
rm 
\emph on
filename
\series default
\emph default
 removes a file.
 It is wise to use the option rm -i, which will ask you for confirmation
 before actually deleting anything.
 You can make this your default by making an 
\begin_inset CommandInset href
LatexCommand href
name "emph{alias}"
target "http://mally.stanford.edu/~sr/computing/alias.html"

\end_inset

in your .cshrc file.
 
\end_layout

\begin_layout Itemize

\series bold
diff 
\emph on
filename1 filename2
\series default
\emph default
 -compares files, and shows where they differ 
\end_layout

\begin_layout Itemize

\series bold
wc 
\emph on
filename
\series default
\emph default
 tells you how many lines, words, and characters there are in a file 
\end_layout

\begin_layout Itemize

\series bold
chmod 
\emph on
options filename
\series default
\emph default
lets you change the read, write, and execute permissions on your files.
 The default is that only you can look at them and change them, but you
 may sometimes want to change these permissions.
 For example, 
\series bold
chmod o+r 
\emph on
filename
\series default
\emph default
 will make the file readable for everyone, and 
\series bold
chmod o-r 
\emph on
filename
\series default
\emph default
 will make it unreadable for others again.
 Note that for someone to be able to actually look at the file the directories
 it is in need to be at least executable.
 See 
\begin_inset CommandInset href
LatexCommand href
name "emph{help   protection}"
target "http://www-csli.stanford.edu/Help/.help/intro-computer/protection"

\end_inset

for more details.
 
\end_layout

\begin_layout Itemize
File Compression
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
gzip 
\emph on
filename
\series default
\emph default
 compresses files, so that they take up much less space.
 Usually text files compress to about half their original size, but it depends
 very much on the size of the file and the nature of the contents.
 There are other tools for this purpose, too (e.g.
 
\series bold
compress
\series default
), but gzip usually gives the highest compression rate.
 Gzip produces files with the ending '.gz' appended to the original filename.
 
\end_layout

\begin_layout Itemize

\series bold
gunzip 
\emph on
filename
\series default
\emph default
 uncompresses files compressed by gzip.
 
\end_layout

\begin_layout Itemize

\series bold
gzcat 
\emph on
filename
\series default
\emph default
 lets you look at a gzipped file without actually having to gunzip it (same
 as 
\series bold
gunzip -c
\series default
).
 You can even print it directly, using 
\series bold
gzcat 
\emph on
filename
\emph default
 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textbar
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

 lpr
\series default
 
\end_layout

\end_deeper
\begin_layout Section
printer
\end_layout

\begin_layout Itemize

\series bold
lpr 
\emph on
filename
\series default
\emph default
 print.
 Use the -P option to specify the printer name if you want to use a printer
 other than your default printer.
 For example, if you want to print double-sided, use 'lpr -Pvalkyr-d', or
 if you're at CSLI, you may want to use 'lpr -Pcord115-d'.
 See 'help printers' for more information about printers and their locations.
 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
lpq
\series default
 check out the printer queue, e.g.
 to get the number needed for removal, or to see how many other files will
 be printed before yours will come out 
\end_layout

\begin_layout Itemize

\series bold
lprm 
\emph on
jobnumber
\series default
\emph default
 remove something from the printer queue.
 You can find the job number by using lpq.
 Theoretically you also have to specify a printer name, but this isn't necessary
 as long as you use your default printer in the department.
 
\end_layout

\begin_layout Itemize

\series bold
genscript
\series default
 onverts plain text files into postscript for printing, and gives you some
 options for formatting.
 Consider making an alias like 
\series bold
alias ecop 'genscript -2 -r 
\backslash
!*lpr -h -Pvalkyr'
\series default
 to print two pages on one piece of paper.
 
\end_layout

\begin_layout Itemize

\series bold
dvips 
\emph on
filename
\series default
\emph default
 print 
\series bold
.dvi
\series default
 files (i.e.
 files produced by Latex).
 You can use 
\series bold
dviselect
\series default
 to print only selected pages.
 See the for more information about how to save paper when printing drafts.
 
\end_layout

\end_deeper
\begin_layout Part
SSH
\end_layout

\begin_layout Subsection
sfotware
\end_layout

\begin_layout Itemize
Filezilla 
\end_layout

\begin_layout Itemize
Winscp
\end_layout

\begin_layout Subsection
X11-SSH
\end_layout

\begin_layout Standard
ssh -X -Y 
\end_layout

\begin_layout Standard
matsub yourfile.m yourfile.log * submit your matlab m file and generate a
 log file
\end_layout

\begin_layout Standard
statasub yourfile.do * submit your stata.do file and generate a log file automatic
ally.
\end_layout

\begin_layout Standard
matlab *调出matlab
\end_layout

\begin_layout Standard
xstata-se * come out STATA
\end_layout

\begin_layout Standard
qstat * show the status of SSH working, to see which task is running or
 in the queue.
\end_layout

\begin_layout Subsection
USING .sh
\end_layout

\begin_layout Standard
#!/bin/sh
\end_layout

\begin_layout Standard
#$ -S /bin/sh
\end_layout

\begin_layout Standard
#$ -N "PS_5"
\end_layout

\begin_layout Standard
#$ -cwd -j y
\end_layout

\begin_layout Standard
#$ -V
\end_layout

\begin_layout Standard
#$ -M FY21@duke.edu -m e
\end_layout

\begin_layout Standard
/usr/local/bin/matlab -nodesktop -nodisplay -nosplash -nojvm PS_5.m PS_5.log
\end_layout

\begin_layout Enumerate
Change directories to the folder where your m-file and function files reside.
 
\end_layout

\begin_layout Enumerate
Submit the m-file for batch computation using the matsub command, e.g.
 matsub ps3main.m ps3main.log 
\end_layout

\begin_layout Enumerate
NowdownloadtheexampleshellscriptfromSakai(Resources/Matlab2Materials/Examples/ex
ample.sh) and copy it into the same folder where you did your matsub from.
 
\end_layout

\begin_layout Enumerate
Edit the example shell script to have a new name, a di↵erent email address,
 and the same filenames as your matsub command.
 
\end_layout

\begin_layout Enumerate
Now submit your shell script with the command qsub -q all.q myshell.sh 
\end_layout

\begin_layout Part
OSX
\end_layout

\begin_layout Subsubsection
FINDER 显示隐藏文件
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

defaults write com.apple.finder AppleShowAllFiles -bool true
\end_layout

\begin_layout Plain Layout

KillAll Finder
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Show Bash folder but not user folder
\end_layout

\begin_layout Standard
If when you open terminal it shows
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

bash-3.2$
\end_layout

\end_inset


\end_layout

\begin_layout Standard
instead of
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

[MacBook-Air:~] yangguodaxia
\end_layout

\end_inset


\end_layout

\begin_layout Standard
then just write
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

/bin/tcsh
\end_layout

\end_inset


\end_layout

\begin_layout Standard
to go back to your user folder
\end_layout

\begin_layout Subsection
sudo to solve the Permission denied error
\end_layout

\begin_layout Standard
But where on your computer does
\begin_inset space ~
\end_inset

pip
\begin_inset space ~
\end_inset

install the packages to? Here's what happens if I try to run
\begin_inset space ~
\end_inset

pip install requests:
\end_layout

\begin_layout Standard
$ pip install requests Downloading/unpacking requests Downloading requests-1.1.0.ta
r.gz (337Kb): 337Kb downloaded Running setup.py egg_info 
\series bold
for
\series default
 package requests Installing collected packages: requests Running setup.py
 install 
\series bold
for
\series default
 requests error: could not create '/Library/Python/2.7/site-packages/requests':
 Permission denied
\end_layout

\begin_layout Standard
Oops! It looks like
\begin_inset space ~
\end_inset

pip
\begin_inset space ~
\end_inset

is trying to install the package into/Library/Python/2.7/site-packages/requests.
 This is a special directory that Python knows about.
 Anything that's installed in
\begin_inset space ~
\end_inset

site-packages
\begin_inset space ~
\end_inset

can be imported by your programs.
\end_layout

\begin_layout Standard
We're seeing the error because
\begin_inset space ~
\end_inset

/Library/
\begin_inset space ~
\end_inset

(on a Mac) is not usually writeable by "ordinary" users.
 To fix the error, we can run
\begin_inset space ~
\end_inset

sudo pip install requests
\begin_inset space ~
\end_inset

(sudomeans "run this command as a superuser").
 Then everything will work fine:
\end_layout

\begin_layout Section
TextShop 
\end_layout

\begin_layout Subsection
pdfsync
\end_layout

\begin_layout Standard
TexShop has a feature called pdfsync: clicking on a spot in the preview
 window activates the corresponding source window with the appropriate source
 line selected.
 This feature requires that files named "pdfsync.sty," "pdfsync.tex", and
 "pdfsync4context.tex" be installed in Tex.
 This is done automatically if you install from the Mac Tex install package.
 Otherwise, 卸掉重装！since Tex is outdated now and it was transformed to TexLive.
\end_layout

\begin_layout Section
Word in Mac
\end_layout

\begin_layout Subsection
EndNote
\end_layout

\begin_layout Standard
If micro word showed an error about endnote, then delete
\end_layout

\begin_layout Standard
This happens when you have EndNote installed and are launching Word by opening
 a document that is protected.
 This is a known bug with EndNote X5
\end_layout

\begin_layout Standard
Go into applications =Microsoft Office=Office=Startup= Word.
 In that folder I found a file titled Endnote something or other...
 
\begin_inset space ~
\end_inset

I deleted that file, rebooted, and it worked...
 
\begin_inset space ~
\end_inset

Or at least it is working so far...
\end_layout

\begin_layout Standard
After dealing with the protected document, restore that endnote file, since
 it works fine for normal file.
\end_layout

\begin_layout Section
Homebrew
\end_layout

\begin_layout Standard
Homebrew is a free and open-source software package management system that
 simplifies the installation of software on Apple's OS X operating system.
 Originally written by Max Howell, the package manager has gained popularity
 in the Ruby on Rails community and earned praise for its extensibility.[1]
 Homebrew has been recommended for its ease of use[2] as well as its integration
 into the command line.[3]
\end_layout

\begin_layout Itemize
usr/local/bin/brew
\end_layout

\begin_layout Itemize
/usr/local/Library/...
\end_layout

\begin_layout Itemize
/usr/local/share/man/man1/brew.1
\end_layout

\begin_layout Standard

\series bold
The following directories will be made group writable:
\end_layout

\begin_layout Itemize
/usr/local/.
\end_layout

\begin_layout Itemize
/usr/local/bin
\end_layout

\begin_layout Itemize
/usr/local/include
\end_layout

\begin_layout Itemize
/usr/local/lib
\end_layout

\begin_layout Itemize
/usr/local/lib/pkgconfig
\end_layout

\begin_layout Itemize
/usr/local/share
\end_layout

\begin_layout Itemize
/usr/local/share/man
\end_layout

\begin_layout Itemize
/usr/local/share/man/man1
\end_layout

\begin_layout Standard

\series bold
the following directories will have their group set to 
\emph on
admin
\series default
\emph default
:
\end_layout

\begin_layout Itemize
/usr/local/.
\end_layout

\begin_layout Itemize
/usr/local/bin
\end_layout

\begin_layout Itemize
/usr/local/include
\end_layout

\begin_layout Itemize
/usr/local/lib
\end_layout

\begin_layout Itemize
/usr/local/lib/pkgconfig
\end_layout

\begin_layout Itemize
/usr/local/share
\end_layout

\begin_layout Itemize
/usr/local/share/man
\end_layout

\begin_layout Itemize
/usr/local
\begin_inset Formula $ $
\end_inset

/share/man/man1
\end_layout

\begin_layout Part
Environment Variable
\end_layout

\begin_layout Standard
Environment variables are a set of dynamic named values that can affect
 the way running processes will behave on a computer.
\end_layout

\begin_layout Standard
They are part of the environment in which a process runs.
 For example, a running process can query the value of the TEMP environment
 variable to discover a suitable location to store temporary files, or the
 HOME or USERPROFILE variable to find the directory structure owned by the
 user running the process.
\end_layout

\begin_layout Standard
In all Unix and Unix-like systems, each process has its own separate set
 of environment variables.
 By default, when a process is created, it inherits a duplicate environment
 of its parent process, except for explicit changes made by the parent when
 it creates the child.
 At the API level, these changes must be done between running fork and exec.
 Alternatively, from command shells such as bash, a user can change environment
 variables for a particular command invocation by indirectly invoking it
 via env or using the ENVIRONMENT_VARIABLE=VALUE <command> notation.
 
\end_layout

\begin_layout Standard
Examples of environment variables include:
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
PATH – a list of directory paths.
 When the user types a command without providing the full path, this list
 is checked to see whether it contains a path that leads to the command.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
HOME (Unix-like) and USERPROFILE (Microsoft Windows) – indicate where a
 user's home directory is located in the file system.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
HOME/{.AppName} (Unix-like) and APPDATA
\backslash
{DeveloperName
\backslash
AppName} (Microsoft Windows) – for storing application settings.
 Many applications incorrectly use USERPROFILE for application settings
 in Windows – USERPROFILE should only be used in dialogs that allow user
 to choose between paths like Documents/Pictures/Downloads/Music, for programmat
ic purposes APPDATA (roaming), LOCALAPPDATA or PROGRAMDATA (shared between
 users) is used.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
TERM (Unix-like) – specifies the type of computer terminal or terminal emulator
 being used (e.g., vt100 or dumb).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
PS1 (Unix-like) – specifies how the prompt is displayed in the Bourne shell
 and variants.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
MAIL (Unix-like) – used to indicate where a user's mail is to be found.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
TEMP – location where processes can store temporary files
\end_layout

\begin_layout Part
Garbage Collection
\end_layout

\begin_layout Standard
P128 Java a Beginner's Guide
\end_layout

\begin_layout Subsection
The finalize( ) Method
\end_layout

\begin_layout Standard
P128 Java a Beginner's Guide
\end_layout

\begin_layout Part
J Primitive & Default Types
\end_layout

\begin_layout Section
Strings
\end_layout

\begin_layout Itemize
Strings Are Immutable
\end_layout

\begin_layout Itemize
Strings are made by chr
\end_layout

\begin_layout Subsection
Constructing Strings
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String str = new String("Hello");
\end_layout

\end_inset


\end_layout

\begin_layout Standard
OR 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String str = "Java strings are powerful.";
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Compare
\end_layout

\begin_layout Standard
When comparing for equality you should use equals(), because it expresses
 your intent in a clear way.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

== tests
\end_layout

\end_inset

 for reference equality (whether they are the same object).
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.equals()
\end_layout

\end_inset

 tests for value equality (whether they are logically "equal").
 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String.compareTo()
\end_layout

\end_inset

 seek the difference of the content of two strings.
\end_layout

\begin_deeper
\begin_layout Itemize
equals only tells you whether they're equal or not, but compareTo gives
 information on how the Strings compare lexicographically.
\end_layout

\end_deeper
\begin_layout Subsection
Opperations
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

str1.length()
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Print
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

System.out.println(str1)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
concatenate
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

String str1 = "One";
\end_layout

\begin_layout Plain Layout

String str2 = "Two";
\end_layout

\begin_layout Plain Layout

String str3 = "Three";
\end_layout

\begin_layout Plain Layout

String str4 = str1 + str2 + str3;
\end_layout

\begin_layout Plain Layout

initializes str4 with the string "OneTwoThree".
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
substring( ) method returns a new string that contains a specified portion
 of the invoking string.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

str1.substring(5, 18);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
string method
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int compareTo(Object o)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
This method compares this String to another Object.
\end_layout

\begin_layout Itemize
If first string is greater than second string, it returns positive number
 (difference of character value).
 
\end_layout

\begin_layout Itemize
If first string is less than second string, it returns negative number and
 
\end_layout

\begin_layout Itemize
if first string is equal to second string, it returns 0.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int indexOf(str) 
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Searches the invoking string for the substring specified by str.
 Returns the index of the first match or –1 on failure.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int lastIndexOf(str) 
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Searches the invoking string for the substring specified by str.
 Returns the index of the last match or –1 on failure.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

str1.charAt(i) // i has to be chr
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
get posittion: Obtains the character at the index specified by index.
\end_layout

\end_deeper
\begin_layout Subsection
Using a String to Control a switch Statement
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case "connect":
\end_layout

\begin_layout Plain Layout

	System.out.println("Connecting");
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case "cancel":
\end_layout

\begin_layout Plain Layout

	System.out.println("Canceling");
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

case "disconnect":
\end_layout

\begin_layout Plain Layout

	System.out.println("Disconnecting");
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

default:
\end_layout

\begin_layout Plain Layout

	System.out.println("Command Error!");
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A mutable string
\end_layout

\begin_layout Standard
Java offers a class called StringBuffer, which creates string objects that
 can be changed.
 For example, in addition to the charAt( ) method, which obtains the character
 at a specific location, StringBuffer defines setCharAt( ), which sets a
 character within the string.
 Java also supplies StringBuilder, which is related to StringBuffer, and
 also supports strings that can be changed.
 However, for most purposes you will want to use String, not StringBuffer
 or StringBuilder.
\end_layout

\begin_layout Section
Array
\end_layout

\begin_layout Standard
An array is a collection of variables of the same type, referred to by a
 common name.
\end_layout

\begin_layout Subsection
Create an Array
\end_layout

\begin_layout Itemize

\series bold
type
\series default
 array-name[ ] = 
\series bold
new
\series default
 
\series bold
type
\series default
[size]; 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
type
\series default
 declares the element type of the array.
 (The element type is also commonly referred to as the base type.)
\end_layout

\begin_layout Itemize
size is strictly a constraint, you can not refer/access an element beyond
 its size.
\end_layout

\end_deeper
\begin_layout Itemize
or size.
 Since arrays are implemented as objects, the creation of an array is a
 two-step process.
 First, you declare an array reference variable.
 Second, you allocate memory for the array, assigning a reference to that
 memory to the array variable.
 Thus, arrays in Java are dynamically allocated using the new operator.
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int sample[];
\end_layout

\begin_layout Plain Layout

sample = new int[10];
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
or 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type array-name[ ] = { val1, val2, val3, ...
 , valN };
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Biud-in Attributes
\end_layout

\begin_layout Itemize
table.length
\end_layout

\begin_deeper
\begin_layout Itemize
If it is a two-dimention arrary: table[0].length is for the row?
\end_layout

\end_deeper
\begin_layout Subsection
Two-Dimensional Arrays
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int table[][] = new int[10][20];
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
table[0][0] is the left most value.
\end_layout

\begin_layout Itemize
Initializing
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

type-specifier array_name[ ] [ ] = {
\end_layout

\begin_layout Plain Layout

{ val, val, val, ..., val },
\end_layout

\begin_layout Plain Layout

{ val, val, val, ..., val },
\end_layout

\begin_layout Plain Layout

.
\end_layout

\begin_layout Plain Layout

.
\end_layout

\begin_layout Plain Layout

.
\end_layout

\begin_layout Plain Layout

{ val, val, val, ..., val }
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Refer Elements in Arrary
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sample[i] = X;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
or for two-dimention
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

table[3][5]
\end_layout

\end_inset


\end_layout

\begin_layout Part
Loop and Control
\end_layout

\begin_layout Section
Loop
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for(initialization; condition; iteration)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	statement sequence
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
condition
\series default
 is a Boolean expression that determines whether or not the loop will repeat.
 
\end_layout

\begin_layout Itemize
The 
\series bold
iteration
\series default
 expression defines the amount by which the loop control variable will change
 each time the loop is repeated.
\end_layout

\begin_deeper
\begin_layout Itemize
The for loop can proceed in a positive or negative fashion, and it can change
 the loop control variable by any amount.
\end_layout

\end_deeper
\begin_layout Itemize
iteration can be inside the loop, and initialization can be done outside
 the loop
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int i;
\end_layout

\begin_layout Plain Layout

i = 0; // move initialization out of loop
\end_layout

\begin_layout Plain Layout

for(; i < 10; ) {
\end_layout

\begin_layout Plain Layout

	System.out.println("Pass #" + i);
\end_layout

\begin_layout Plain Layout

	i++; // increment loop control var
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for(num = 1.0; num < 100.0; num++) { ...
 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for(i=0, j=10; i < j; i++, j--){}  // OK to have two variables, separated
 by comma
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Loop with array
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for(type itr-var : collection) statement-block
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
type 
\series default
specifies the type, 
\end_layout

\begin_layout Itemize

\series bold
itr-var 
\series default
specifies the name of an iteration variable that will receive the elements
 from a collection, one at a time, from beginning to end.
 
\end_layout

\begin_layout Itemize
The 
\series bold
collection
\series default
 being cycled through is specified by collection.
 There are various types of collections that can be used with the for, but
 the only type used in this book is the array
\end_layout

\begin_deeper
\begin_layout Itemize
Its iteration variable is “read-only” as it relates to the underlying array.
 You can’t change the contents of the array by assigning the iteration variable
 a new value.
\end_layout

\end_deeper
\begin_layout Standard
Example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int nums[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
\end_layout

\begin_layout Plain Layout

int sum = 0;
\end_layout

\begin_layout Plain Layout

for(int x: nums) sum += x;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Loop with 2-dimentional arrary
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for(int x[] : nums) {
\end_layout

\begin_layout Plain Layout

	for(int y : x) {
\end_layout

\begin_layout Plain Layout

		System.out.println("Value is: " + y);
\end_layout

\begin_layout Plain Layout

		sum += y;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
break
\end_layout

\begin_layout Standard
stop the loop where it belongs.
 If it is a nested loop, break will only stop loop at its level
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for(int x : nums) {
\end_layout

\begin_layout Plain Layout

	System.out.println("Value is: " + x);
\end_layout

\begin_layout Plain Layout

	sum += x;
\end_layout

\begin_layout Plain Layout

	if(x == 5) break; // stop the loop when 5 is obtained
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Continue
\end_layout

\begin_layout Subsection
Recursion
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// A simple example of recursion.
\end_layout

\begin_layout Plain Layout

class Factorial {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// This is a recursive function.
\end_layout

\begin_layout Plain Layout

	int factR(int n) {
\end_layout

\begin_layout Plain Layout

		int result;
\end_layout

\begin_layout Plain Layout

		if(n==1) return 1; // recusive function must have a stop condition.
\end_layout

\begin_layout Plain Layout

		result = factR(n-1) * n;
\end_layout

\begin_layout Plain Layout

		return result;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// This is an iterative equivalent.
\end_layout

\begin_layout Plain Layout

	int factI(int n) {
\end_layout

\begin_layout Plain Layout

		int t, result;
\end_layout

\begin_layout Plain Layout

		result = 1;
\end_layout

\begin_layout Plain Layout

		for(t=1; t <= n; t++) result *= t;
\end_layout

\begin_layout Plain Layout

		return result;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Varargs
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

int doIt(int a, int b, double c, int ...
 vals) {
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
valsis operated on as an array.
 This is because vals is an array.
 The ...
 syntax simply tells the compiler that a variable number of arguments will
 be used, and that these arguments will be stored in the array referred
 to by vals.
 The ...
 arguments are automatically put in an array and passed to vals.
\end_layout

\begin_layout Itemize
vararg parameter can be empty
\end_layout

\begin_layout Itemize
the varargs parameter must be last
\end_layout

\begin_layout Section
If
\end_layout

\begin_layout Subsection
switch Statement
\end_layout

\begin_layout Itemize
need break at the end of each case
\end_layout

\begin_layout Itemize
need a default choice at the last
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case "connect":
\end_layout

\begin_layout Plain Layout

	System.out.println("Connecting");
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

case "cancel":
\end_layout

\begin_layout Plain Layout

	System.out.println("Canceling");
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

case "disconnect":
\end_layout

\begin_layout Plain Layout

	System.out.println("Disconnecting");
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

default:
\end_layout

\begin_layout Plain Layout

	System.out.println("Command Error!");
\end_layout

\begin_layout Plain Layout

	break;
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Operator 
\end_layout

\begin_layout Subsection
++
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sum += i++
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In other words, this statement says, “Add to sum the value of sum plus i,
 then increment i.” Thus, it is the same as this sequence of statements:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

sum = sum + i;
\end_layout

\begin_layout Plain Layout

i++;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Shift Operators
\end_layout

\begin_layout Standard
p171 beginner;s guid
\end_layout

\begin_layout Standard
In Java it is possible to shift the bits that make up a value to the left
 or to the right by a specified amount.
 Java defines the three bit-shift operators shown here: 
\end_layout

\begin_layout Standard
<< Left shift
\end_layout

\begin_layout Standard
>> Right shift 
\end_layout

\begin_layout Standard
>>> Unsigned right shift
\end_layout

\begin_layout Part
J Class
\end_layout

\begin_layout Section
Creat a Class
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ClassName {
\end_layout

\begin_layout Plain Layout

	// declare instance variables
\end_layout

\begin_layout Plain Layout

	type Var1;
\end_layout

\begin_layout Plain Layout

	type Var2;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// declare methods 
\end_layout

\begin_layout Plain Layout

	type Method1(type Parameters) {
\end_layout

\begin_layout Plain Layout

	// body of method
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	type Method2(type Parameters) {
\end_layout

\begin_layout Plain Layout

	// body of method
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Terms
\end_layout

\begin_layout Itemize

\series bold
instance variables (MemberVar): 
\end_layout

\begin_deeper
\begin_layout Itemize
defined at the top of class block
\end_layout

\begin_layout Itemize
Each time you create an instance of a class, you are creating an object
 that contains its own copy of each instance variable defined by the class.
\end_layout

\begin_layout Itemize
They can be later accessed/redefined as using dot.
 ClassObject.MemerVar
\end_layout

\end_deeper
\begin_layout Itemize
Objects (ClassObject) = Instances of Class : uses a class specification
 to construct objects.
 Objects are instances of a class.
\end_layout

\begin_layout Subsection
Controlling Access to Class Members: private / public
\end_layout

\begin_layout Standard
Restricting access to a class’ members is a fundamental part of object-oriented
 programming because it helps prevent the misuse of an object.
 Although Java’s approach is a bit more sophisticated, in essence, there
 are two basic types of class members: public and private.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class MyClass {
\end_layout

\begin_layout Plain Layout

	private int alpha; // private access
\end_layout

\begin_layout Plain Layout

	public int beta; // public access
\end_layout

\begin_layout Plain Layout

	int gamma; // default access
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
private: Because alpha is private, it cannot be accessed by code outside
 of its class.
 But you can still directly refer it within the ClassDefine block
\end_layout

\begin_layout Itemize
bt default, if no private / public is specified, then the member is public.
\end_layout

\begin_layout Subsection
Constructors: Quick/Flexible Initiation of an Instance
\end_layout

\begin_layout Itemize
Usage: A constructor can 
\end_layout

\begin_deeper
\begin_layout Enumerate
initialize an ClassObject and 
\end_layout

\begin_layout Enumerate
at the same time assign references/values to MemberVars
\end_layout

\begin_layout Enumerate
Define some start actions
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class MyThread implements Runnable {
\end_layout

\begin_layout Plain Layout

	Thread thrd;
\end_layout

\begin_layout Plain Layout

	TickTock ttOb;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Construct a new thread.
\end_layout

\begin_layout Plain Layout

	MyThread(String name, TickTock tt) {
\end_layout

\begin_layout Plain Layout

		thrd = new Thread(this, name);
\end_layout

\begin_layout Plain Layout

		ttOb = tt;
\end_layout

\begin_layout Plain Layout

		thrd.start(); // start actions
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
All classes have constructors, whether you define one or not, which are
 zero, null, and false, for numeric types, reference types, and booleans,
 respectively.
\end_layout

\end_deeper
\begin_layout Itemize
Basic Format
\end_layout

\begin_deeper
\begin_layout Itemize
To define a Constructor, it must have the same name as Class itself.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ClassName{
\end_layout

\begin_layout Plain Layout

	int X ;// a memebr instance
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// this is a Constructor
\end_layout

\begin_layout Plain Layout

	ClassName(type Parameters){
\end_layout

\begin_layout Plain Layout

		x = i 
\end_layout

\begin_layout Plain Layout

		// and other actions
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Vehicle {
\end_layout

\begin_layout Plain Layout

	int passengers; // number of passengers
\end_layout

\begin_layout Plain Layout

	int fuelcap; // fuel capacity in gallons
\end_layout

\begin_layout Plain Layout

	int mpg; // fuel consumption in miles per gallon
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// This is a constructor for Vehicle.
\end_layout

\begin_layout Plain Layout

	Vehicle(int p, int f, int m) {
\end_layout

\begin_layout Plain Layout

		passengers = p;
\end_layout

\begin_layout Plain Layout

		fuelcap = f;
\end_layout

\begin_layout Plain Layout

		mpg = m;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	// Return the range.
\end_layout

\begin_layout Plain Layout

	int range() {
\end_layout

\begin_layout Plain Layout

		return mpg * fuelcap;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	// Compute fuel needed for a given distance.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	double fuelneeded(int miles) {
\end_layout

\begin_layout Plain Layout

		return (double) miles / mpg;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Use the constructor 
\end_layout

\begin_layout Plain Layout

// initialize an ClassObject and 
\end_layout

\begin_layout Plain Layout

// at the same time assign references/values to MemberVars
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vehicle minivan = new Vehicle(7, 16, 21);
\end_layout

\begin_layout Plain Layout

Vehicle sportscar = new Vehicle(2, 14, 12);
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Methods
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

returntype Method1(parameters) {
\end_layout

\begin_layout Plain Layout

	// body of method
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
returntype
\series default
 specifies the type of data returned by the method.
 This can be any valid type, including class types that you creating
\end_layout

\begin_deeper
\begin_layout Itemize
If the method does not return a value, its return type must be 
\series bold
void
\series default
.
 
\end_layout

\begin_layout Itemize

\series bold
return X : you must write keyword return to return an object
\end_layout

\begin_deeper
\begin_layout Itemize
return will cause all the following codes within that method not running.
\end_layout

\end_deeper
\begin_layout Itemize
The return type of a method is important because the type of data returned
 by a method must be compatible with the return type specified by the method.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Namespace
\series default
: 
\end_layout

\begin_deeper
\begin_layout Itemize
the instance variables (MemberVar) can be directly used when define a method,
 no need to write ClassObject.ClassMember, you can directly write ClassMemeber.
\end_layout

\begin_layout Itemize
OR, you can use this.Memebr to access them within the class definition block.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Argument
\series default
: 
\end_layout

\begin_deeper
\begin_layout Itemize
a value passed to a method is called an argument.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Parameter
\series default
: Inside the method, the variable that receives the argument is called a
 parameter.
\end_layout

\begin_deeper
\begin_layout Itemize
parameter must be initialized
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ChkNum {
\end_layout

\begin_layout Plain Layout

	// return true if x is even
\end_layout

\begin_layout Plain Layout

	boolean isEven(int x) { //parameter must be initialized
\end_layout

\begin_layout Plain Layout

		if((x%2) == 0) return true;
\end_layout

\begin_layout Plain Layout

		else return false;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Signature
\series default
: As it applies to Java, a signature is the name of a method plus its parameter
 list.
 Thus, for the purposes of overloading, no two methods within the same class
 can have the same signature.
 Notice that a signature does not include the return type, since it is not
 used by Java for overload resolution.
\end_layout

\begin_layout Standard
Example 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Vehicle {
\end_layout

\begin_layout Plain Layout

	int passengers; // number of passengers
\end_layout

\begin_layout Plain Layout

	int fuelcap; // fuel capacity in gallons
\end_layout

\begin_layout Plain Layout

	int mpg; // fuel consumption in miles per gallon
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Return the range.
\end_layout

\begin_layout Plain Layout

	int range() {
\end_layout

\begin_layout Plain Layout

		return mpg * fuelcap; // directly use the ClassMember
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Method Tricks
\end_layout

\begin_layout Standard
Different methods defined within the class has no implementation orders.
 
\end_layout

\begin_layout Section
this
\end_layout

\begin_layout Standard

\series bold
this
\series default
 means the class instance itself.
\end_layout

\begin_layout Subsection
this - to refer a Class Instance itself.
\end_layout

\begin_layout Standard
Within an instance method or a constructor, this is a reference to the current
 object — the object whose method or constructor is being called.
 You can refer to any member of the current object from within an instance
 method or a constructor by using this.
\end_layout

\begin_layout Itemize
The most common reason for using the this keyword is because a field is
 shadowed by a method or constructor parameter.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Point {
\end_layout

\begin_layout Plain Layout

    public int x = 0;
\end_layout

\begin_layout Plain Layout

    public int y = 0;
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

    //constructor
\end_layout

\begin_layout Plain Layout

    public Point(int a, int b) {
\end_layout

\begin_layout Plain Layout

        x = a;
\end_layout

\begin_layout Plain Layout

        y = b;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//but it could have been written like this:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public class Point {
\end_layout

\begin_layout Plain Layout

    public int x = 0;
\end_layout

\begin_layout Plain Layout

    public int y = 0;
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

    //constructor
\end_layout

\begin_layout Plain Layout

    public Point(int x, int y) {
\end_layout

\begin_layout Plain Layout

        this.x = x;
\end_layout

\begin_layout Plain Layout

        this.y = y;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
this -- in a Constructor
\end_layout

\begin_layout Standard
This class contains a set of constructors.
 Each constructor initializes some or all of the rectangle's member variables.
 The constructors provide a default value for any member variable whose
 initial value is not provided by an argument.
 For example, the no-argument constructor creates a 1x1 Rectangle at coordinates
 0,0.
 The two-argument constructor calls the four-argument constructor, passing
 in the width and height but always using the 0,0 coordinates.
 
\end_layout

\begin_layout Standard
As before, the compiler determines which constructor to call, based on the
 number and the type of arguments.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public class Rectangle {
\end_layout

\begin_layout Plain Layout

    private int x, y;
\end_layout

\begin_layout Plain Layout

    private int width, height;
\end_layout

\begin_layout Plain Layout

        
\end_layout

\begin_layout Plain Layout

    public Rectangle() {
\end_layout

\begin_layout Plain Layout

        this(0, 0, 1, 1);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    public Rectangle(int width, int height) {
\end_layout

\begin_layout Plain Layout

        this(0, 0, width, height);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    public Rectangle(int x, int y, int width, int height) {
\end_layout

\begin_layout Plain Layout

        this.x = x;
\end_layout

\begin_layout Plain Layout

        this.y = y;
\end_layout

\begin_layout Plain Layout

        this.width = width;
\end_layout

\begin_layout Plain Layout

        this.height = height;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    ...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
this -- 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class SumArray {
\end_layout

\begin_layout Plain Layout

	private int sum;
\end_layout

\begin_layout Plain Layout

	synchronized int sumArray(int nums[]) {   //sumArray( ) is synchronized.
\end_layout

\begin_layout Plain Layout

		sum = 0; // reset sum
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		for(int i=0; i<nums.length; i++) {
\end_layout

\begin_layout Plain Layout

			sum += nums[i];
\end_layout

\begin_layout Plain Layout

			System.out.println("Running total for " +
\end_layout

\begin_layout Plain Layout

			Thread.currentThread().getName() +
\end_layout

\begin_layout Plain Layout

			" is " + sum);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			try {
\end_layout

\begin_layout Plain Layout

				Thread.sleep(10); // allow task-switch
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

				System.out.println("Thread interrupted.");
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	return sum;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class MyThread implements Runnable {
\end_layout

\begin_layout Plain Layout

	Thread thrd;
\end_layout

\begin_layout Plain Layout

	static SumArray sa = new SumArray(); // use SumArray class defined above
 to define a new static variable SumArray
\end_layout

\begin_layout Plain Layout

	int a[];
\end_layout

\begin_layout Plain Layout

	int answer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Construct a new thread.
\end_layout

\begin_layout Plain Layout

	MyThread(String name, int nums[]) {
\end_layout

\begin_layout Plain Layout

		thrd = new Thread(this, name);
\end_layout

\begin_layout Plain Layout

		a = nums;
\end_layout

\begin_layout Plain Layout

		thrd.start(); // start the thread
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Begin execution of new thread.
\end_layout

\begin_layout Plain Layout

	public void run() {
\end_layout

\begin_layout Plain Layout

		int sum;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		System.out.println(thrd.getName() + " starting.");
\end_layout

\begin_layout Plain Layout

		answer = sa.sumArray(a);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		System.out.println("Sum for " + thrd.getName() +
\end_layout

\begin_layout Plain Layout

		" is " + answer);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		System.out.println(thrd.getName() + " terminating.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Sync {
\end_layout

\begin_layout Plain Layout

	public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

		int a[] = {1, 2, 3, 4, 5};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		MyThread mt1 = new MyThread("Child #1", a);
\end_layout

\begin_layout Plain Layout

		MyThread mt2 = new MyThread("Child #2", a);
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			mt1.thrd.join();
\end_layout

\begin_layout Plain Layout

			mt2.thrd.join();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Main thread interrupted.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Child #1 starting.
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 1
\end_layout

\begin_layout Plain Layout

Child #2 starting.
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 3 
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 6
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 10
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 15  
\end_layout

\begin_layout Plain Layout

Sum for Child #1 is 15
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Child #1 terminating.
 // "synchronized" prevent other instance to access method sumArray until
 it is unlocked
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 1
\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 3
\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 6
\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 10
\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 15
\end_layout

\begin_layout Plain Layout

Sum for Child #2 is 15
\end_layout

\begin_layout Plain Layout

Child #2 terminating.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Static
\end_layout

\begin_layout Subsection
Static member
\end_layout

\begin_layout Standard
Normally a class member must be accessed through an object of its class,
 but it is possible to create a member that can be used by itself, without
 reference to a specific instance.
 To create such a member, precede its declaration with the keyword static.
 When a member is declared static.
\end_layout

\begin_layout Itemize
To access Traditional ClassMember: ClassObject.ClassMember
\end_layout

\begin_layout Itemize
To access static ClassMember: ClassName.ClassMember
\end_layout

\begin_deeper
\begin_layout Itemize
For example, if you want to assign the value 10 to a static variable called
 count that is part of the Timer class, use this line:
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Timer.count = 10;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The most common example of a static member is main( ).
 main( ) is declared as static because it must be called by the JVM when
 your program begins.
 Outside the class, to use a static member, you need only specify the name
 of its class followed by the dot operator.
 No object needs to be created
\end_layout

\begin_layout Itemize

\series bold
Variables declared as static are, essentially, global variables.
\end_layout

\begin_layout Itemize

\series bold
As you can see, the static variable y is shared by both ob1 and ob2.
 Changing it affects the entire class, not just an instance.
\end_layout

\begin_deeper
\begin_layout Itemize
So you can use this global behavior to control all instances under the same
 class.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class StaticDemo {
\end_layout

\begin_layout Plain Layout

	int x; // a normal instance variable
\end_layout

\begin_layout Plain Layout

	static int y; // a static variable
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Return the sum of the instance variable x
\end_layout

\begin_layout Plain Layout

	// and the static variable y.
\end_layout

\begin_layout Plain Layout

	int sum() {
\end_layout

\begin_layout Plain Layout

	return x + y;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// usage: no need to create an instance
\end_layout

\begin_layout Plain Layout

StaticDemo.y = 19;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
static method
\end_layout

\begin_layout Standard
The difference between a static method and a normal method is that the static
 method is called through its class name, without any object of that class
 being created.
\end_layout

\begin_layout Standard
Methods declared as static have several restrictions:
\end_layout

\begin_layout Standard
● They can directly call only other static methods.
\end_layout

\begin_layout Standard
● They can directly access only static data.
\end_layout

\begin_layout Standard
● They do not have a this reference
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class StaticMeth {
\end_layout

\begin_layout Plain Layout

	static int val = 1024; // a static variable
\end_layout

\begin_layout Plain Layout

	// a static method
\end_layout

\begin_layout Plain Layout

	static int valDiv2() {
\end_layout

\begin_layout Plain Layout

		return val/2;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

taticMeth.valDiv2()
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Static Blocks
\end_layout

\begin_layout Itemize
Static block is mostly used for changing the default values of static variables.T
his block gets executed when the class is loaded in the memory.
\end_layout

\begin_layout Itemize
It serves the same functionality of a constructor.
\end_layout

\begin_layout Itemize
It's useful since the above static field could not have been initialized
 using StaticBlock.rootOf2 =
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class StaticBlock {
\end_layout

\begin_layout Plain Layout

	static double rootOf2;
\end_layout

\begin_layout Plain Layout

	static double rootOf3;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	static {
\end_layout

\begin_layout Plain Layout

		System.out.println("Inside static block.");
\end_layout

\begin_layout Plain Layout

		rootOf2 = Math.sqrt(2.0);
\end_layout

\begin_layout Plain Layout

		rootOf3 = Math.sqrt(3.0);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	StaticBlock(String msg) {
\end_layout

\begin_layout Plain Layout

		System.out.println(msg);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Nested and Inner Classes
\end_layout

\begin_layout Section
Use a Class
\end_layout

\begin_layout Subsection
Creat a Class Objects
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Classname ClassObject = new Classname();
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
Step 1: Classname ObjectToDefine ---- is to 
\series bold
declare
\series default
 a variable called ClassObject (minivan).
 At this point, minivan does not refer to an object.
\end_layout

\begin_layout Enumerate
Step 2: new Classname() --- creates a physical copy of the object and assigns
 to minivan a ClassObject to that object Classname();.
 This is done by using the new operator.
 Here it creates a new Vehicle object and assigns a reference to it to minivan.
 Now, minivan is linked with an object.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class Vehicle {
\end_layout

\begin_layout Plain Layout

	int passengers; // number of passengers
\end_layout

\begin_layout Plain Layout

	int fuelcap; // fuel capacity in gallons
\end_layout

\begin_layout Plain Layout

	int mpg; // fuel consumption in miles per gallon	
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// To use a class
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vehicle minivan = new Vehicle(); // create a Vehicle object called minivan
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
keyword: new
\end_layout

\begin_layout Standard
new can be used to create an object of any class type.
 The new operator returns a reference to the newly created object, which
 (in this case) is assigned to class-var.
\end_layout

\begin_layout Standard
Usage
\end_layout

\begin_layout Itemize
Create a ClassObject
\end_layout

\begin_layout Itemize
Create an array.
\end_layout

\begin_layout Subsection
Call the method
\end_layout

\begin_layout Standard

\series bold
instance.method(parameter)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

minivan.range(parameter);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Access/Assign values to Class (Instance) Members
\end_layout

\begin_layout Standard
you can use the dot operator to access both instance variables and methods.
\end_layout

\begin_layout Itemize
ClassObject.ClassMember
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

minivan.fuelcap = 16;
\end_layout

\end_inset


\end_layout

\begin_layout Section
Namespace, Overloading Polymorphism
\end_layout

\begin_layout Subsection
Mutate Arguments inside the Method
\end_layout

\begin_layout Itemize
When you pass 
\series bold
a primitive type
\series default
, such as int or double, to a method, it is passed by value.
 Thus, a copy of the argument is made, and what occurs to the parameter
 that receives the argument has no effect outside the method.
\end_layout

\begin_layout Itemize
When you pass 
\series bold
an object to a method
\series default
, the situation changes dramatically, because objects are implicitly passed
 by reference.
 Keep in mind that when you create a variable of a class type, you are creating
 a reference to an object.
 It is the reference, not the object itself, that is actually passed to
 the method.
\end_layout

\begin_layout Subsection
Method Overloading & Polymorphism
\end_layout

\begin_layout Standard
In Java, two or more methods within the same class can share the same name,
 as long as their parameter declarations are different.
 When this is the case, the methods are said to be overloaded, and the process
 is referred to as method overloading.
 Method overloading is one of the ways that Java implements polymorphism.
\end_layout

\begin_layout Itemize
You must observe one important restriction: the type and/or number of the
 parameters of each overloaded method must differ.
\end_layout

\begin_layout Itemize
Java provides certain automatic type conversions.
 These conversions also apply to parameters of overloaded methods.
 For example, consider the following:
\end_layout

\begin_deeper
\begin_layout Itemize
In this example, only two versions of f( ) are defined: one that has an
 int parameter and one that has a double parameter.
 However, it is possible to pass f( ) a byte, short, or float value.
 In the case of byte and short, Java automatically converts them to int.
 Thus, f(int) is invoked.
 In the case of float, the value is converted to double and f(double) is
 called.
\end_layout

\begin_layout Itemize
In this version, since there is a version of f( ) that takes a byte argument,
 when f( ) is called with a byte argument, f(byte) is invoked and the automatic
 conversion to int does not occur.
\end_layout

\end_deeper
\begin_layout Subsection
Overloading Constructors
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class MyClass {
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	int x;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Construct objects in a variety of ways.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	MyClass() {
\end_layout

\begin_layout Plain Layout

	System.out.println("Inside MyClass().");
\end_layout

\begin_layout Plain Layout

	x = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	MyClass(double d) {
\end_layout

\begin_layout Plain Layout

	System.out.println("Inside MyClass(double).");
\end_layout

\begin_layout Plain Layout

	x = (int) d;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	MyClass(int i, int j) {
\end_layout

\begin_layout Plain Layout

	System.out.println("Inside MyClass(int, int).");
\end_layout

\begin_layout Plain Layout

	x = i * j;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One of the most common reasons that constructors are overloaded is to allow
 one object to initialize another
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Summation(Summation ob)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Reference, Copy and Assignment
\end_layout

\begin_layout Standard
Terms:
\end_layout

\begin_layout Itemize
Object: the value stored in memory.
 Itself has no name.
 But it does have position at the RAM.
\end_layout

\begin_layout Itemize
Variables: We can only directly interact with them.
 They are just the frontdoor of an object, they are just the name.
 
\end_layout

\begin_layout Itemize
Reference: 
\end_layout

\begin_deeper
\begin_layout Itemize
a relation between Variable and Object
\end_layout

\end_deeper
\begin_layout Standard
Reference Rules
\end_layout

\begin_layout Itemize
When you assign one primitive-type variable to another, the situation is
 straightforward.
 The variable on the left receives a copy of the value of the variable on
 the right.
\end_layout

\begin_layout Itemize
When you assign one object reference variable to another, the situation
 is a bit more complicated because you are changing the object that the
 reference variable refers to.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Vehicle car1 = new Vehicle();
\end_layout

\begin_layout Plain Layout

Vehicle car2 = car1;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Instead, car1 and car2 will both refer to the same object.
\end_layout

\begin_layout Itemize
Later, if you change car1, car2 will automatically changed.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

car1.mpg = 26;
\end_layout

\begin_layout Plain Layout

executes, both of these println( ) statements
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

System.out.println(car1.mpg);
\end_layout

\begin_layout Plain Layout

System.out.println(car2.mpg);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

display the same value: 26.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Inheritance
\end_layout

\begin_layout Standard
A class that is inherited is called a superclass.
 The class that does the inheriting is called a subclass.
\end_layout

\begin_layout Itemize
All public memers and methods of SuperClass are also memebers & methods
 in SubClass
\end_layout

\begin_deeper
\begin_layout Itemize
Within subclass, all public members and methods can be directly accessed
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class TwoDShape {
\end_layout

\begin_layout Plain Layout

	double width;
\end_layout

\begin_layout Plain Layout

	double height;	
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class Triangle extends TwoDShape {
\end_layout

\begin_layout Plain Layout

	String style;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// All members of Triangle are available to Triangle objects, even those
 inherited from TwoDShape.
\end_layout

\begin_layout Plain Layout

t1.width = 4.0;
\end_layout

\begin_layout Plain Layout

t1.height = 4.0;
\end_layout

\begin_layout Plain Layout

t1.style = "filled";
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Multi-Level Inheritance
\end_layout

\begin_deeper
\begin_layout Itemize
ColorTriangle inherits Triangle, which is descended from TwoDShape, so ColorTria
ngle includes all members of Triangle and TwoDShape.
\end_layout

\end_deeper
\begin_layout Subsection
Constructor Execution Order 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Demonstrate when constructors are executed.
\end_layout

\begin_layout Plain Layout

// Create a super class.
\end_layout

\begin_layout Plain Layout

class A {
\end_layout

\begin_layout Plain Layout

	A() {
\end_layout

\begin_layout Plain Layout

	System.out.println("Constructing A.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Create a subclass by extending class A.
\end_layout

\begin_layout Plain Layout

class B extends A {
\end_layout

\begin_layout Plain Layout

	B() {
\end_layout

\begin_layout Plain Layout

	System.out.println("Constructing B.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Create another subclass by extending B.
\end_layout

\begin_layout Plain Layout

class C extends B {
\end_layout

\begin_layout Plain Layout

	C() {
\end_layout

\begin_layout Plain Layout

	System.out.println("Constructing C.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class OrderOfConstruction {
\end_layout

\begin_layout Plain Layout

	public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

	C c = new C();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The output from this program is shown here:
\end_layout

\begin_layout Plain Layout

Constructing A.
\end_layout

\begin_layout Plain Layout

Constructing B.
\end_layout

\begin_layout Plain Layout

Constructing C.
\end_layout

\begin_layout Plain Layout

As you can see, the constructors are executed in order of derivation.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Create a Subclass: Extends
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class SubClassName extends SuperClassName {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Super-Sub Class Refer Compatibility
\end_layout

\begin_layout Standard
As you know, Java is a strongly typed language.
 Aside from the standard conversions and automatic promotions that apply
 to its primitive types, type compatibility is strictly enforced.
\end_layout

\begin_layout Itemize
There is, however, an important exception to Java’s strict type enforcement.
 A reference variable of a superclass can be assigned a reference to an
 object of any subclass derived from that superclass.
\end_layout

\begin_layout Itemize
Superclass reference variable can refer to a subclass object.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// A superclass reference can refer to a subclass object.
\end_layout

\begin_layout Plain Layout

class X {
\end_layout

\begin_layout Plain Layout

	int a;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	X(int i) { a = i; }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Y extends X {
\end_layout

\begin_layout Plain Layout

	int b;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	Y(int i, int j) {
\end_layout

\begin_layout Plain Layout

		super(j);
\end_layout

\begin_layout Plain Layout

		b = i;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class SupSubRef {
\end_layout

\begin_layout Plain Layout

	public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

		X x = new X(10);
\end_layout

\begin_layout Plain Layout

		X x2;
\end_layout

\begin_layout Plain Layout

		Y y = new Y(5, 6);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		x2 = x; // OK, both of same type
\end_layout

\begin_layout Plain Layout

		System.out.println("x2.a: " + x2.a);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		x2 = y; // still Ok because Y is derived from X
\end_layout

\begin_layout Plain Layout

		System.out.println("x2.a: " + x2.a);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// X references know only about X members
\end_layout

\begin_layout Plain Layout

		x2.a = 19; // OK
\end_layout

\begin_layout Plain Layout

		// x2.b = 27; // Error, X doesn't have a b member
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
It is important to understand that it is the type of the reference variable—not
 the type of the object that it refers to—that determines what members can
 be accessed.
 That is, when
\series bold
 a reference to a subclass object
\series default
 is assigned 
\series bold
to a superclass reference variable
\series default
, y
\series bold
ou will have access only to those parts of the object defined by the superclass.
\end_layout

\begin_deeper
\begin_layout Itemize
An important place where subclass references are assigned to superclass
 variables is when constructors are called in a class hierarchy.
 As you know, it is common for a class to define a constructor that takes
 an object of the class as a parameter.
 This allows the class to construct a copy of an object.
 Subclasses of such a class can take advantage of this feature.
\end_layout

\begin_deeper
\begin_layout Itemize
p249
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Polymorphism: Method Overloading / Overriding
\end_layout

\begin_layout Itemize

\series bold
Overrides
\series default
: In a class hierarchy, when a method in a subclass has the
\series bold
 same return type and signatur
\series default
e as a method in its superclass, then the method in the subclass is said
 to 
\series bold
override
\series default
 the method in the superclass
\series bold
.
 Overrides
\series default
: When show( ) is invoked on an object of type B, the version of show( )
 defined within B is used.
 That is, the version of show( ) inside B 
\series bold
overrides
\series default
 the version declared in A.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class B extends A {
\end_layout

\begin_layout Plain Layout

	int k;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	B(int a, int b, int c) {
\end_layout

\begin_layout Plain Layout

		super(a, b);
\end_layout

\begin_layout Plain Layout

		k = c;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void show() {
\end_layout

\begin_layout Plain Layout

	super.show(); // this calls A’s show() 
\end_layout

\begin_layout Plain Layout

	//Use super to call the version of show( ) defined by superclass A.
\end_layout

\begin_layout Plain Layout

	System.out.println("k: " + k);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Overload
\series default
: Because signatures differ, this show( ) simply overloads show( ) in superclass
 A
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class A {
\end_layout

\begin_layout Plain Layout

	int i, j;
\end_layout

\begin_layout Plain Layout

	A(int a, int b) {
\end_layout

\begin_layout Plain Layout

		i = a;
\end_layout

\begin_layout Plain Layout

		j = b;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// display i and j
\end_layout

\begin_layout Plain Layout

void show() {
\end_layout

\begin_layout Plain Layout

	System.out.println("i and j: " + i + " " + j);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Create a subclass by extending class A.
\end_layout

\begin_layout Plain Layout

class B extends A {
\end_layout

\begin_layout Plain Layout

	int k;
\end_layout

\begin_layout Plain Layout

	B(int a, int b, int c) {
\end_layout

\begin_layout Plain Layout

		super(a, b);
\end_layout

\begin_layout Plain Layout

		k = c;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// overload show()
\end_layout

\begin_layout Plain Layout

void show(String msg) {
\end_layout

\begin_layout Plain Layout

	System.out.println(msg + k);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
When different types of objects are referred to, different versions of an
 overridden method will be called.
 In other words, it is the type of the object being referred to (not the
 type of the reference variable) that determines which version of an overridden
 method will be executed.
 Therefore, if a superclass contains a method that is overridden by a subclass,
 then when different types of objects are referred to through a superclass
 reference variable, different versions of the method are executed.
\end_layout

\begin_deeper
\begin_layout Itemize
p254
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Demonstrate dynamic method dispatch.
\end_layout

\begin_layout Plain Layout

class Sup {
\end_layout

\begin_layout Plain Layout

	void who() {
\end_layout

\begin_layout Plain Layout

	System.out.println("who() in Sup");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Sub1 extends Sup {
\end_layout

\begin_layout Plain Layout

	void who() {
\end_layout

\begin_layout Plain Layout

	System.out.println("who() in Sub1");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Sub2 extends Sup {
\end_layout

\begin_layout Plain Layout

	void who() {
\end_layout

\begin_layout Plain Layout

	System.out.println("who() in Sub2");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class DynDispDemo {
\end_layout

\begin_layout Plain Layout

	public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

		Sup superOb = new Sup();
\end_layout

\begin_layout Plain Layout

		Sub1 subOb1 = new Sub1();
\end_layout

\begin_layout Plain Layout

		Sub2 subOb2 = new Sub2();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//In each case, the version of who( ) to call is determined at run time
 by the type of object being referred to.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		Sup supRef;
\end_layout

\begin_layout Plain Layout

		supRef = superOb;
\end_layout

\begin_layout Plain Layout

		supRef.who();
\end_layout

\begin_layout Plain Layout

		supRef = subOb1;
\end_layout

\begin_layout Plain Layout

		supRef.who();
\end_layout

\begin_layout Plain Layout

		supRef = subOb2;
\end_layout

\begin_layout Plain Layout

		supRef.who();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

The output from the program is shown here:
\end_layout

\begin_layout Plain Layout

who() in Sup
\end_layout

\begin_layout Plain Layout

who() in Sub1
\end_layout

\begin_layout Plain Layout

who() in Sub2
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Abstract Classes
\end_layout

\begin_layout Itemize
Such a class determines the nature of the methods that the subclasses must
 implement but does not, itself, provide an implementation of one or more
 of these methods.
 
\end_layout

\begin_deeper
\begin_layout Itemize
One way this situation can occur is when a superclass is unable to create
 a meaningful implementation for a method.
 This is the case with the version of TwoDShape used in the preceding example.
\end_layout

\end_deeper
\begin_layout Itemize
A class that contains one or more abstract methods must also be declared
 as abstract by preceding its class declaration with the abstract modifier.
\end_layout

\begin_deeper
\begin_layout Itemize
Since an abstract class does not define a complete implementation, there
 can be no objects of an abstract class.
 Thus, attempting to create an object of an abstract class by using new
 will result in a compile-time error.
\end_layout

\begin_layout Itemize
ALL subclasses of SuperClass must override ALL the abstract method.
\end_layout

\end_deeper
\begin_layout Standard
Example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Create an abstract class.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

abstract class TwoDShape {
\end_layout

\begin_layout Plain Layout

	private double width;
\end_layout

\begin_layout Plain Layout

	private double height;
\end_layout

\begin_layout Plain Layout

	private String name;
\end_layout

\begin_layout Plain Layout

	.....
\end_layout

\begin_layout Plain Layout

	// Now, area() is abstract.
\end_layout

\begin_layout Plain Layout

	abstract double area();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// A subclass of TwoDShape for triangles.
\end_layout

\begin_layout Plain Layout

class Triangle extends TwoDShape {
\end_layout

\begin_layout Plain Layout

	double area() {
\end_layout

\begin_layout Plain Layout

		return getWidth() * getHeight(); // implement the abstrat method
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
final method
\end_layout

\begin_layout Itemize
As powerful and useful as method overriding and inheritance are, sometimes
 you will want to prevent them.
 
\end_layout

\begin_layout Itemize
For example, you might have a class that encapsulates control of some hardware
 device.
 Further, this class might offer the user the ability to initialize the
 device, making use of private, proprietary information.
 In this case, you don’t want users of your class to be able to override
 the initialization method.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class A {
\end_layout

\begin_layout Plain Layout

	final void meth() {
\end_layout

\begin_layout Plain Layout

		System.out.println("This is a final method.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

class B extends A {
\end_layout

\begin_layout Plain Layout

	void meth() { // ERROR! Can't override.
\end_layout

\begin_layout Plain Layout

		System.out.println("Illegal!");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Because meth( ) is declared as final, it cannot be overridden in B.
 If you attempt to do so, a compile-time error will result.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
final class
\end_layout

\begin_layout Standard
You can prevent a class from being inherited by preceding its declaration
 with final.
 Declaring a class as final implicitly declares all of its methods as final,
 too.
 As you might expect, it is illegal to declare a class as both abstract
 and final.
\end_layout

\begin_layout Subsection
final member
\end_layout

\begin_layout Standard
Using final with Data Members In addition to the uses of final just shown,
 final can also be applied to member variables to create what amounts to
 named constants.
 
\end_layout

\begin_layout Standard
If you precede a class variable’s name with final, its value cannot be changed
 throughout the lifetime of your program.
 You can, of course, give that variable an initial value.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ErrorMsg {
\end_layout

\begin_layout Plain Layout

	// Error codes.
\end_layout

\begin_layout Plain Layout

	final int OUTERR = 0;
\end_layout

\begin_layout Plain Layout

	final int INERR = 1;
\end_layout

\begin_layout Plain Layout

	final int DISKERR = 2;
\end_layout

\begin_layout Plain Layout

	final int INDEXERR = 3;
\end_layout

\end_inset


\end_layout

\begin_layout Section
Package
\end_layout

\begin_layout Itemize
Package gives you a way to partition the namespace.
\end_layout

\begin_layout Itemize
Package provides a means by which classes can be encapsulated.
\end_layout

\begin_layout Subsection
Example: create and use
\end_layout

\begin_layout Standard
the examples shown in this book is to simply create the package directories
 below your current development directory,
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// A short package demonstration.
\end_layout

\begin_layout Plain Layout

package bookpack; // This file is part of the bookpack package.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Book {  // Thus, Book is part of bookpack.
\end_layout

\begin_layout Plain Layout

	private String title;
\end_layout

\begin_layout Plain Layout

	private String author;
\end_layout

\begin_layout Plain Layout

	private int pubDate;
\end_layout

\begin_layout Plain Layout

	Book(String t, String a, int d) {
\end_layout

\begin_layout Plain Layout

	title = t;
\end_layout

\begin_layout Plain Layout

	author = a;
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class BookDemo { //BookDemo is also part of bookpack.
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Call this file BookDemo.java and put it in a directory called bookpack.
\end_layout

\begin_layout Itemize
Next, compile the file.
 You can do this by specifying from the directory directly above bookpack:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

javac bookpack/BookDemo.java
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Then try executing the class, using the following command line:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

java bookpack.BookDemo
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
As explained, BookDemo and Book are now part of the package bookpack.
 This means that BookDemo cannot be executed by itself.
 Instead, BookDemo must be qualified with its package name.
\end_layout

\end_deeper
\begin_layout Subsection
Importing Packages
\end_layout

\begin_layout Standard
The import statement.
 Using import you can bring one or more members of a package into view.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import pkg.classname; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, pkg is the name of the package, which can include its full path, and
 classname is the name of the class being imported.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import mypack.MyClass  // In the first case, the MyClass class is imported
 from mypack.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
If you want to import the entire contents of a package, use an asterisk
 (*) for the class name.
 Here are examples of both forms: 
\end_layout

\begin_deeper
\begin_layout Itemize
You can use import to bring the bookpack package into view so that the Book
 class can be used without qualification.
 To do so, simply add this import statement to the top of any file that
 uses Book.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import bookpack.*;
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
path
\end_layout

\begin_layout Itemize
First, by default, the Java run-time system uses the current working directory
 as its starting point.
 Thus, if your package is in a subdirectory of the current directory, it
 will be found.
\end_layout

\begin_layout Itemize
Second, you can specify a directory path or paths by setting the CLASSPATH
 environmental variable.
 Third, you can use the -classpath option with java and javac to specify
 the path to your classes.
\end_layout

\begin_layout Subsection
Protected Members
\end_layout

\begin_layout Standard
s explained, the protected modifier creates a member that is accessible
 within its package and to subclasses in other packages.
 Thus, a protected member is available for all subclasses to use but is
 still protected from arbitrary access by code outside its package.
 To better understand the effects of protected.
\end_layout

\begin_layout Section
Interfaces
\end_layout

\begin_layout Standard

\series bold
An interface is syntactically similar to an abstract class
\series default
, in that you can specify one or more methods that have no body.
 
\end_layout

\begin_layout Standard
Those methods must be implemented by a class in order for their actions
 to be defined.
 Thus, an interface specifies what must be done, but not how to do it.
 Once an interface is defined, any number of classes can implement it.
 Also, one class can implement any number of interfaces.
\end_layout

\begin_layout Itemize
Variables declared in an interface are not instance variables.
 Instead, they are implicitly 
\series bold
public, final, and static
\series default
 and must be 
\series bold
initialized
\series default
.
 --- Thus, they are essentially constants
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

access interface name {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	type var1 = value;
\end_layout

\begin_layout Plain Layout

	type var2 = value;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// ...
\end_layout

\begin_layout Plain Layout

	ret-type method-nameN(param-list);
\end_layout

\begin_layout Plain Layout

	type varN = value;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Once an interface has been defined, one or more classes can implement that
 interface.
\end_layout

\begin_deeper
\begin_layout Itemize
To implement more than one interface, the interfaces are separated with
 a comma.
 Of course, the extends clause is optional.
\end_layout

\begin_layout Itemize
The methods that implement an interface must be declared public.
 Also, the type signature of the implementing method must match exactly
 the type signature specified in the interface definition.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class classname extends superclass implements interface {
\end_layout

\begin_layout Plain Layout

// class-body
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Example: create an Interface and Implementing Method
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface Series {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Define the undefined methods
\end_layout

\begin_layout Plain Layout

	int getNext(); // return next number in series
\end_layout

\begin_layout Plain Layout

	void reset(); // restart
\end_layout

\begin_layout Plain Layout

	void setStart(int x); // set starting value
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Implement Series.
\end_layout

\begin_layout Plain Layout

class ByTwos implements Series {
\end_layout

\begin_layout Plain Layout

	int start;
\end_layout

\begin_layout Plain Layout

	int val;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	ByTwos() {
\end_layout

\begin_layout Plain Layout

		start = 0;
\end_layout

\begin_layout Plain Layout

		val = 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// IMPLEMENT THE METHODS
\end_layout

\begin_layout Plain Layout

	public int getNext() {
\end_layout

\begin_layout Plain Layout

		val += 2;
\end_layout

\begin_layout Plain Layout

		return val;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	public void reset() {
\end_layout

\begin_layout Plain Layout

		val = start;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public void setStart(int x) {
\end_layout

\begin_layout Plain Layout

		start = x;
\end_layout

\begin_layout Plain Layout

		val = x;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Interface References
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

public interface Series {}
\end_layout

\begin_layout Plain Layout

class ByTwos implements Series {}
\end_layout

\begin_layout Plain Layout

class ByThrees implements Series {}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ByTwos twoOb = new ByTwos();
\end_layout

\begin_layout Plain Layout

ByThrees threeOb = new ByThrees();
\end_layout

\begin_layout Plain Layout

Series ob;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//you can create an interface reference variable.
 Such a variable can refer to any object that implements its interface
\end_layout

\begin_layout Plain Layout

ob = twoOb;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// When you call a method on an object through an interface reference, it
 is the version of the method implemented by the object that is executed.
\end_layout

\begin_layout Plain Layout

ob.getNext()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ob = threeOb;
\end_layout

\begin_layout Plain Layout

ob.getNext()
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Interfaces Can Be Extended
\end_layout

\begin_layout Itemize
One interface can inherit another by use of the keyword extends.
\end_layout

\begin_layout Itemize
When a class implements an interface that inherits another interface, it
 must provide implementations for all methods required by the interface
 inheritance chain.
\end_layout

\begin_layout Subsection
Default Method Fundamentals
\end_layout

\begin_layout Standard
An interface default method is defined similar to the way a method is defined
 by a class.
 The primary difference is that the declaration is preceded by the keyword
 default.
 For example, consider this simple interface:
\end_layout

\begin_layout Itemize
Because getAdminID( ) includes a default implementation, it is not necessary
 for an implementing class to override it.
 In other words, if an implementing class does not provide its own implementatio
n, the default is used.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface MyIF {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// This is a "normal" interface method declaration.
\end_layout

\begin_layout Plain Layout

	// It does NOT define a default implementation.
\end_layout

\begin_layout Plain Layout

	int getUserID();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// This is a default method.
 Notice that it provides
\end_layout

\begin_layout Plain Layout

	// a default implementation.
\end_layout

\begin_layout Plain Layout

	default int getAdminID() {
\end_layout

\begin_layout Plain Layout

	return 1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Use static Methods in an Interface 
\end_layout

\begin_layout Standard
JDK 8 added another new capability to interface: the ability to define one
 or more static methods.
 
\end_layout

\begin_layout Standard
Like static methods in a class, a static method defined by an interface
 can be called independently of any object.
 Thus, no implementation of the interface is necessary, and no instance
 of the interface is required in order to call a static method.
 
\end_layout

\begin_layout Standard
Instead, a static method is called by specifying the interface name, followed
 by a period, followed by the method name.
 Here is the general form: 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

InterfaceName.staticMethodName
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public interface MyIF {
\end_layout

\begin_layout Plain Layout

	// This is a "normal" interface method declaration.
\end_layout

\begin_layout Plain Layout

	// It does NOT define a default implementation.
\end_layout

\begin_layout Plain Layout

	int getUserID();
\end_layout

\begin_layout Plain Layout

	// This is a default method.
 Notice that it provides
\end_layout

\begin_layout Plain Layout

	// a default implementation.
\end_layout

\begin_layout Plain Layout

	default int getAdminID() {
\end_layout

\begin_layout Plain Layout

	return 1;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// This is a static interface method.
\end_layout

\begin_layout Plain Layout

	static int getUniversalID() {
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// The getUniversalID( ) method can be called, as shown here:
\end_layout

\begin_layout Plain Layout

int uID = MyIF.getUniversalID();
\end_layout

\end_inset


\end_layout

\begin_layout Part
Exception Handling
\end_layout

\begin_layout Subsection

\series bold
Throwable: error vs exception
\end_layout

\begin_layout Standard
In Java, all exceptions are represented by classes.
 All exception classes are derived from a class called 
\series bold
Throwable
\series default
.
 Thus, when an exception occurs in a program, an object of some type of
 exception class is generated.
 
\end_layout

\begin_layout Standard
There are two direct subclasses of 
\series bold
Throwable
\series default
: Exception and Error.
\end_layout

\begin_layout Enumerate
Exceptions of type Error are related to errors that occur in the Java virtual
 machine itself, and not in your program.
 These types of exceptions are beyond your control, and your program will
 not usually deal with them.
 Thus, these types of exceptions are not described here.
\end_layout

\begin_layout Enumerate
Second, standard exceptions, such as those corresponding to divide-by-zero
 or array index out-of-bounds, are generated by errors in program code.
 You need to handle these exceptions.
 
\end_layout

\begin_layout Enumerate
Third,
\series bold
 you can manually generate an exception
\series default
 by using the throw statement.
 No matter how an exception is generated, it is handled in the same way.
\end_layout

\begin_layout Subsection
try, catch, throw, throws, and finally
\end_layout

\begin_layout Enumerate
Program statements that you want to monitor for exceptions are contained
 within a try block.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
If an exception occurs within the try block, it is 
\series bold
thrown
\series default
.
 Your code can catch this exception using catch and handle it in some rational
 manner.
 
\end_layout

\begin_deeper
\begin_layout Enumerate
System-generated exceptions are automatically thrown by the Java run-time
 system.
 
\end_layout

\begin_layout Enumerate
To manually 
\series bold
throw
\series default
 an exception, use the keyword 
\series bold
throw
\series default
.
 In some cases, an exception that is thrown out of a method must be specified
 as such by a 
\series bold
throws
\series default
 
\series bold
clause
\series default
.
 
\end_layout

\end_deeper
\end_deeper
\begin_layout Enumerate
Any code that absolutely must be executed upon exiting from a try block
 is put in a finally block.
\end_layout

\begin_layout Subsection
finally
\end_layout

\begin_layout Standard
Sometimes you will want to define a block of code that will execute when
 a try/catch block is left.
 For example, an exception might cause an error that terminates the current
 method, causing its premature return.
 However, that method may have opened a file or a network connection that
 needs to be closed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

// block of code to monitor for errors
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (ExcepType1 exOb) {
\end_layout

\begin_layout Plain Layout

// handler for ExcepType1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (ExcepType2 exOb) {
\end_layout

\begin_layout Plain Layout

// handler for ExcepType2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//...
\end_layout

\begin_layout Plain Layout

finally {
\end_layout

\begin_layout Plain Layout

// finally code
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Try and Catch
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

// block of code to monitor for errors
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (ExcepType1 exOb) {
\end_layout

\begin_layout Plain Layout

// handler for ExcepType1
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

catch (ExcepType2 exOb) {
\end_layout

\begin_layout Plain Layout

// handler for ExcepType2
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The 
\series bold
type of the exception 
\series default
determines which 
\series bold
catch statement
\series default
 is executed.
 
\end_layout

\begin_deeper
\begin_layout Itemize
That is, if the 
\series bold
exception type
\series default
 specified by a catch statement matches that of the 
\series bold
exception
\series default
, then that 
\series bold
catch
\series default
 statement is executed (and all others are bypassed).
 
\end_layout

\begin_layout Itemize
When an exception is caught, 
\series bold
exOb
\series default
 will receive its value.
 
\end_layout

\end_deeper
\begin_layout Itemize
If no exception is thrown, then a try block ends normally, and all of its
 catch statements are bypassed.
\end_layout

\begin_layout Itemize
Code in try block after the exception will not be executed.
\end_layout

\begin_deeper
\begin_layout Itemize
when an exception occurs (in this case, because of the attempt to index
 nums beyond its bounds), the exception is thrown out of the try block and
 caught by the catch statement.
 At this point, control passes to the catch, and the try block is terminated.
 That is, catch is not called.
 Rather, program execution is transferred to it.
 
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

	System.out.println("Before exception is generated.");
\end_layout

\begin_layout Plain Layout

	// Generate an index out-of-bounds exception.
\end_layout

\begin_layout Plain Layout

	nums[7] = 10;
\end_layout

\begin_layout Plain Layout

	System.out.println("this won't be displayed"); // Code in try block after
 the exception will not be executed.
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	catch (ArrayIndexOutOfBoundsException exc) {
\end_layout

\begin_layout Plain Layout

	// catch the exception
\end_layout

\begin_layout Plain Layout

	System.out.println("Index out-of-bounds!");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

System.out.println("After catch statement.");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// This program displays the following output:
\end_layout

\begin_layout Plain Layout

Before exception is generated.
\end_layout

\begin_layout Plain Layout

Index out-of-bounds!
\end_layout

\begin_layout Plain Layout

After catch statement.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Uncaught Exception
\end_layout

\begin_layout Standard
When an exception is thrown, it must be caught by some piece of code, somewhere.
 In general, if your program does not catch an exception, then it will be
 caught by the JVM.
\end_layout

\begin_layout Standard
The trouble is that the JVM’s default exception handler terminates execution
 and displays a stack trace and error message.
 
\end_layout

\begin_layout Standard
While such a message is useful for you while debugging, it would not be
 something that you would want others to see, to say the least! This is
 why it is important for your program to handle exceptions itself, rather
 than rely upon the JVM.
\end_layout

\begin_layout Subsection
Multiple catch Statements
\end_layout

\begin_layout Enumerate
For example, since the superclass of all exceptions is Throwable, to catch
 all possible exceptions, catch Throwable.
 If you want to catch exceptions of both a superclass type and a subclass
 type, put the subclass first in the catch sequence.
\end_layout

\begin_layout Subsection
Try Blocks Can Be Nested
\end_layout

\begin_layout Standard
One try block can be nested within another.
 An exception generated within the inner try block that is not caught by
 a catch associated with that try is propagated to the outer try block.
\end_layout

\begin_layout Section
Throwable's sub-classes
\end_layout

\begin_layout Subsection
Built-in Exceptions
\end_layout

\begin_layout Description
ArithmeticException: Arithmetic error, such as integer divide-by-zero.
\end_layout

\begin_layout Description
ArrayIndexOutOfBoundsException: Array index is out-of-bounds.
\end_layout

\begin_layout Description
ArrayStoreException: Assignment to an array element of an incompatible type.
\end_layout

\begin_layout Description
ClassCastException: Invalid cast.
\end_layout

\begin_layout Description
EnumConstantNotPresentException: An attempt is made to use an undefined
 enumeration value.
\end_layout

\begin_layout Description
IllegalArgumentException: Illegal argument used to invoke a method.
\end_layout

\begin_layout Description
IllegalMonitorStateException: Illegal monitor operation, such as waiting
 on an unlocked thread.
\end_layout

\begin_layout Description
IllegalStateException: Environment or application is in incorrect state.
\end_layout

\begin_layout Description
IllegalThreadStateException: Requested operation not compatible with current
 thread state.
\end_layout

\begin_layout Description
IndexOutOfBoundsException: Some type of index is out-of-bounds.
\end_layout

\begin_layout Description
NegativeArraySizeException: Array created with a negative size.
\end_layout

\begin_layout Description
NullPointerException: Invalid use of a null reference.
\end_layout

\begin_layout Description
NumberFormatException: Invalid conversion of a string to a numeric format.
\end_layout

\begin_layout Description
SecurityException: Attempt to violate security.
\end_layout

\begin_layout Description
StringIndexOutOfBoundsException: Attempt to index outside the bounds of
 a string.
\end_layout

\begin_layout Description
TypeNotPresentException: Type not found.
\end_layout

\begin_layout Description
UnsupportedOperationException: An unsupported operation was encountered.
\end_layout

\begin_layout Itemize
IOException,
\end_layout

\begin_deeper
\begin_layout Itemize
FileNotFoundException is a subclass of IOException
\end_layout

\end_deeper
\begin_layout Subsection
Creating Exception Subclasses
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Use a custom exception.
\end_layout

\begin_layout Plain Layout

// Create an exception.
\end_layout

\begin_layout Plain Layout

class NonIntResultException extends Exception {
\end_layout

\begin_layout Plain Layout

	int n;
\end_layout

\begin_layout Plain Layout

	int d;
\end_layout

\begin_layout Plain Layout

	NonIntResultException(int i, int j) {
\end_layout

\begin_layout Plain Layout

		n = i;
\end_layout

\begin_layout Plain Layout

		d = j;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public String toString() {
\end_layout

\begin_layout Plain Layout

		return "Result of " + n + " / " + d +
\end_layout

\begin_layout Plain Layout

		" is non-integer.";
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// when use it
\end_layout

\begin_layout Plain Layout

throw new NonIntResultException(numer[i], denom[i]);
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Throw
\end_layout

\begin_layout Subsection
Throwing an Exception
\end_layout

\begin_layout Itemize
The preceding examples have been catching exceptions generated automatically
 by the JVM.
 However, it is possible to manually throw an exception by using the throw
 statement.
 Its general form is shown here
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

throw exceptOb;
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Notice how the ArithmeticException was created using 
\series bold
new
\series default
 in the throw statement
\series bold
.
 Remember, throw throws an object.
 Thus, you must create an object for it to throw.
 That is, you can’t just throw a type.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

	System.out.println("Before throw.");
\end_layout

\begin_layout Plain Layout

	throw new ArithmeticException(); //Throw an exception.
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

catch (ArithmeticException exc) {
\end_layout

\begin_layout Plain Layout

	// catch the exception
\end_layout

\begin_layout Plain Layout

	System.out.println("Exception caught.");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Rethrowing an Exception (normally happens at then end of catch block): An
 exception caught by one catch statement can be rethrown so that it can
 be caught by an outer catch.
 The most likely reason for rethrowing this way is to allow multiple handlers
 access to the exception.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

catch (ArrayIndexOutOfBoundsException exc) {
\end_layout

\begin_layout Plain Layout

	// catch the exception
\end_layout

\begin_layout Plain Layout

	System.out.println("No matching element found.");
\end_layout

\begin_layout Plain Layout

	throw exc; // rethrow the exception
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
method throws
\end_layout

\begin_layout Standard
In some cases, if a method generates an exception that it does not handle,
 it must declare that exception in a throws clause.
 Here is the general form of a method that includes a throws clause: 
\end_layout

\begin_layout Standard
Exceptions that are subclasses of Error or RuntimeException don’t need to
 be specified in a throws list.
 Java simply assumes that a method may throw one.
 All other types of exceptions do need to be declared.
 Failure to do so causes a compile-time error.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

ret-type methName(param-list) throws except-list {
\end_layout

\begin_layout Plain Layout

// body
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ThrowsDemo {
\end_layout

\begin_layout Plain Layout

	public static char prompt(String str)
\end_layout

\begin_layout Plain Layout

		throws java.io.IOException {
\end_layout

\begin_layout Plain Layout

		System.out.print(str + ": ");
\end_layout

\begin_layout Plain Layout

		return (char) System.in.read();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

		char ch;
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			ch = prompt("Enter a letter");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// Since prompt( ) might throw an exception, a call to it must be enclosed
 within a try block.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		catch(java.io.IOException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("I/O exception occurred.");
\end_layout

\begin_layout Plain Layout

			ch = 'X';
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		System.out.println("You pressed " + ch);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Part
I/O
\end_layout

\begin_layout Section
Byte Stream Classes
\end_layout

\begin_layout Standard
Byte streams are defined by using two class hierarchies.
 At the top of these are two abstract classes: 
\end_layout

\begin_layout Itemize
InputStream
\end_layout

\begin_layout Itemize
OutputStream
\end_layout

\begin_layout Section
Character Stream Classes
\end_layout

\begin_layout Standard
Character streams are defined by using two class hierarchies topped by these
 two abstract classes:
\end_layout

\begin_layout Standard
Reader and Writer.
 Reader is used for input, and Writer is used for output.
\end_layout

\begin_layout Subsection
Read from keyboard: subclass - BufferedReader 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
System.in
\series default
 is for bite: you must first convert it into a character stream.
 To do this, you will use 
\series bold
InputStreamReader
\series default
, which converts bytes to characters
\end_layout

\begin_layout Standard

\series bold
Read method of BufferedReader
\end_layout

\begin_layout Itemize
int read( ) throws IOException
\end_layout

\begin_deeper
\begin_layout Itemize
reads a single Unicode character.
 It returns –1 when the end of the stream is reached.
 
\end_layout

\end_deeper
\begin_layout Itemize
int read(char data[ ]) throws IOException
\end_layout

\begin_deeper
\begin_layout Itemize
The second version reads characters from the input stream and puts them
 into data until either the array is full, the end of stream is reached,
 or an error occurs.
 It returns the number of characters read or –1 at the end of the stream.
\end_layout

\end_deeper
\begin_layout Itemize
int read(char data[ ], int start, int max) throws IOException
\end_layout

\begin_deeper
\begin_layout Itemize
The third version reads input into data beginning at the location specified
 by start.
 Up to max characters are stored.
 It returns the number of characters read or –1 when the end of the stream
 is encountered
\end_layout

\end_deeper
\begin_layout Section
InputStream Method
\end_layout

\begin_layout Itemize
int available( ) 
\end_layout

\begin_deeper
\begin_layout Itemize
Returns the number of bytes of input currently available for reading.
\end_layout

\end_deeper
\begin_layout Itemize
void close( ) 
\end_layout

\begin_deeper
\begin_layout Itemize
Closes the input source.
 Further read attempts will generate an IOException.
\end_layout

\end_deeper
\begin_layout Itemize
void mark(int numBytes) 
\end_layout

\begin_deeper
\begin_layout Itemize
Places a mark at the current point in the input stream that will remain
 valid until numBytes bytes are read.
\end_layout

\end_deeper
\begin_layout Itemize
boolean markSupported( ) 
\end_layout

\begin_deeper
\begin_layout Itemize
Returns true if mark( )/reset( ) are supported by the invoking stream.
\end_layout

\end_deeper
\begin_layout Itemize
void reset( ) 
\end_layout

\begin_deeper
\begin_layout Itemize
Resets the input pointer to the previously set mark.
\end_layout

\end_deeper
\begin_layout Itemize
long skip(long numBytes) 
\end_layout

\begin_deeper
\begin_layout Itemize
Ignores (that is, skips) numBytes bytes of input, returning the number of
 bytes actually ignored
\end_layout

\end_deeper
\begin_layout Subsection
System.in.
\end_layout

\begin_layout Itemize

\series bold
System.in is an instance of InputStream
\series default
, you automatically have access to the methods defined by InputStream
\end_layout

\begin_layout Subsection
read method
\end_layout

\begin_layout Standard
InputStream defines only one input method, read( ), which reads bytes.
 There are three versions of read( ), which are shown here:
\end_layout

\begin_layout Itemize
int read( ) 
\end_layout

\begin_deeper
\begin_layout Itemize
Returns an integer representation of the next available byte of input.
 –1 is returned when the end of the stream is encountered.
\end_layout

\end_deeper
\begin_layout Itemize
int read(byte buffer[ ]) 
\end_layout

\begin_deeper
\begin_layout Itemize
Attempts to read up to buffer.length bytes into buffer and 
\series bold
returns the actual number of bytes 
\series default
that were successfully read.
 –1 is returned when the end of the stream is encountered.
\end_layout

\end_deeper
\begin_layout Itemize
int read(byte buffer[ ], int offset, int numBytes)
\end_layout

\begin_deeper
\begin_layout Itemize
Attempts to read up to numBytes bytes into buffer starting at buffer[offset],
 returning the number of bytes successfully read.
 –1 is returned when the end of the stream is encountered.
\end_layout

\begin_layout Itemize
The third version reads input into data beginning at the location specified
 by start.
 Up to max bytes are stored.
 It returns the number of bytes read, or –1 when the end of the stream is
 reached.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Read an array of bytes from the keyboard.
\end_layout

\begin_layout Plain Layout

import java.io.*;
\end_layout

\begin_layout Plain Layout

class ReadBytes {
\end_layout

\begin_layout Plain Layout

	public static void main(String args[])
\end_layout

\begin_layout Plain Layout

		throws IOException {
\end_layout

\begin_layout Plain Layout

			byte data[] = new byte[10];
\end_layout

\begin_layout Plain Layout

			System.out.println("Enter some characters.");
\end_layout

\begin_layout Plain Layout

			System.in.read(data); // Read an array of bytes from the keyboard.
\end_layout

\begin_layout Plain Layout

			System.out.print("You entered: ");
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

			for(int i=0; i < data.length; i++)
\end_layout

\begin_layout Plain Layout

				System.out.print((char) data[i]);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
OutputStream
\end_layout

\begin_layout Itemize
void close( )
\end_layout

\begin_deeper
\begin_layout Itemize
Closes the output stream.
 Further write attempts will generate an IOException.
\end_layout

\end_deeper
\begin_layout Itemize
void flush( )
\end_layout

\begin_deeper
\begin_layout Itemize
Causes any output that has been buffered to be sent to its destination.
 That is, it flushes the output buffer.
\end_layout

\end_deeper
\begin_layout Itemize
void write(int b)
\end_layout

\begin_deeper
\begin_layout Itemize
Writes a single byte to an output stream.
 Note that the parameter is an int, which allows you to call write( ) with
 expressions without having to cast them back to byte.
\end_layout

\end_deeper
\begin_layout Itemize
void write(byte buffer[ ])
\end_layout

\begin_deeper
\begin_layout Itemize
Writes a complete array of bytes to an output stream.
\end_layout

\end_deeper
\begin_layout Itemize
void write(byte buffer[ ], int offset, int numBytes)
\end_layout

\begin_deeper
\begin_layout Itemize
Writes a subrange of numBytes bytes from the array buffer, beginning at
 buffer[offset].
\end_layout

\end_deeper
\begin_layout Subsection
Writing Console Output
\end_layout

\begin_layout Itemize
System.out is an instance of OutputStream
\end_layout

\begin_layout Itemize
write is a method of OutputStream
\end_layout

\begin_layout Itemize
You will not often use write( ) to perform console output (although it might
 be useful in some situations), since print( ) and println( ) are substantially
 easier to use.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

b = 'X';
\end_layout

\begin_layout Plain Layout

System.out.write(b);
\end_layout

\begin_layout Plain Layout

System.out.write('
\backslash
n');
\end_layout

\end_inset


\end_layout

\begin_layout Section
Reading and Writing Files Using Byte Streams
\end_layout

\begin_layout Subsection
reading a file
\end_layout

\begin_layout Standard
steps:
\end_layout

\begin_layout Itemize

\series bold
initialize
\series default
 a file-read object to be read using FileInputStream class
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FileInputStream fin;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
open the interested file: 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fin = new FileInputStream(args[0]); // Open the file
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
read the file into the file-read object.
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

		// read bytes until EOF is encountered
\end_layout

\begin_layout Plain Layout

		do {
\end_layout

\begin_layout Plain Layout

			i = fin.read();  // Read from the file.
\end_layout

\begin_layout Plain Layout

			if(i != -1) System.out.print((char) i);
\end_layout

\begin_layout Plain Layout

		} while(i != -1); // When i equals –1, the end of the file has been reached.
\end_layout

\begin_layout Plain Layout

	} catch(IOException exc) {
\end_layout

\begin_layout Plain Layout

		System.out.println("Error reading file.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
CLOSE
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// CLOSE
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			fin.close();   // Close the file.
\end_layout

\begin_layout Plain Layout

		} catch(IOException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Error closing file.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Full example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ShowFile {
\end_layout

\begin_layout Plain Layout

public static void main(String args[]){
\end_layout

\begin_layout Plain Layout

		int i;
\end_layout

\begin_layout Plain Layout

		FileInputStream fin;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		// First make sure that a file has been specified.
\end_layout

\begin_layout Plain Layout

		if(args.length != 1) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Usage: ShowFile File");
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			fin = new FileInputStream(args[0]); // Open the file
\end_layout

\begin_layout Plain Layout

		} catch(FileNotFoundException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("File Not Found");
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// READING	
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			// read bytes until EOF is encountered
\end_layout

\begin_layout Plain Layout

			do {
\end_layout

\begin_layout Plain Layout

				i = fin.read();  // Read from the file.
\end_layout

\begin_layout Plain Layout

				if(i != -1) System.out.print((char) i);
\end_layout

\begin_layout Plain Layout

			} while(i != -1); // When i equals –1, the end of the file has been reached.
\end_layout

\begin_layout Plain Layout

		} catch(IOException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Error reading file.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// CLOSE
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			fin.close();   // Close the file.
\end_layout

\begin_layout Plain Layout

		} catch(IOException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Error closing file.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
close and automatically close
\end_layout

\begin_layout Standard
You have to close a file when you finish reading/writing, otherwise there
 will be a memory leak.
\end_layout

\begin_layout Standard
usually close is hiding in the finally block:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

finally {
\end_layout

\begin_layout Plain Layout

// Close file on the way out of the try block.
\end_layout

\begin_layout Plain Layout

try {
\end_layout

\begin_layout Plain Layout

	fin.close();
\end_layout

\begin_layout Plain Layout

	} catch(IOException exc) {
\end_layout

\begin_layout Plain Layout

	System.out.println("Error Closing File");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To enable automatic closing a file
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// template
\end_layout

\begin_layout Plain Layout

try (resource-specification) {
\end_layout

\begin_layout Plain Layout

// use the resource
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Example
\end_layout

\begin_layout Plain Layout

try (FileInputStream fin = new FileInputStream(args[0]);
\end_layout

\begin_layout Plain Layout

	FileOutputStream fout = new FileOutputStream(args[1]))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

		do {
\end_layout

\begin_layout Plain Layout

			i = fin.read();
\end_layout

\begin_layout Plain Layout

			if(i != -1) fout.write(i);
\end_layout

\begin_layout Plain Layout

			} while(i != -1);
\end_layout

\begin_layout Plain Layout

			} catch(IOException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("I/O Error: " + exc);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Writing to a File
\end_layout

\begin_layout Itemize
In the second form, if append is true, then output is appended to the end
 of the file.
 Otherwise, the file is overwritten.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FileOutputStream(String fileName) throws FileNotFoundException
\end_layout

\begin_layout Plain Layout

FileOutputStream(String fileName, boolean append) throws FileNotFoundException
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Steps:
\end_layout

\begin_layout Enumerate
initialize and object under FileOutputStream
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

FileOutputStream fout = null;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
open the file 
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

fout = new FileOutputStream(args[1]);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Write
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

//Read bytes from one file and write them to another
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

do {
\end_layout

\begin_layout Plain Layout

	i = fin.read();
\end_layout

\begin_layout Plain Layout

	if(i != -1) fout.write(i);
\end_layout

\begin_layout Plain Layout

} while(i != -1);
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Reading & writing Binary Data
\end_layout

\begin_layout Standard
To read and write binary values of the Java primitive types, you will use
 DataInputStream and DataOutputStream.
\end_layout

\begin_layout Standard
DataOutputStream implements the DataOutput interface.
 This interface defines methods that write all of Java’s primitive types
 to a file.
 It is important to understand that this data is written using its internal,
 binary format, not its human-readable text form.
\end_layout

\begin_layout Enumerate

\series bold
DataInputStream
\series default
 implements the 
\series bold
DataInput
\series default
 interface.
 
\series bold
DataInputStream
\series default
 uses an 
\series bold
InputStream
\series default
 instance as its foundation, overlaying it with methods that read the various
 Java data types
\end_layout

\begin_layout Enumerate

\series bold
DataOutputStream
\series default
 is for writing
\end_layout

\begin_layout Itemize
boolean readBoolean( )
\end_layout

\begin_deeper
\begin_layout Itemize
Reads a boolean.
\end_layout

\end_deeper
\begin_layout Itemize
byte readByte( )
\end_layout

\begin_deeper
\begin_layout Itemize
Reads a byte.
\end_layout

\end_deeper
\begin_layout Itemize
char readChar( )
\end_layout

\begin_deeper
\begin_layout Itemize
Reads a char.
\end_layout

\end_deeper
\begin_layout Itemize
double readDouble( )
\end_layout

\begin_deeper
\begin_layout Itemize
Reads a double.
\end_layout

\end_deeper
\begin_layout Itemize
float readFloat( )
\end_layout

\begin_deeper
\begin_layout Itemize
Reads a float.
\end_layout

\end_deeper
\begin_layout Itemize
int readInt( )
\end_layout

\begin_deeper
\begin_layout Itemize
Reads an int.
\end_layout

\end_deeper
\begin_layout Itemize
long readLong( )
\end_layout

\begin_deeper
\begin_layout Itemize
Reads a long.
\end_layout

\end_deeper
\begin_layout Itemize
short readShort( )
\end_layout

\begin_deeper
\begin_layout Itemize
Reads a short.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

try (DataOutputStream dataOut = // initialize the to-be-written ob ject
\end_layout

\begin_layout Plain Layout

		new DataOutputStream(new FileOutputStream("testdata")))
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	dataOut.writeInt(i);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

try (DataInputStream dataIn = // initialize the read ob ject
\end_layout

\begin_layout Plain Layout

	new DataInputStream(new FileInputStream("testdata")))
\end_layout

\begin_layout Plain Layout

		{
\end_layout

\begin_layout Plain Layout

		i = dataIn.readInt();
\end_layout

\begin_layout Plain Layout

		System.out.println("Reading " + i);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Part
Multithreaded Programming
\end_layout

\begin_layout Standard
A multithreaded program contains two or more parts that can run concurrently.
 Each part of such a program is called a thread, and each thread defines
 a separate path of execution.
\end_layout

\begin_layout Itemize
In process based multitasking, a program is the smallest unit of code that
 can be dispatched by the scheduler.
 
\end_layout

\begin_deeper
\begin_layout Itemize
Although Java programs make use of process-based multitasking environments,
 process-based multitasking is not under the control of Java.
 Multithreaded multitasking is.
 
\end_layout

\end_deeper
\begin_layout Itemize
In a thread-based multitasking environment, the thread is the smallest unit
 of dispatchable code.
 This means that a single program can perform two or more tasks at once.
\end_layout

\begin_deeper
\begin_layout Itemize
For instance, a text editor can be formatting text at the same time that
 it is printing, as long as these two actions are being performed by two
 separate threads.
 
\end_layout

\end_deeper
\begin_layout Subsection
Thread
\end_layout

\begin_layout Standard
Each part of such a program is called a thread, and each thread defines
 a separate path of execution.
\end_layout

\begin_layout Itemize
in a single-core system, two or more threads do not actually run at the
 same time, but idle CPU time is utilized.
\end_layout

\begin_layout Standard
A thread can be in one of several states.
 It can be 
\series bold
running
\series default
.
 It can be 
\series bold
ready to run
\series default
 as soon as it gets CPU time.
 A running thread can be 
\series bold
suspended
\series default
, which is a temporary halt to its execution.
 It can later be 
\series bold
resumed
\series default
.
 A thread can be 
\series bold
blocked
\series default
 when waiting for a resource.
 A thread can be 
\series bold
terminated
\series default
, in which case its execution ends and cannot be resumed.
\end_layout

\begin_layout Standard
Along with thread-based multitasking comes the need for a special type of
 feature called 
\series bold
synchronization
\series default
, which allows the execution of threads to be coordinated in certain well-define
d ways.
 Java has a complete subsystem devoted to synchronization, and its key features
 are also described here.
\end_layout

\begin_layout Subsection
Creating a Thread: Method 1
\end_layout

\begin_layout Standard
Java defines two ways in which you can create a runnable object:
\end_layout

\begin_layout Standard
Methods
\end_layout

\begin_layout Itemize
You can implement the Runnable interface.
 -- major method
\end_layout

\begin_deeper
\begin_layout Itemize
The Thread class defines several methods that can be overridden by a derived
 class.
 Of these methods, the only one that must be overridden is run( ).
 This is, of course, the same method required when you implement Runnable.
 Some Java programmers feel that classes should be extended only when they
 are being enhanced or modified in some way.
 So, if you will not be overriding any of Thread’s other methods, it is
 probably best to simply implement Runnable.
 Also, by implementing Runnable, you enable your thread to inherit a class
 other than Thread.
\end_layout

\end_deeper
\begin_layout Itemize
You can extend the Thread class.
\end_layout

\begin_layout Standard
Steps
\end_layout

\begin_layout Itemize
Step 1: 
\series bold
define a class to implement the Runnable interface 
\series default
-- within which you need to define the method run
\end_layout

\begin_deeper
\begin_layout Itemize
The Runnable interface abstracts a unit of executable code.
\end_layout

\begin_layout Itemize
Runnable defines only one method called run( ), which is declared like this:
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

public void run( )
\end_layout

\end_inset

 
\end_layout

\begin_layout Itemize
Inside run( ), you will define the code that constitutes the new thread.
\end_layout

\begin_layout Itemize
run( ) establishes the entry point for another, concurrent thread of execution
 within your program.
\end_layout

\end_deeper
\begin_layout Itemize
Step 2: create a runnable object (MyThread) using the class you defined
 above.
\end_layout

\begin_layout Itemize
Step 3: create a thread object: You can 
\series bold
construct
\series default
 a 
\series bold
thread
\series default
 on any object that implements the 
\series bold
Runnable
\series default
 interface
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Thread(Runnable threadOb, String name)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
there is no need for MyThread to store the name of the thread since it is
 possible to give a name to a thread when it is created.
 To do so, use this version of Thread’s constructor:
\end_layout

\end_deeper
\begin_layout Itemize
Step 4: schedule to start to run
\end_layout

\begin_deeper
\begin_layout Itemize
Once created, the new thread will not start running until you call its start(
 ) method, which is declared within Thread.
 In essence, start( ) executes a call to run( ).
 The start( ) method is shown here: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

void start( )
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Create a thread by implementing Runnable.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class MyThread implements Runnable { 
\end_layout

\begin_layout Plain Layout

	// Objects of MyThread can be run in their own threads because MyThread
 implements Runnable.
\end_layout

\begin_layout Plain Layout

	String thrdName;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	MyThread(String name) {
\end_layout

\begin_layout Plain Layout

		thrdName = name;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Entry point of thread.
\end_layout

\begin_layout Plain Layout

	public void run() {
\end_layout

\begin_layout Plain Layout

		System.out.println(thrdName + " starting.");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			for(int count=0; count < 10; count++) {
\end_layout

\begin_layout Plain Layout

				Thread.sleep(400);
\end_layout

\begin_layout Plain Layout

				System.out.println("In " + thrdName +
\end_layout

\begin_layout Plain Layout

					", count is " + count);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println(thrdName + " interrupted.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		System.out.println(thrdName + " terminating.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class UseThreads {
\end_layout

\begin_layout Plain Layout

	public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

		System.out.println("Main thread starting.");
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		// First, construct a MyThread object.
\end_layout

\begin_layout Plain Layout

		MyThread mt = new MyThread("Child #1"); // Create a runnable object.
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		// Next, construct a thread from that object.
\end_layout

\begin_layout Plain Layout

		Thread newThrd = new Thread(mt); // Construct a thread on that object.
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		// Finally, start execution of the thread.
\end_layout

\begin_layout Plain Layout

		newThrd.start(); 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		for(int i=0; i<50; i++) {
\end_layout

\begin_layout Plain Layout

			System.out.print(".");
\end_layout

\begin_layout Plain Layout

			try {
\end_layout

\begin_layout Plain Layout

				Thread.sleep(100);
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

				System.out.println("Main thread interrupted.");
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		System.out.println("Main thread ending.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// After calling start( ), execution returns to main( ), and it enters main(
 )’s for loop.
 Notice that this loop iterates 50 times, pausing 100 milliseconds each
 time through the loop.
 Both threads continue running, sharing the CPU in single-CPU systems, until
 their loops finish.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// result below
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Main thread starting.
\end_layout

\begin_layout Plain Layout

.Child #1 starting.
\end_layout

\begin_layout Plain Layout

...In Child #1, count is 0
\end_layout

\begin_layout Plain Layout

....In Child #1, count is 1
\end_layout

\begin_layout Plain Layout

....In Child #1, count is 2
\end_layout

\begin_layout Plain Layout

...In Child #1, count is 3
\end_layout

\begin_layout Plain Layout

....In Child #1, count is 4
\end_layout

\begin_layout Plain Layout

....In Child #1, count is 5
\end_layout

\begin_layout Plain Layout

....In Child #1, count is 6
\end_layout

\begin_layout Plain Layout

...In Child #1, count is 7
\end_layout

\begin_layout Plain Layout

....In Child #1, count is 8
\end_layout

\begin_layout Plain Layout

....In Child #1, count is 9
\end_layout

\begin_layout Plain Layout

Child #1 terminating.
\end_layout

\begin_layout Plain Layout

............Main thread ending.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Creating a Thread: Method 2
\end_layout

\begin_layout Itemize

\series bold
Create a runnable class: and at the same time 
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
initialize the thread within it usign a constructor.
\end_layout

\begin_layout Itemize
start the thread usign a constructor.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class MyThread implements Runnable {
\end_layout

\begin_layout Plain Layout

	Thread thrd;
\end_layout

\begin_layout Plain Layout

	TickTock ttOb;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Construct a new thread.
\end_layout

\begin_layout Plain Layout

	MyThread(String name, TickTock tt) {
\end_layout

\begin_layout Plain Layout

		thrd = new Thread(this, name);
\end_layout

\begin_layout Plain Layout

		ttOb = tt;
\end_layout

\begin_layout Plain Layout

		thrd.start(); // start the thread
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Begin execution of new thread.
\end_layout

\begin_layout Plain Layout

	public void run() {
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Finish the main thread first
\end_layout

\begin_layout Standard
having the main thread finish last is not a requirement.
 It is, however, often a good practice to follow—especially when you are
 first learning about threads.
 To illustrate the fact that the 
\series bold
main
\series default
 thread and 
\series bold
mt
\series default
 execute concurrently, it is necessary to keep main( ) from terminating
 until mt is finished.
 
\end_layout

\begin_layout Itemize
Here, this is done through the timing differences between the two threads.
 Because the calls to sleep( ) inside main( )’s for loop cause a total delay
 of 5 seconds (50 iterations times 100 milliseconds), but the total delay
 within run( )’s loop is only 4 seconds (10 iterations times 400 milliseconds),
 run( ) will finish approximately 1 second before main( ).
 
\end_layout

\begin_layout Itemize
As a result, both the main thread and mt will execute concurrently until
 
\series bold
mt
\series default
 ends.
 Then, about 1 second later main( ) ends.
\end_layout

\begin_layout Subsection
Static Methods
\end_layout

\begin_layout Standard
The sleep( ) method causes the thread from which it is called to suspend
 execution for the specified period of milliseconds.
 Its general form is shown here
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Thread.sleep(4000);
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Names
\end_layout

\begin_layout Itemize
final String 
\series bold
getName
\series default
( )
\end_layout

\begin_deeper
\begin_layout Itemize
Obtains a thread’s name.
\end_layout

\end_deeper
\begin_layout Itemize
final void 
\series bold
setName
\series default
(String threadName)
\end_layout

\begin_deeper
\begin_layout Itemize
which is shown here: 
\end_layout

\end_deeper
\begin_layout Subsection
Run Alive and ends
\end_layout

\begin_layout Itemize
void 
\series bold
run
\series default
( )
\end_layout

\begin_deeper
\begin_layout Itemize
Entry point for the thread.
 You need to overwrite it in your runnable class
\end_layout

\end_deeper
\begin_layout Itemize
void 
\series bold
start
\series default
( )
\end_layout

\begin_deeper
\begin_layout Itemize
Starts a thread by calling its run( ) method.
\end_layout

\end_deeper
\begin_layout Itemize
final boolean 
\series bold
isAlive
\series default
( )
\end_layout

\begin_deeper
\begin_layout Itemize
Determines whether a thread is still running.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mt1.thrd.isAlive()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
final void 
\series bold
join
\series default
( )
\end_layout

\begin_deeper
\begin_layout Itemize
Waits for a thread to terminate.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

mt1.thrd.join(); // Wait until the specified thread ends.
\end_layout

\begin_layout Plain Layout

System.out.println("Child #1 joined.");
\end_layout

\begin_layout Plain Layout

mt2.thrd.join();
\end_layout

\begin_layout Plain Layout

System.out.println("Child #2 joined.");
\end_layout

\begin_layout Plain Layout

mt3.thrd.join();
\end_layout

\begin_layout Plain Layout

System.out.println("Child #3 joined.");
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
static void 
\series bold
sleep
\series default
(long milliseconds)
\end_layout

\begin_deeper
\begin_layout Itemize
Suspends a thread for a specified period of milliseconds.
\end_layout

\end_deeper
\begin_layout Subsection
Priorities
\end_layout

\begin_layout Standard

\series bold
Definition
\series default
: thread’s priority determines, in part, how much CPU time a thread receives
 relative to the other active threads.
 In general, over a given period of time, low-priority threads receive little.
 High-priority threads receive a lot.
 As you might expect, how much CPU time a thread receives has profound impact
 on its execution characteristics and its interaction with other threads
 currently executing in the system.
\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final int getPriority( )
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Obtains a thread’s priority.
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

final void setPriority(int level)
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// set the priorities
\end_layout

\begin_layout Plain Layout

mt1.thrd.setPriority(Thread.NORM_PRIORITY+2);
\end_layout

\begin_layout Plain Layout

mt2.thrd.setPriority(Thread.NORM_PRIORITY-2);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// start the threads
\end_layout

\begin_layout Plain Layout

mt1.thrd.start();
\end_layout

\begin_layout Plain Layout

mt2.thrd.start();
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard

\series bold
Levels of Priorities:
\series default
 
\end_layout

\begin_layout Itemize
Here, level specifies the new priority setting for the calling thread.
 The value of level must be within the range MIN_PRIORITY and MAX_PRIORITY.
 
\end_layout

\begin_layout Itemize
Currently, these values are 1 and 10, respectively.
 To return a thread to default priority, specify NORM_PRIORITY, which is
 currently 5.
 These priorities are defined as static final variables within Thread.
\end_layout

\begin_layout Itemize
When a child thread is started, its priority setting is equal to that of
 its parent thread.
 
\end_layout

\begin_layout Subsection
Synchronization
\end_layout

\begin_layout Standard
The most common reason for synchronization is when two or more threads need
 access to a shared resource that can be used by only one thread at a time.
\end_layout

\begin_layout Standard
Another reason for synchronization is when one thread is waiting for an
 event that is caused by another thread.
 In this case, there must be some means by which the first thread is held
 in a suspended state until the event has occurred.
 Then, the waiting thread must resume execution.
\end_layout

\begin_layout Standard
Key to synchronization in Java is the concept of the 
\series bold
monitor
\series default
, which controls access to an object.
 A monitor works by implementing the concept of a lock.
 When an object is locked by one thread, no other thread can gain access
 to the object.
 When the thread exits, the object is unlocked and is available for use
 by another thread.
\end_layout

\begin_layout Subsection
Synchronization: define a Synchronized Method
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class SumArray {
\end_layout

\begin_layout Plain Layout

	private int sum;
\end_layout

\begin_layout Plain Layout

	synchronized int sumArray(int nums[]) {   //sumArray( ) is synchronized.
\end_layout

\begin_layout Plain Layout

		sum = 0; // reset sum
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		for(int i=0; i<nums.length; i++) {
\end_layout

\begin_layout Plain Layout

			sum += nums[i];
\end_layout

\begin_layout Plain Layout

			System.out.println("Running total for " +
\end_layout

\begin_layout Plain Layout

			Thread.currentThread().getName() +
\end_layout

\begin_layout Plain Layout

			" is " + sum);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			try {
\end_layout

\begin_layout Plain Layout

				Thread.sleep(10); // allow task-switch
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

			catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

				System.out.println("Thread interrupted.");
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	return sum;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class MyThread implements Runnable {
\end_layout

\begin_layout Plain Layout

	Thread thrd;
\end_layout

\begin_layout Plain Layout

	static SumArray sa = new SumArray(); // use SumArray class defined above
 to define a new static variable SumArray
\end_layout

\begin_layout Plain Layout

	int a[];
\end_layout

\begin_layout Plain Layout

	int answer;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Construct a new thread.
\end_layout

\begin_layout Plain Layout

	MyThread(String name, int nums[]) {
\end_layout

\begin_layout Plain Layout

		thrd = new Thread(this, name);
\end_layout

\begin_layout Plain Layout

		a = nums;
\end_layout

\begin_layout Plain Layout

		thrd.start(); // start the thread
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Begin execution of new thread.
\end_layout

\begin_layout Plain Layout

	public void run() {
\end_layout

\begin_layout Plain Layout

		int sum;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		System.out.println(thrd.getName() + " starting.");
\end_layout

\begin_layout Plain Layout

		answer = sa.sumArray(a);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		System.out.println("Sum for " + thrd.getName() +
\end_layout

\begin_layout Plain Layout

		" is " + answer);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		System.out.println(thrd.getName() + " terminating.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Sync {
\end_layout

\begin_layout Plain Layout

	public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

		int a[] = {1, 2, 3, 4, 5};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		MyThread mt1 = new MyThread("Child #1", a);
\end_layout

\begin_layout Plain Layout

		MyThread mt2 = new MyThread("Child #2", a);
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			mt1.thrd.join();
\end_layout

\begin_layout Plain Layout

			mt2.thrd.join();
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Main thread interrupted.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Child #1 starting.
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 1
\end_layout

\begin_layout Plain Layout

Child #2 starting.
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 3 
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 6
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 10
\end_layout

\begin_layout Plain Layout

Running total for Child #1 is 15  
\end_layout

\begin_layout Plain Layout

Sum for Child #1 is 15
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Child #1 terminating.
 // "synchronized" prevent other instance to access method sumArray until
 it is unlocked
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 1
\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 3
\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 6
\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 10
\end_layout

\begin_layout Plain Layout

Running total for Child #2 is 15
\end_layout

\begin_layout Plain Layout

Sum for Child #2 is 15
\end_layout

\begin_layout Plain Layout

Child #2 terminating.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Synchronization: create a Synchronized Block
\end_layout

\begin_layout Standard
you might want to synchronize access to some method that is not modified
 by synchronized.
 This can occur because you want to use a class that was not created by
 you but by a third party, and you do not have access to the source code.
 Thus, it is not possible for you to add synchronized to the appropriate
 methods within the class.
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

synchronized(objref) {
\end_layout

\begin_layout Plain Layout

	// statements to be synchronized
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class MyThread implements Runnable {
\end_layout

\begin_layout Plain Layout

	Thread thrd;
\end_layout

\begin_layout Plain Layout

	static SumArray sa = new SumArray();
\end_layout

\begin_layout Plain Layout

	int a[];
\end_layout

\begin_layout Plain Layout

	int answer;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	// Construct a new thread.
\end_layout

\begin_layout Plain Layout

	MyThread(String name, int nums[]) {
\end_layout

\begin_layout Plain Layout

		thrd = new Thread(this, name);
\end_layout

\begin_layout Plain Layout

		a = nums;
\end_layout

\begin_layout Plain Layout

		thrd.start(); // start the thread
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Begin execution of new thread.
\end_layout

\begin_layout Plain Layout

	public void run() {
\end_layout

\begin_layout Plain Layout

		int sum;
\end_layout

\begin_layout Plain Layout

		System.out.println(thrd.getName() + " starting.");
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		// synchronize calls to sumArray()
\end_layout

\begin_layout Plain Layout

		synchronized(sa) {
\end_layout

\begin_layout Plain Layout

			answer = sa.sumArray(a);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		System.out.println("Sum for " + thrd.getName() +
\end_layout

\begin_layout Plain Layout

		" is " + answer);
\end_layout

\begin_layout Plain Layout

		System.out.println(thrd.getName() + " terminating.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
wait()
\end_layout

\begin_layout Standard
When a thread is temporarily blocked from running, it calls wait( ).
 This causes the thread to go to sleep and the monitor for that object to
 be released, allowing another thread to use the object.
\end_layout

\begin_layout Itemize
final void wait( ) throws InterruptedException
\end_layout

\begin_layout Itemize
final void wait(long millis) throws InterruptedException
\end_layout

\begin_layout Itemize
final void wait(long millis, int nanos) throws InterruptedException
\end_layout

\begin_layout Standard
The first form waits until notified.
 The second form waits until notified or until the specified period of milliseco
nds has expired.
 The third form allows you to specify the wait period in terms of nanoseconds.
\end_layout

\begin_layout Subsection
notify
\end_layout

\begin_layout Standard
At a later point, the sleeping thread is awakened when some other thread
 enters the same monitor and calls notify( ), or notifyAll( ).
\end_layout

\begin_layout Standard
Here are the general forms for notify( ) and notifyAll( ):
\end_layout

\begin_layout Itemize
final void notify( )
\end_layout

\begin_layout Itemize
final void notifyAll( )
\end_layout

\begin_layout Subsection
Example: wait() and notify()
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class TickTock {
\end_layout

\begin_layout Plain Layout

	String state; // contains the state of the clock
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	synchronized void tick(boolean running) {
\end_layout

\begin_layout Plain Layout

		if(!running) { // stop the clock -- this is to define the closing state
\end_layout

\begin_layout Plain Layout

			state = "ticked"; // assign a state
\end_layout

\begin_layout Plain Layout

			notify(); // notify any waiting threads
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		System.out.print("Tick ");
\end_layout

\begin_layout Plain Layout

		// though "state" is not defined as a static variable, but as long as
 it is inside the the synchronized method, it is locked when the method
 tick() is running.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		state = "ticked"; // set the current state to ticked
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		//The reason for the call to notify( ) when the clock is stopped is to
 allow a final call to wait( )
\end_layout

\begin_layout Plain Layout

to succeed.
 Remember, both tick( ) and tock( ) execute a call to wait( ) after displaying
 their
\end_layout

\begin_layout Plain Layout

message.
 
\end_layout

\begin_layout Plain Layout

		//The problem is that when the clock is stopped, one of the methods will
 still be waiting.
\end_layout

\begin_layout Plain Layout

Thus, a final call to notify( ) is required in order for the waiting method
 to run
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		notify(); // let tock() run
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// The while loop that calls wait( ) checks the value of state, waiting
 for it to equal "tocked",
\end_layout

\begin_layout Plain Layout

which will be the case only after the tock( ) method executes.
 As explained, using a while loop
\end_layout

\begin_layout Plain Layout

to check this condition prevents a spurious wakeup from incorrectly restarting
 the thread.
 If
\end_layout

\begin_layout Plain Layout

state does not equal "tocked" when wait( ) returns, it means that a spurious
 wakeup occurred,
\end_layout

\begin_layout Plain Layout

and wait( ) is simply called again.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			while(!state.equals("tocked"))
\end_layout

\begin_layout Plain Layout

				wait(); // wait for tock() to complete.
 Tick will stop waiting when it is notified from toke.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Thread interrupted.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	synchronized void tock(boolean running) {
\end_layout

\begin_layout Plain Layout

		if(!running) { // stop the clock
\end_layout

\begin_layout Plain Layout

			state = "tocked";
\end_layout

\begin_layout Plain Layout

			notify(); // notify any waiting threads
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		System.out.println("Tock");
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		state = "tocked"; // set the current state to tocked
\end_layout

\begin_layout Plain Layout

		notify(); // let tick() run
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			while(!state.equals("ticked"))
\end_layout

\begin_layout Plain Layout

			wait(); // wait for tick to complete
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Thread interrupted.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class MyThread implements Runnable {
\end_layout

\begin_layout Plain Layout

	Thread thrd;
\end_layout

\begin_layout Plain Layout

	TickTock ttOb;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Construct a new thread.
\end_layout

\begin_layout Plain Layout

	MyThread(String name, TickTock tt) {
\end_layout

\begin_layout Plain Layout

		thrd = new Thread(this, name);
\end_layout

\begin_layout Plain Layout

		ttOb = tt;
\end_layout

\begin_layout Plain Layout

		thrd.start(); // start the thread
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Begin execution of new thread.
\end_layout

\begin_layout Plain Layout

	public void run() {
\end_layout

\begin_layout Plain Layout

		if(thrd.getName().compareTo("Tick") == 0) {
\end_layout

\begin_layout Plain Layout

			for(int i=0; i<5; i++) ttOb.tick(true);
\end_layout

\begin_layout Plain Layout

			ttOb.tick(false);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		else {
\end_layout

\begin_layout Plain Layout

			for(int i=0; i<5; i++) ttOb.tock(true);
\end_layout

\begin_layout Plain Layout

			ttOb.tock(false);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Run!
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

class ThreadCom {
\end_layout

\begin_layout Plain Layout

	public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		TickTock tt = new TickTock();
\end_layout

\begin_layout Plain Layout

		MyThread mt1 = new MyThread("Tick", tt);
\end_layout

\begin_layout Plain Layout

		MyThread mt2 = new MyThread("Tock", tt);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			mt1.thrd.join();
\end_layout

\begin_layout Plain Layout

			mt2.thrd.join();
\end_layout

\begin_layout Plain Layout

		} catch(InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println("Main thread interrupted.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Tick Tock
\end_layout

\begin_layout Plain Layout

Tick Tock
\end_layout

\begin_layout Plain Layout

Tick Tock
\end_layout

\begin_layout Plain Layout

Tick Tock
\end_layout

\begin_layout Plain Layout

Tick Tock
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
suspend and stop
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

// Suspending, resuming, and stopping a thread.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class MyThread implements Runnable {
\end_layout

\begin_layout Plain Layout

	Thread thrd;
\end_layout

\begin_layout Plain Layout

	boolean suspended;
\end_layout

\begin_layout Plain Layout

	boolean stopped;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	MyThread(String name) {
\end_layout

\begin_layout Plain Layout

		thrd = new Thread(this, name);
\end_layout

\begin_layout Plain Layout

		suspended = false;
\end_layout

\begin_layout Plain Layout

		stopped = false;
\end_layout

\begin_layout Plain Layout

		thrd.start();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// This is the entry point for thread.
\end_layout

\begin_layout Plain Layout

	public void run() {
\end_layout

\begin_layout Plain Layout

		System.out.println(thrd.getName() + " starting.");
\end_layout

\begin_layout Plain Layout

		try {
\end_layout

\begin_layout Plain Layout

			for(int i = 1; i < 1000; i++) {
\end_layout

\begin_layout Plain Layout

				System.out.print(i + " ");
\end_layout

\begin_layout Plain Layout

				if((i%10)==0) {
\end_layout

\begin_layout Plain Layout

					System.out.println();
\end_layout

\begin_layout Plain Layout

					Thread.sleep(250);
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

				// Use synchronized block to check suspended and stopped.
\end_layout

\begin_layout Plain Layout

				synchronized(this) {
\end_layout

\begin_layout Plain Layout

					while(suspended) { // keyword suspended control here
\end_layout

\begin_layout Plain Layout

						wait();
\end_layout

\begin_layout Plain Layout

					}
\end_layout

\begin_layout Plain Layout

					if(stopped) break; // keyword stop control here
\end_layout

\begin_layout Plain Layout

				}
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		} catch (InterruptedException exc) {
\end_layout

\begin_layout Plain Layout

			System.out.println(thrd.getName() + " interrupted.");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		System.out.println(thrd.getName() + " exiting.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Stop the thread.
\end_layout

\begin_layout Plain Layout

	synchronized void mystop() {
\end_layout

\begin_layout Plain Layout

		stopped = true;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		// The following ensures that a suspended thread can be stopped.
\end_layout

\begin_layout Plain Layout

		suspended = false;
\end_layout

\begin_layout Plain Layout

		notify();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Suspend the thread.
\end_layout

\begin_layout Plain Layout

	synchronized void mysuspend() {
\end_layout

\begin_layout Plain Layout

		suspended = true;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	// Resume the thread.
\end_layout

\begin_layout Plain Layout

	synchronized void myresume() {
\end_layout

\begin_layout Plain Layout

		suspended = false;
\end_layout

\begin_layout Plain Layout

		notify();
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class Suspend {
\end_layout

\begin_layout Plain Layout

public static void main(String args[]) {
\end_layout

\begin_layout Plain Layout

	MyThread ob1 = new MyThread("My Thread");
\end_layout

\begin_layout Plain Layout

	try {
\end_layout

\begin_layout Plain Layout

		Thread.sleep(1000); // let ob1 thread start executing
\end_layout

\begin_layout Plain Layout

		ob1.mysuspend();
\end_layout

\begin_layout Plain Layout

		System.out.println("Suspending thread.");
\end_layout

\begin_layout Plain Layout

		Thread.sleep(1000);
\end_layout

\begin_layout Plain Layout

		ob1.myresume();
\end_layout

\begin_layout Plain Layout

		System.out.println("Resuming thread.");
\end_layout

\begin_layout Plain Layout

		Thread.sleep(1000);
\end_layout

\begin_layout Plain Layout

		ob1.mysuspend();
\end_layout

\begin_layout Plain Layout

		System.out.println("Suspending thread.");
\end_layout

\begin_layout Plain Layout

		Thread.sleep(1000);
\end_layout

\begin_layout Plain Layout

		ob1.myresume();
\end_layout

\begin_layout Plain Layout

		System.out.println("Resuming thread.");
\end_layout

\begin_layout Plain Layout

		Thread.sleep(1000);
\end_layout

\begin_layout Plain Layout

		ob1.mysuspend();
\end_layout

\begin_layout Plain Layout

		System.out.println("Stopping thread.");
\end_layout

\begin_layout Plain Layout

		ob1.mystop();
\end_layout

\begin_layout Plain Layout

		} catch (InterruptedException e) {
\end_layout

\begin_layout Plain Layout

		System.out.println("Main thread Interrupted");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

// wait for thread to finish
\end_layout

\begin_layout Plain Layout

	try {
\end_layout

\begin_layout Plain Layout

		ob1.thrd.join();
\end_layout

\begin_layout Plain Layout

		} catch (InterruptedException e) {
\end_layout

\begin_layout Plain Layout

		System.out.println("Main thread Interrupted");
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

		System.out.println("Main thread exiting.");
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Section
concurrency utilities: Fork/Join Framework
\end_layout

\end_body
\end_document
