#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[BoldFont,SlantFont,CJKnumber,fallback]{xeCJK}%使用TexLive自带的xeCJK宏包，并启用加粗、斜体、CJK数字和备用字体选项
\setCJKmainfont{Songti SC}%设置中文衬线字体,若没有该字体,请替换该字符串为系统已有的中文字体,下同
\setCJKsansfont{STXihei}%中文无衬线字体
\setCJKmonofont{SimHei}%中文等宽字体
%中文断行和弹性间距在XeCJK中自动处理了
%\XeTeXlinebreaklocale “zh”%中文断行
%\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt%左右弹性间距
\usepackage{indentfirst}%段落首行缩进

\usepackage[multidot]{grffile}
\setlength{\parindent}{2em}%缩进两个字符
\end_preamble
\use_default_options true
\begin_modules
eqs-within-sections
figs-within-sections
tabs-within-sections
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package auto
\inputencoding utf8-plain
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 3
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "unicode=false"
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes true
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author 16419249 "v660271" 
\end_header

\begin_body

\begin_layout Title
R: Objectiive Programming
\end_layout

\begin_layout Author
Fan Yang
\end_layout

\begin_layout Date
\begin_inset Foot
status open

\begin_layout Plain Layout
First version: Nov 
\begin_inset Formula $11{}^{th}$
\end_inset

, 2013.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Part*
Book Reference
\end_layout

\begin_layout Itemize
R Language Definition: http://www.hep.by/gnu/r-patched/r-lang/R-lang.html#SEC_Top
\end_layout

\begin_deeper
\begin_layout Itemize
This is an introduction to the R language, explaining evaluation, parsing,
 object oriented programming, computing on the language, and so forth.
 
\end_layout

\end_deeper
\begin_layout Itemize
http://adv-r.had.co.nz/
\end_layout

\begin_layout Part
OO
\end_layout

\begin_layout Section
Class
\end_layout

\begin_layout Standard
A class defines the behaviour of objects by describing their attributes
 and their relationship to other classes.
 
\end_layout

\begin_layout Subsection
create a S3 new class 
\end_layout

\begin_layout Standard
with attributes: name and age
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

setClass(Class = "Person", 
\end_layout

\begin_layout Plain Layout

		representation(name = "character", age = "numeric")) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
create inheritance for S3
\end_layout

\begin_layout Standard
Use contains to show “Reporter” inherits from “Person”
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

setClass(Class = "Reporter", 
\end_layout

\begin_layout Plain Layout

		representation(title = "character"), contains = "Person") 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Create a S4 new instance.
\end_layout

\begin_layout Standard
S4 method is capable check each attributes satisfy the constraints.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

yuchen <- new("Reporter", name = "yuchen", age = 22, title = 22) 
\end_layout

\begin_layout Plain Layout

yuchen <- new("Reporter", name = "yuchen", age = 22, title = "R and OO")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
unclass: remove the class attribute & features.to de-factor or delist
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

test_str = substring("statistics", 1:10, 1:10)
\end_layout

\begin_layout Plain Layout

test_str
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

# x is the labels provided
\end_layout

\begin_layout Plain Layout

# levels are the universe of all labels.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ff <- factor(x = test_str, levels = letters)
\end_layout

\begin_layout Plain Layout

ff
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

unclass_ff = unclass(ff)
\end_layout

\begin_layout Plain Layout

unclass_ff
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

attr(,"levels")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class(unclass_ff)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
method
\end_layout

\begin_layout Standard
methods are functions that behave differently depending on the class of
 their input.
 
\end_layout

\begin_layout Standard
Often you will see the function’s source code is hiding behind some generic
 method
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

lda
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
All the methods of a generic function: 
\family typewriter
methods(generic.function)
\family default
:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

methods(generic.function=predict)
\end_layout

\begin_layout Plain Layout

methods("mean") 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
All generics that have a method for a given class 
\family typewriter
methods(class)
\family default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

methods(class = "ts")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
• Because methods are normal R functions, you can call them directly:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

print.data.frame()
\end_layout

\begin_layout Plain Layout

getS3method("predict", "lm") # show the source code of generic function
 predict on class lm
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## OR package::: generic.class
\end_layout

\begin_layout Plain Layout

MASS:::lda.formula
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
UseMethod
\family default
() get methods from an S3 object
\end_layout

\begin_layout Standard

\family typewriter
UseMethod("mean") 
\end_layout

\begin_layout Subsection
DispatchGroup() get methods from an S3 object coded by C
\end_layout

\begin_layout Standard
Some S3 generics, like [, sum(), and cbind(), don’t call UseMethod() because
 they are implemented in C.
 Instead, they call the C functions 
\end_layout

\begin_layout Standard

\family typewriter
DispatchGroup() 
\end_layout

\begin_layout Standard
or 
\end_layout

\begin_layout Standard

\family typewriter
DispatchOrEval()
\end_layout

\begin_layout Subsection
Generic method in S4
\end_layout

\begin_layout Standard
Define a generic function named as “prepare”
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

setGeneric("prepare", function(object) { standardGeneric("prepare") }) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Define a method on a specific class “Person”
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

setMethod("prepare", 
\end_layout

\begin_layout Plain Layout

			signature(object = "Person"), 
\end_layout

\begin_layout Plain Layout

			function(object) cat("Got Materials.
\backslash
n") }) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Use the specific method
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

prepare(new("Person")) 
\end_layout

\begin_layout Plain Layout

## Got Materials.
 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Define method hierarchy using 
\family typewriter
callNextMethod() 
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

setMethod("prepare", signature(object = "Reporter"), function(object){ 
\end_layout

\begin_layout Plain Layout

callNextMethod() 
\end_layout

\begin_layout Plain Layout

cat("Slides are ready.
\backslash
n") 
\end_layout

\begin_layout Plain Layout

}) 
\end_layout

\begin_layout Plain Layout

prepare(new("Reporter")) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Attributes
\end_layout

\begin_layout Subsection
Attributes: storage of metadata
\end_layout

\begin_layout Standard
All objects can have arbitrary additional attributes, used to store metadata
 about the object.
 Attributes can be thought of as a named list (with unique names).
 Attributes can be accessed individually with 
\family typewriter
attr()
\family default
 or all at once (as a list) with 
\family typewriter
attributes()
\family default
.
\end_layout

\begin_layout Standard

\family typewriter
• attr ()
\family default
: Add an attribute to an object / get a specific attribute
\end_layout

\begin_layout Standard
• 
\family typewriter
attributes ()
\family default
: show all attributes.
\end_layout

\begin_layout Standard
An object’s class, dimension, names, colnames etc are most common attributes.
 
\end_layout

\begin_layout Standard
Each of these attributes has a specific accessor function to get and set
 values.
 When working with these attributes, use names(x), class(x), and dim(x),
 not attr(x, "names"), attr(x, "class"), and attr(x, "dim").
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

attr(y, "my_attribute") <- "This is a vector"
\end_layout

\begin_layout Plain Layout

attr(y, "my_attribute")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# this is a list
\end_layout

\begin_layout Plain Layout

str(attributes(y)) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# By default, most attributes are lost when modifying a vector:
\end_layout

\begin_layout Plain Layout

attributes(y[1])
\end_layout

\begin_layout Plain Layout

#> NULL
\end_layout

\begin_layout Plain Layout

attributes(sum(y))
\end_layout

\begin_layout Plain Layout

#> NULL
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only attributes not lost are the three most important:
\end_layout

\begin_layout Itemize
Names, a character vector giving each element a name, described in names.
\end_layout

\begin_layout Itemize
Dimensions, used to turn vectors into matrices and arrays, described in
 matrices and arrays.
\end_layout

\begin_layout Itemize
Class, used to implement the S3 object system, described in S3.
\end_layout

\begin_layout Subsubsection
Access attributes 
\family typewriter
S3$attr
\end_layout

\begin_layout Subsubsection
Access attributes 
\family typewriter
S4@attr
\end_layout

\begin_layout Subsection
Set default values of attributes: S4 class
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

setClass("Person", 
\end_layout

\begin_layout Plain Layout

         # attributes in S4
\end_layout

\begin_layout Plain Layout

         representation(name = "character", age = "numeric"),  
\end_layout

\begin_layout Plain Layout

         # prototype is to set default values
\end_layout

\begin_layout Plain Layout

         prototype(name = NA_character_, # default name is NA
\end_layout

\begin_layout Plain Layout

                   age = NA_real_)) # default age is NA
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

new("Person", name = "yuchen")@name
\end_layout

\begin_layout Plain Layout

new("Person", name = "yuchen")@age
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Add constraints to attributes for S4
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

CheckAge <- function(object) { if (object@age <= 0) { 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  stop("Age is negative.") } 
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

setClass("Person", 
\end_layout

\begin_layout Plain Layout

         representation(name = "character", age = "numeric"), 
\end_layout

\begin_layout Plain Layout

         # constraints are in the format of a function
\end_layout

\begin_layout Plain Layout

         validity = CheckAge) 
\end_layout

\begin_layout Plain Layout

new("Person", age = -5) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
S3, S4 and R5
\end_layout

\begin_layout Subsection
S3
\end_layout

\begin_layout Itemize
In S3, methods belong to functions, called generic functions, or generics
 for short.
 They do not belong to objects or classes.
 This is different from most other programming languages, but is a legitimate
 OO style.
\end_layout

\begin_layout Itemize
You can recognize S3 methods by their names, which look like 
\family typewriter
generic.class()
\family default
.
 For example, the Date method for the mean() generic is called 
\family typewriter
mean.Date()
\family default
, and the factor method for print() is called print.factor().
\end_layout

\begin_layout Itemize
Apart from methods defined in the base package, most S3 methods will not
 be visible: use getS3method()
\end_layout

\begin_layout Standard
You can also call an S3 generic with a non-S3 object.
 Non-internal S3 generics will dispatch on the implicit class of base types.
\end_layout

\begin_layout Standard
Print that function you will see
\end_layout

\begin_layout Subsection
S4
\end_layout

\begin_layout Standard
S4 works in a similar way to S3: Methods still belong to functions, not
 classes.
\end_layout

\begin_layout Standard
But it adds formality and rigor.
\end_layout

\begin_layout Itemize
Classes have formal definitions which describe their fields and inheritance
 structures (parent classes).
\end_layout

\begin_layout Itemize
Method dispatch can be based on multiple arguments to a generic function,
 not just one.
 (S3’s method dispatch can only be based on one argument’s class)
\end_layout

\begin_layout Itemize
There is a special operator, @, for extracting slots (aka fields) from an
 S4 object.
\end_layout

\begin_layout Itemize
You can identify an S4 object because str() describes it as a “
\family typewriter
formal
\family default
” class, 
\family typewriter
isS4()
\family default
 returns TRUE, and 
\family typewriter
pryr::otype()
\family default
 returns “S4”.
 
\end_layout

\begin_layout Subsection
R5 or RC: Reference classes
\end_layout

\begin_layout Standard
http://adv-r.had.co.nz/OO-essentials.html
\end_layout

\begin_layout Standard
Reference classes (or RC for short) are the newest OO system in R.
 They were introduced in version 2.12.
 They are fundamentally different to S3 and S4 because:
\end_layout

\begin_layout Itemize
RC methods belong to objects, not functions
\end_layout

\begin_layout Itemize
RC objects are mutable: the usual R copy-on-modify semantics do not apply
\end_layout

\begin_layout Standard
These properties make RC objects behave more like objects do in most other
 programming languages, e.g., Python, Ruby, Java, and C#.
 
\end_layout

\begin_layout Standard
When you usually call 
\family typewriter
f(a, b)
\family default
 in 
\family typewriter
R
\family default
 you can assume that 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 will not be modified.
 But if 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 are RC objects, they might be modified in the place.
 Generally, when using RC objects you want to minimise side effects as much
 as possible, and use them only where mutable states are absolutely required.
 The majority of functions should still be “functional”, and free of side
 effects.
 
\end_layout

\begin_layout Section
get structure of Objects
\end_layout

\begin_layout Subsection
class(), type() and mode()
\end_layout

\begin_layout Enumerate
The c
\family typewriter
lass()
\family default
 is used to define/identify what "type" an object is from the point of view
 of general object-oriented programming .
\end_layout

\begin_layout Enumerate

\family typewriter
typeof()
\family default
 gives the "type" of object from R's point of view.
\end_layout

\begin_layout Enumerate

\family typewriter
mode()
\family default
 gives the "type" of object from the point of view of Becker, Chambers &
 Wilks (1988).
 The latter may be more compatible with other S implementations according
 to the R Language Definition manual.
\end_layout

\begin_layout Subsection

\family typewriter
str()
\family default
: structure of the object
\end_layout

\begin_layout Standard
Often used on data.frame: Compactly Display the Structure of an Arbitrary
 R Object.
 Useful to show the structure and classes/types of data.frame and its each
 column
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

df <- data.frame(x = 1:3, y = c("a", "b", "c"))
\end_layout

\begin_layout Plain Layout

str(df)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
structure(): return/assign/change the attributes
\end_layout

\begin_layout Standard
change the dimension attributes .
\end_layout

\begin_layout Standard
Note that this is different from 
\family typewriter
str()
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

structure(1:6, dim = 2:3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# assign the class attributes
\end_layout

\begin_layout Plain Layout

foo <- structure(1, class = c("son", "father"))
\end_layout

\begin_layout Plain Layout

class(foo)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

foo + 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

attr(foo + 1,"class")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Also you can use this to create a return of function on certain class
\end_layout

\begin_layout Plain Layout

# Like the fda.defualt ‘s return:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# structure(list(prior = prior, counts = counts, means = group.means, 
\end_layout

\begin_layout Plain Layout

#    scaling = scaling, lev = lev, svd = X.s$d[1L:rank], N = n, 
\end_layout

\begin_layout Plain Layout

#    call = cl), class = "lda")
\end_layout

\end_inset


\end_layout

\begin_layout Section
Expression
\end_layout

\begin_layout Subsection
Expression as an object
\end_layout

\begin_layout Standard
expression: an object that represents an 
\series bold
action
\series default
 that can be performed by R.
\end_layout

\begin_layout Standard
There are four possible components of an expression: 
\end_layout

\begin_layout Enumerate
constants
\end_layout

\begin_layout Enumerate
names
\end_layout

\begin_layout Enumerate
calls
\end_layout

\begin_layout Enumerate
pairlists.
 (see the subsection of tree structure of the code)
\end_layout

\begin_layout Standard
To create an epxression, use quote:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

z <- quote(y <- x * 10)
\end_layout

\begin_layout Plain Layout

z
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Structure of Calls 
\end_layout

\begin_layout Standard
Call is one type of expression.
\end_layout

\begin_layout Itemize
Calls represent the action of calling a function.
 Like lists, calls are recursive: they can contain constraints, names, pairlists
 and other calls.
\end_layout

\begin_layout Itemize
Call has the structure of a list
\end_layout

\begin_layout Itemize
First element is function name
\end_layout

\begin_layout Itemize
Other elements are arguments in that function
\end_layout

\begin_layout Standard
One interesting thing is if you delete the first argument in a call, then
 the second argument will atuomatially become the function name.
 This is often used when you want to use ...
 argument to create a list of call structures with first element as the
 function name.
 Then you cansubstitute it and delete the first argument 
\begin_inset Quotes eld
\end_inset

list()
\begin_inset Quotes erd
\end_inset

, it will give the call you want.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  a_full <- substitute(list(df, var, values))
\end_layout

\begin_layout Plain Layout

  a_full
\end_layout

\begin_layout Plain Layout

  a_full %>% class
\end_layout

\begin_layout Plain Layout

  a_full[1]
\end_layout

\begin_layout Plain Layout

  a_full[1] %>% class
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  a_full[-1]
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\family typewriter
quote()/substitute
\family default
 
\change_inserted 16419249 1460038830
--
\change_deleted 16419249 1460038830
:
\change_unchanged
 Create a call: Put a function in a quote, then later you can evaluate the
 call’s structure.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x <- quote(read.csv("important.csv", row.names = FALSE))
\end_layout

\begin_layout Plain Layout

x %>% class 
\change_inserted 16419249 1460039310

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039313

# [1] "call" 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x[[1]] # function name
\change_inserted 16419249 1460039318

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039320

# read.csv 
\change_unchanged

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039323

\end_layout

\begin_layout Plain Layout

x[[1]] %>% class 
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039333

# [1] "name"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x[[3]]
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039363

# [1] FALSE 
\change_unchanged

\end_layout

\begin_layout Plain Layout

x[[4]]
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039358

# Error in x[[4]] : subscript out of bounds 
\change_unchanged

\end_layout

\begin_layout Plain Layout

length(x)
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039354

# [1] 3 
\change_unchanged

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# If you want a list of the unevaluated arguments (expressions), 
\end_layout

\begin_layout Plain Layout

# use explicit coercion:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# A list of the unevaluated arguments
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

as.list(x[-1])
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
double substitute, get expression represented by a name
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

code = substitute(1+1)
\end_layout

\begin_layout Plain Layout

substitute(code)
\change_inserted 16419249 1460039548

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039550

# code
\change_unchanged

\end_layout

\begin_layout Plain Layout

substitute(code_dummy,env = list(code_dummy = code))
\change_inserted 16419249 1460039552

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039558

# 1 +1
\change_unchanged

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
as.call: create a call by its component
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

as.call(list(quote(mean), quote(1:10)))
\end_layout

\begin_layout Plain Layout

as.call(list(quote(adder(10)), 20))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
list: modify a call
\end_layout

\begin_layout Standard
You can add, modify and delete elements of the call with the standard replacemen
t operators, $<- and [[<-:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

y <- quote(read.csv("important.csv", row.names = FALSE))
\end_layout

\begin_layout Plain Layout

y$row.names <- TRUE
\end_layout

\begin_layout Plain Layout

y$col.names <- FALSE
\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

y[[2]] <- quote(paste0(filename, ".csv"))
\end_layout

\begin_layout Plain Layout

y[[4]] <- NULL
\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

y$sep <- ","
\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
ast : tree structure of the code (expression)
\end_layout

\begin_layout Standard
An expression is also called an abstract syntax tree (AST) because it represents
 the hierarchical tree structure of a code.
 We’ll use pryr::ast() to see this more clearly:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

ast(y <- x * 10)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
update: update a call
\end_layout

\begin_layout Subsection
update: update a linear formula
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

mod <- lm(mpg ~ wt, data = mtcars)
\end_layout

\begin_layout Plain Layout

update(mod, formula = .
 ~ .
 + cyl)
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
standardise_call : standardize argument position of a call
\end_layout

\begin_layout Standard
Calls are different, sometimes only due to they have different positions
 for the same arguments.
\end_layout

\begin_layout Standard
Calls below have the same effect, 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

m1 <- quote(read.delim("data.txt", sep = "|"))
\end_layout

\begin_layout Plain Layout

m2 <- quote(read.delim(s = "|", "data.txt"))
\end_layout

\begin_layout Plain Layout

m3 <- quote(read.delim(file = "data.txt", , "|"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# To work around this problem, pryr provides standardise_call().
 It uses the base match.call() function to convert all positional arguments
 to named arguments:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

standardise_call(m1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

standardise_call(m2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

standardise_call(m3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Advanced Modification of a call: Walking the AST with recursive functions
\end_layout

\begin_layout Standard
It’s easy to modify a single call with substitute() or pryr::modify_call().
 For more complicated tasks we need to work directly with the AST.
 The base codetools package provides some useful motivating examples of
 how we can do this:
\end_layout

\begin_layout Standard
http://adv-r.had.co.nz/Expressions.html#parsing-and-deparsing
\end_layout

\begin_layout Subsection

\change_inserted 16419249 1460039670
match.call in function: get call structure for later change
\end_layout

\begin_layout Standard

\change_inserted 16419249 1460039670
match.call returns a call in which all of the specified arguments are specified
 by their full names.
\end_layout

\begin_layout Subsubsection

\change_inserted 16419249 1460039670
What it looks like
\end_layout

\begin_layout Description

\change_inserted 16419249 1460039670
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

<<eval = F>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

match.call (definition = sys.function(sys.parent()),
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

			call = sys.call(sys.parent()),
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

			expand.dots = TRUE,
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

			envir = parent.frame(2L))
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\change_inserted 16419249 1460039670
Usage
\end_layout

\begin_layout Standard

\change_inserted 16419249 1460039670
Normally we use it within a function, thus it will return the call of that
 function.
 Then we can manipulate that call to pass it to future functions.
\end_layout

\begin_layout Subsubsection

\change_inserted 16419249 1460039670
Basic Functionality
\end_layout

\begin_layout Standard

\change_inserted 16419249 1460039670
When expand.dots = T as default, match.call will return the specified argument,
 when expand.dots = TF, it will return the ...
 itself
\end_layout

\begin_layout Standard

\change_inserted 16419249 1460039670
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

<<>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

f <- function(x, y, ...) match.call()
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call = f(y = 1, 2, z = 3, 4)
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call %>% class
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call$x
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call$y
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call$z
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

f <- function(x, y, ...) match.call(expand.dots = F)
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call = f(y = 1, 2, z = 3, 4)
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call$z
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

Call$...
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

> Call$...
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

$z
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

[1] 3
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

[[2]]
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

[1] 4
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\change_inserted 16419249 1460039670
Examples
\end_layout

\begin_layout Standard

\change_inserted 16419249 1460039670
Below are examples inside lm(), it uses the inputs argument, delete some
 unused parts, and then change the function to 
\begin_inset Quotes eld
\end_inset

model.frame
\begin_inset Quotes erd
\end_inset

, and fianlly evaluate it.
\end_layout

\begin_layout Standard

\change_inserted 16419249 1460039670
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

<<eval = F>>=
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

    mf <- cl <- match.call()
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

	mf$singular.ok <- mf$model <- mf$method <- NULL
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

	mf$x <- mf$y <- mf$qr <- mf$contrasts <- NULL
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

	mf$drop.unused.levels <- TRUE
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

	mf[[1]] <- as.name("model.frame")
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

	mf <- eval(mf, sys.frame(sys.parent()))
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039670

@
\end_layout

\end_inset


\end_layout

\begin_layout Part
Metaprogramming Theory
\end_layout

\begin_layout Standard
Metaprogramming is the writing of computer programs with the ability to
 treat programs/code as their data.
 It means that a program could be designed to read, generate, analyse and/or
 transform other programs, and even modify itself while running.
\end_layout

\begin_layout Subsection
What is Lazy evaluation
\end_layout

\begin_layout Standard
In programming language theory, lazy evaluation, or call-by-need[1] is an
 evaluation strategy which delays the evaluation of an expression until
 its value is needed (non-strict evaluation) and which also avoids repeated
 evaluations (sharing).
\end_layout

\begin_layout Standard
# a simple example of lazy evaluation
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lazy_eval = function(variable,values){
\end_layout

\begin_layout Plain Layout

    assign(names(values)[1],values[1]) # create a local environment where
 CFSDF = 2
\end_layout

\begin_layout Plain Layout

    eval(I(CFSDF^2))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

lazy_eval(I(CFSDF^2),c(CFSDF=2))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
• To create unevaluated code directly: use 
\family typewriter
quote()
\end_layout

\begin_layout Standard
• To create unevaluated code from text: use 
\family typewriter
parse(), 
\family default
example below
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

parse(text = "ttt^2")
\end_layout

\begin_layout Plain Layout

parse(text = "ttt^2") %>% class 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

eval(parse(text = "ttt^2"),envir= list(ttt=2))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# parse returns the parsed but unevaluated expressions in a list.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Promise objects as Function Arguments
\end_layout

\begin_layout Standard
Function arguments in R is in class of “promise”.
 They are not evaluated when defined, they are only evaluated when we call
 the function.
\end_layout

\begin_layout Standard
Promise objects are part of R's lazy evaluation mechanism.
 They contain three slots:
\end_layout

\begin_layout Standard
1.
 an expression, (the expression/code to get a value)
\end_layout

\begin_layout Standard
2.
 a value, (the value you would get when you evaluate the expression) 
\end_layout

\begin_layout Standard
3.
 and an environment ( yes, an argument may have different values in Global
 Environment from a next environment)
\end_layout

\begin_layout Standard
When a function is called the arguments are matched and then each of the
 formal arguments is bound to a promise.
 The expression that was given for that formal argument and a pointer to
 the environment the function was called from are stored in the promise.
\end_layout

\begin_layout Standard
Until that argument is accessed there is no value associated with the promise.
 When the argument is accessed, the stored expression is evaluated in the
 stored environment, and the result is returned.
 The result is also saved by the promise.
 The substitute function will extract the content of the expression slot.
 This allows the programmer to access either the value or the expression
 associated with the promise.
\end_layout

\begin_layout Standard
Within the R language, promise objects are almost only seen implicitly:
 actual function arguments are of this type.
 There is also a delayed.
 Assign function that will make a promise out of an expression.
 There is generally no way in R code to check whether an object is a promise
 or not, nor is there a way to use R code to determine the environment of
 a promise.
\end_layout

\begin_layout Part
Metaprogramming Practice
\end_layout

\begin_layout Subsection
substitute, quote, and eval
\change_inserted 16419249 1460039817

\end_layout

\begin_layout Standard

\change_inserted 16419249 1460039818
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460039818

> substitute(sum(1+1)) %>% class
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039818

[1] "call"
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039818

> quote(sum(1+1)) %>% class
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460039818

[1] "call"
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
Not too much empirical difference between substitute and quote
\end_layout

\begin_layout Itemize
substitute takes a function argument (a special type of object called a
 promise) and returns a parse tree.
 Basically, substitute sees the code and not the value you supply as an
 argument to a function, and returns the unevaluated expression (really
 a parse tree, but we can think of it as an expression).
\end_layout

\begin_layout Itemize
quote is like substitute but simpler.
 quote takes an expression as an argument and returns an expression, i.e.
 it returns its argument without evaluating it.
\end_layout

\begin_layout Itemize
We use eval 
\change_deleted 16419249 1460039745
o
\change_inserted 16419249 1460039745
to
\change_unchanged
 actually evaluate an expression.
 
\end_layout

\begin_layout Enumerate
Thus, we often take the output of 
\series bold
quote or substitute
\series default
 as the input to eval when we are ready to evaluate an expression we have
 captured.
\end_layout

\begin_layout Enumerate
Both substitue and quote will return a call, which you can later manipulate.
\end_layout

\begin_layout Standard
Retun the code and not the value you supply as an argument to a function,
 and returns the unevaluated expression (really a parse tree, but we can
 think of it as an expression).
\end_layout

\begin_layout Standard
Substitute can be used to change the parse tree of an expression, but It
 is in fact not often that one wants to modify the innards of an expression
 like in the previous section.
\end_layout

\begin_layout Subsection
deparse(substitute(x)): return 
\change_deleted 16419249 1460040401
the object's name
\change_inserted 16419249 1460040401
x
\change_unchanged
 as character
\end_layout

\begin_layout Standard
deparse(substitute(x))
\end_layout

\begin_layout Itemize

\change_inserted 16419249 1460041662
In a function: 
\change_deleted 16419249 1460041914
# to let the code print th
\change_inserted 16419249 1460041919
return as character of 
\change_deleted 16419249 1460041920
e
\change_inserted 16419249 1460041920
an
\change_unchanged
 
\change_inserted 16419249 1460041650
underlying object's name of argument 
\change_deleted 16419249 1460041653
original name of x 
\change_unchanged
in a function.

\change_deleted 16419249 1460041883
 Only used inside function.
\change_inserted 16419249 1460041884

\end_layout

\begin_layout Itemize

\change_inserted 16419249 1460041928
in Global: return the code as character:
\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460040424

> deparse(substitute(y))
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040424

[1] "y"
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040424

> deparse(substitute(b))
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040424

[1] "b"
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040418

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040414

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040414

foo = function(x= y){
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040414

   deparse(substitute(x)) 
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040414

  }
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040416

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040444

> foo(y)
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040444

[1] "y"
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040444

> foo(y) %>% class
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040444

[1] "character"
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040444

> foo(b)
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040444

[1] "b"
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1460040414

foo = function(x= y){
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1460040414

+ deparse(substitute(x)) 
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1460040447

+ }
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1460040447

foo(y)
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1460040447

foo(b)
\change_unchanged

\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\change_inserted 16419249 1460042112
multuple line of code: return a secquence of characters, with each element
 of the sequence representing one single line of code
\end_layout

\begin_layout Standard

\change_inserted 16419249 1460042033
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460042034

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460042034

deparse(substitute(
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460042034

                      function(a,b){
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460042034

                        a+1
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460042034

                        b+1
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460042034

                      }))
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460042051

# [1] "function(a, b) {" "    a + 1"        "    b + 1"        "}"     
           
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460042036

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Example: 
\family typewriter
deparse(substitute(ggplot2))
\family default
: used in direct reference without quotes
\end_layout

\begin_layout Standard
Here are a lot of functions in Base R that use these ideas.
 Some use them to avoid quotes:
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460040160

\family typewriter
library(ggplot2)
\change_inserted 16419249 1460040160

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460040160

library(ggplot2)
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard

\family typewriter
# because inside the function “library”, we use deparse(substitute(ggplot2)).
 
\end_layout

\begin_layout Standard

\family typewriter
# It is the same as
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460040166

\family typewriter
library("ggplot2")
\change_inserted 16419249 1460040166

\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460040166

library("ggplot2")
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Subsection
substitute(x, envir): used in plot label and math annotation
\end_layout

\begin_layout Standard
More frequently, one wants to simply get at an expression in order to deparse
 it (expression to string) and use it for labeling plots, for instance.
 An example of this is seen at the beginning of plot.default:
\end_layout

\begin_layout Standard

\change_inserted 16419249 1460040184

\family typewriter
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted 16419249 1460040184

xlabel <- if (!missing(x))
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460040184

deparse(substitute(x))
\change_unchanged

\end_layout

\end_inset


\change_deleted 16419249 1460040184
xlabel <- if (!missing(x))
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460040184

\family typewriter
deparse(substitute(x))
\change_unchanged

\end_layout

\begin_layout Standard
Also, substitute has an additional argument which can be an environment
 or a list in which the variables are looked up.
 So that for variables that can be found a value in the provided environment,
 the substitute will force to evaluate it and return its value.
\end_layout

\begin_layout Standard
The exact rules for substitutions are as follows: 
\end_layout

\begin_layout Standard
1.
 Each symbol in the parse tree for the first is matched against the second
 argument, which can be a tagged list or an environment frame.
 
\end_layout

\begin_layout Standard
2.
 If it is a simple local object, its value is inserted, except if matching
 against the global environment.
\end_layout

\begin_layout Standard
3.
 If it is a promise (usually a function argument), the promise expression
 is substituted.
 If the symbol is not matched, it is left untouched.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

plot(0)
\end_layout

\begin_layout Plain Layout

for (i in 1:4) {
\end_layout

\begin_layout Plain Layout

    text(1, 0.2 * i,substitute(x[ix] == y, list(ix = i, y = pnorm(i))))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

# If not provide the environment for it, we will have no values
\end_layout

\begin_layout Plain Layout

plot(0)
\end_layout

\begin_layout Plain Layout

for (i in 1:4) {
\end_layout

\begin_layout Plain Layout

    text(1, 0.2 * i,substitute(x[i] == pnorm(i)))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
lazy(), lazyeval(exp, envir)
\end_layout

\begin_layout Standard
See : https://cran.r-project.org/web/packages/lazyeval/vignettes/lazyeval.html
\end_layout

\begin_layout Standard
The key tool that makes this approach possible is lazy(), an equivalent
 to substitute() that captures both expression and environment associated
 with a function argument:
\end_layout

\begin_layout Standard
# 
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(lazyeval)
\end_layout

\begin_layout Plain Layout

f <- function(x = a - b) {
\end_layout

\begin_layout Plain Layout

    lazy(x)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

f()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#> <lazy>
\end_layout

\begin_layout Plain Layout

#> expr: a - b
\end_layout

\begin_layout Plain Layout

#> env: <environment: 0x7fd2f3a406b0>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f(a + b)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#> <lazy>
\end_layout

\begin_layout Plain Layout

#> expr: a + b
\end_layout

\begin_layout Plain Layout

#> env: <environment: R_GlobalEnv>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
lazyeval(exp, envir)
\end_layout

\begin_layout Standard
As a complement to eval(), the lazy package provides lazy_eval() that uses
 the environment associated with the lazy object:
\end_layout

\begin_layout Itemize
lazy_eval() will always coerce it’s first argument into a lazy object, so
 a variety of specifications will work:
\end_layout

\begin_layout Itemize
The second argument to lazy eval is a list or data frame where names should
 be looked up first:
\end_layout

\begin_layout Itemize
lazy_eval() also works with formulas, since they contain the same information
 as a lazy object: an expression (only the RHS is used by convention) and
 an environment:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

a <- 10
\end_layout

\begin_layout Plain Layout

b <- 1
\end_layout

\begin_layout Plain Layout

lazy_eval(f())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lazy_eval(f(a + b))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lazy_eval(f(), list(a = 1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# lazy_eval() also works with formulas, since they contain the same information
 as a lazy object: an expression (only the RHS is used by convention) and
 an environment:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lazy_eval(~ a + b)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

h <- function(i) {
\end_layout

\begin_layout Plain Layout

~ 10 + i
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lazy_eval(h(1))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
as.name(“x”) : return object's name
\end_layout

\begin_layout Standard
Often use with eval,
\end_layout

\begin_layout Standard
eval(as.name(character))
\end_layout

\begin_layout Standard
“name” is a class; it is one kind of expressions
\end_layout

\begin_layout Standard
A ‘name’ (also known as a ‘symbol’) is a way to refer to R objects by name
\end_layout

\begin_layout Standard
as.name and as.symbol are identical: they attempt to coerce the argument to
 a name.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

a=1
\end_layout

\begin_layout Plain Layout

as.name('a')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

class(as.name('a'))
\end_layout

\begin_layout Plain Layout

eval(as.name('a'))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
get(
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

)
\change_inserted 16419249 1460038739
 --
\change_deleted 16419249 1460038737
: 
\change_unchanged
return a call: Call an R object using a character string.
\end_layout

\begin_layout Standard
Call an R object using a character string.
 as a call is an action, that means you evaluate 
\begin_inset Quotes eld
\end_inset

x
\begin_inset Quotes erd
\end_inset

 and exercise it into an action.
 
\end_layout

\begin_layout Standard
How to use: 
\end_layout

\begin_layout Itemize
get("function") will return the function itself.
 get(
\begin_inset Quotes eld
\end_inset

function
\begin_inset Quotes erd
\end_inset

)(argument1, argument2) to evaluate the function with its argument
\end_layout

\begin_layout Itemize
get(
\begin_inset Quotes eld
\end_inset

object_name
\begin_inset Quotes erd
\end_inset

) will return the object itself.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

get("mean")
\end_layout

\begin_layout Plain Layout

get("mean")(c(1.5, 2.5, 3.5, 4.5))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
 x – The name of an R object, listed as a character string.
\end_layout

\begin_layout Standard
The reverse of a <- get(nam) is assign(name, a).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

L3 <- list("list", "of", "three")
\end_layout

\begin_layout Plain Layout

get("L3")
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

get("L3[[3]]") # not work
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

get("L3")[[3]] # works
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
assign (create variable with specific character name)
\end_layout

\begin_layout Standard
http://stackoverflow.com/questions/5510966/create-a-variable-name-with-paste-in-r
\end_layout

\begin_layout Standard
assign(character_as_name, object)
\end_layout

\begin_layout Standard
Y<<>>=ou can use assign (doc) to change the value of perf.a1:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

assign(paste("perf.a", "1", sep=""),5)
\end_layout

\begin_layout Plain Layout

perf.a1
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This can only be used with paste( ) or something already exists.
\end_layout

\begin_layout Subsection

\change_deleted 16419249 1460039658
match.call in function: get call structure for later change
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460039658
match.call returns a call in which all of the specified arguments are specified
 by their full names.
\end_layout

\begin_layout Subsubsection

\change_deleted 16419249 1460039658
What it looks like
\end_layout

\begin_layout Description

\change_deleted 16419249 1460039658
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval = F>>=
\end_layout

\begin_layout Plain Layout

match.call (definition = sys.function(sys.parent()),
\end_layout

\begin_layout Plain Layout

			call = sys.call(sys.parent()),
\end_layout

\begin_layout Plain Layout

			expand.dots = TRUE,
\end_layout

\begin_layout Plain Layout

			envir = parent.frame(2L))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\change_deleted 16419249 1460039658
Usage
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460039658
Normally we use it within a function, thus it will return the call of that
 function.
 Then we can manipulate that call to pass it to future functions.
\end_layout

\begin_layout Subsubsection

\change_deleted 16419249 1460039658
Basic Functionality
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460039658
When expand.dots = T as default, match.call will return the specified argument,
 when expand.dots = TF, it will return the ...
 itself
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460039658
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f <- function(x, y, ...) match.call()
\end_layout

\begin_layout Plain Layout

Call = f(y = 1, 2, z = 3, 4)
\end_layout

\begin_layout Plain Layout

Call
\end_layout

\begin_layout Plain Layout

Call %>% class
\end_layout

\begin_layout Plain Layout

Call$x
\end_layout

\begin_layout Plain Layout

Call$y
\end_layout

\begin_layout Plain Layout

Call$z
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

f <- function(x, y, ...) match.call(expand.dots = F)
\end_layout

\begin_layout Plain Layout

Call = f(y = 1, 2, z = 3, 4)
\end_layout

\begin_layout Plain Layout

Call
\end_layout

\begin_layout Plain Layout

Call$z
\end_layout

\begin_layout Plain Layout

Call$...
\change_inserted 16419249 1460038566

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460038567

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460038570

> Call$...
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460038570

$z
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460038570

[1] 3
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460038570

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460038570

[[2]]
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1460038570

[1] 4
\change_unchanged

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\change_deleted 16419249 1460039658
Examples
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460039658
Below are examples inside lm(), it uses the inputs argument, delete some
 unused parts, and then change the function to 
\begin_inset Quotes eld
\end_inset

model.frame
\begin_inset Quotes erd
\end_inset

, and fianlly evaluate it.
\end_layout

\begin_layout Standard

\change_deleted 16419249 1460039658
\begin_inset ERT
status open

\begin_layout Plain Layout

<<eval = F>>=
\end_layout

\begin_layout Plain Layout

    mf <- cl <- match.call()
\end_layout

\begin_layout Plain Layout

	mf$singular.ok <- mf$model <- mf$method <- NULL
\end_layout

\begin_layout Plain Layout

	mf$x <- mf$y <- mf$qr <- mf$contrasts <- NULL
\end_layout

\begin_layout Plain Layout

	mf$drop.unused.levels <- TRUE
\end_layout

\begin_layout Plain Layout

	mf[[1]] <- as.name("model.frame")
\end_layout

\begin_layout Plain Layout

	mf <- eval(mf, sys.frame(sys.parent()))
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Subsection
defmacro: Macro Programming in R
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

####
\end_layout

\begin_layout Plain Layout

# macro for replacing a specified missing value indicator with NA
\end_layout

\begin_layout Plain Layout

# within a dataframe
\end_layout

\begin_layout Plain Layout

###
\end_layout

\begin_layout Plain Layout

setNA <- defmacro(df, var, values,
\end_layout

\begin_layout Plain Layout

                  expr={
\end_layout

\begin_layout Plain Layout

                         df$var[df$var %in% values] <- NA
\end_layout

\begin_layout Plain Layout

                       })
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# create example data using 999 as a missing value indicator
\end_layout

\begin_layout Plain Layout

d <- data.frame(
\end_layout

\begin_layout Plain Layout

   Grp=c("Trt", "Ctl", "Ctl", "Trt", "Ctl", "Ctl", "Trt", "Ctl", "Trt",
 "Ctl"),
\end_layout

\begin_layout Plain Layout

   V1=c(1, 2, 3, 4, 5, 6, 999, 8,   9,  10),
\end_layout

\begin_layout Plain Layout

   V2=c(1, 1, 1, 1, 1, 2, 999, 2, 999, 999)
\end_layout

\begin_layout Plain Layout

               )
\end_layout

\begin_layout Plain Layout

d
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Try it out
\end_layout

\begin_layout Plain Layout

setNA(d, V1, 999)
\end_layout

\begin_layout Plain Layout

setNA(d, V2, 999)
\end_layout

\begin_layout Plain Layout

d
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Can have multiple variables
\end_layout

\begin_layout Standard
expression can be multi-line, but by default will only print the last line
\end_layout

\begin_layout Standard
Note that everything inside defmacro is GLOBAL, so if you change a variable
 inside, it will be changed globally.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

y=1
\end_layout

\begin_layout Plain Layout

test = defmacro(change, expr = {y=change})
\end_layout

\begin_layout Plain Layout

test(2)
\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Research on dfmacro
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

function (..., expr) 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

  expr <- substitute(expr)
\end_layout

\begin_layout Plain Layout

#   
\end_layout

\begin_layout Plain Layout

#   a_full <- substitute(list(df, var, values))
\end_layout

\begin_layout Plain Layout

#   a_full
\end_layout

\begin_layout Plain Layout

#   a_full %>% class
\end_layout

\begin_layout Plain Layout

#   a_full[1]
\end_layout

\begin_layout Plain Layout

#   a_full[1] %>% class
\end_layout

\begin_layout Plain Layout

#   
\end_layout

\begin_layout Plain Layout

#   a = a_full[-1]
\end_layout

\begin_layout Plain Layout

  a <- substitute(list(...))[-1] # delelte the list()
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  nn <- names(a)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # make a as an list,  with names as arguments in ..., 
\end_layout

\begin_layout Plain Layout

  # values as the stop meesage if certain arugument is missing
\end_layout

\begin_layout Plain Layout

  if (is.null(nn)) 
\end_layout

\begin_layout Plain Layout

    nn <- rep("", length(a))
\end_layout

\begin_layout Plain Layout

  for (i in 1:length(a)) {
\end_layout

\begin_layout Plain Layout

    if (nn[i] == "") { 
\end_layout

\begin_layout Plain Layout

      nn[i] <- paste(a[[i]])
\end_layout

\begin_layout Plain Layout

      msg <- paste(a[[i]], "not supplied")
\end_layout

\begin_layout Plain Layout

      a[[i]] <- substitute(stop(foo), list(foo = msg))
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    if (nn[i] == "DOTS") {
\end_layout

\begin_layout Plain Layout

      nn[i] <- "..."
\end_layout

\begin_layout Plain Layout

      a[[i]] <- formals(function(...) {
\end_layout

\begin_layout Plain Layout

      })[[1]]
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  names(a) <- nn
\end_layout

\begin_layout Plain Layout

  a <- as.list(a)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # make expression a call, then put it into a function, 
\end_layout

\begin_layout Plain Layout

  # then substitute the function, then evaluate it to make it a real function!
\end_layout

\begin_layout Plain Layout

  ff <- 
\end_layout

\begin_layout Plain Layout

    eval(
\end_layout

\begin_layout Plain Layout

      substitute(
\end_layout

\begin_layout Plain Layout

        function() {
\end_layout

\begin_layout Plain Layout

          tmp <- substitute(body)
\end_layout

\begin_layout Plain Layout

          eval(tmp, parent.frame())
\end_layout

\begin_layout Plain Layout

          }, 
\end_layout

\begin_layout Plain Layout

        list(body = expr) 
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

      )
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  # this is the standard way to change arguments!
\end_layout

\begin_layout Plain Layout

  formals(ff) <- a
\end_layout

\begin_layout Plain Layout

  mm <- match.call()
\end_layout

\begin_layout Plain Layout

  mm$expr <- NULL
\end_layout

\begin_layout Plain Layout

  mm[[1]] <- as.name("macro")
\end_layout

\begin_layout Plain Layout

  attr(ff, "source") <- c(deparse(mm), deparse(expr))
\end_layout

\begin_layout Plain Layout

  ff
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Part
Environments & Namespace
\end_layout

\begin_layout Subsection
identical(x, y).
 Check if two R objects x and y are exactly identical.
\end_layout

\begin_layout Subsection
exists(x)
\end_layout

\begin_layout Standard
Check if an R object exists in the current session.
 Functions and data objects from the base or other packages may also be
 checked.
\end_layout

\begin_layout Standard

\family typewriter
x
\family default
 – The name of an R object as a character string.
\end_layout

\begin_layout Section
Environments: Practice
\end_layout

\begin_layout Subsection
same name: argument name = default argument name 
\change_inserted 16419249 1457976844

\end_layout

\begin_layout Standard

\change_inserted 16419249 1457976856
This is about the error message: promise already under evaluation: recursive
 default argument reference or earlier problems?
\change_unchanged

\end_layout

\begin_layout Standard
"One of the most important things to know about the evaluation of arguments
 to a function is that supplied arguments and default arguments are treated
 differently.
 
\change_inserted 16419249 1457976725

\end_layout

\begin_layout Itemize
The supplied arguments to a function are evaluated in the evaluation frame
 of the calling function.
 
\change_inserted 16419249 1457976736

\end_layout

\begin_layout Itemize
The default arguments to a function are evaluated in the evaluation frame
 of the function."
\end_layout

\begin_layout Standard
the parameter testparams, when no matching argument is passed, is given
 the default value which is the value of the variable testparams looked-up
 
\change_inserted 16419249 1457976812

\end_layout

\begin_layout Itemize
*not* in the environment where foo is defined, 
\change_inserted 16419249 1457976815

\end_layout

\begin_layout Itemize
and *not* in the environment where foo is called, 
\change_inserted 16419249 1457976818

\end_layout

\begin_layout Itemize
but rather in the local environment created when the function is called
 and where parameters are mapped to values -- and in this environment, testparam
s is a parameter, which is already being under evaluation, hence the recursive
 lookup error.
\end_layout

\begin_layout Standard
in some programming languages, testparams (the default value) would come
 from the definition-time environment, so you'd not have problems; in others,
 it's more like in r: 
\change_inserted 16419249 1457976951

\end_layout

\begin_layout Standard
python> x = 1; def foo(x, y=x): return y; foo(2) # 1 
\change_inserted 16419249 1457976974

\end_layout

\begin_layout Standard
ruby> x = 1; def foo(x, y=x); y; end; foo(2) # 2
\end_layout

\begin_layout Standard
you just have to get used to it.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977262

# this error occured when 
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977316

	# when define the function: argument name = default argument name
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977331

	# when call the function, not speicify that argument
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977376

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977376

xxxx = 200
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977376

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977376

g3 <- function(y, xxxx = xxxx){
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977376

  xxxx + y
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977376

}
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977377

g3(y = 1) # 
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977377

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977384

Error in g3(y = 1) :    promise already under evaluation: recursive default
 argument reference or earlier problems?
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977401

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977535

#== no error
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977399

> g3(y = 1,xxxx = 1)
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977399

[1] 2
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977471

\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977536

#== if not the same name, then a different error
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977466

> g4 <- function(y, xxxx = xxdasda){
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977466

+ xxxx + y
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977466

+ }
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977466

> g4(y = 1) #
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977470

# Error in g4(y = 1) : object 'xxdasda' not found
\end_layout

\begin_layout Plain Layout

\change_inserted 16419249 1457977463

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

f <- function(x){
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

  10*sin(0.3*x)*sin(1.3*x^2)+0.001*x^3+0.2*x+80 }
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

g1 <- function(x, f=f){
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

  exp(-f(x)/2) }
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

g1(1)
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

g2 <- function(x, f.=f){
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

  exp(-f.(x)/2) }
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

g2(1)
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

xxxx = 200
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

g3 <- function(y, xxxx = xxxx){
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

  xxxx + y
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

}
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

xxxx = 1
\end_layout

\begin_layout Plain Layout

\change_deleted 16419249 1457977546

g3(y = 1)
\change_unchanged

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Functions that have problem with Environments
\end_layout

\begin_layout Standard

\family typewriter
dfmacro, update(lm/glm), step/stwpwise
\end_layout

\begin_layout Standard
most of them has the problem due to lazy evaluation.
 
\end_layout

\begin_layout Standard
Use those functions really carefully…..
\end_layout

\begin_layout Subsection
:: (double colon) refer an (exported) object from a namespace.
\end_layout

\begin_layout Standard
Use :: when
\end_layout

\begin_layout Itemize
don't want toload the package! 
\end_layout

\begin_layout Itemize
Useful when two packages have overlapping objects.
\end_layout

\begin_deeper
\begin_layout Itemize
When load plyr and then reshape, Note that if we just type rename, R will
 return the value from the reshape package, because that package was loaded
 after the plyr package.
\end_layout

\end_deeper
\begin_layout Standard

\family typewriter
reshape ::rename
\end_layout

\begin_layout Standard

\family typewriter
plyr ::rename
\end_layout

\begin_layout Subsection
::: refer an (non-exported) object from a namespace.
\end_layout

\begin_layout Standard
Some objects are hided in the namespace and the author of namespace doesn’t
 want them to be exposed and seen.
 You can use ::: to refer them.
 ::: can also refer exported objects
\end_layout

\begin_layout Standard
Again No need to load the package!
\end_layout

\begin_layout Standard

\family typewriter
plyr::id_var
\end_layout

\begin_layout Standard

\family typewriter
# Error: 'id_var' is not an exported object from 'namespace:plyr'
\end_layout

\begin_layout Standard

\family typewriter
plyr:::id_var
\end_layout

\begin_layout Standard

\family typewriter
#function (x, drop = FALSE) 
\end_layout

\begin_layout Standard

\family typewriter
#{
\end_layout

\begin_layout Standard

\family typewriter
#……
\end_layout

\begin_layout Standard

\family typewriter
#}
\end_layout

\begin_layout Standard

\family typewriter
#<environment: namespace:plyr>
\end_layout

\begin_layout Subsection
getAnywhere() show where to find the function
\end_layout

\begin_layout Standard

\family typewriter
> getAnywhere("lda")
\end_layout

\begin_layout Standard
A single object matching ‘lda’ was found
\end_layout

\begin_layout Standard
It was found in the following places
\end_layout

\begin_layout Standard

\family typewriter
package:MASS
\end_layout

\begin_layout Standard

\family typewriter
namespace:MASS
\end_layout

\begin_layout Standard

\family typewriter
with value
\end_layout

\begin_layout Standard

\family typewriter
function (x, ...) 
\end_layout

\begin_layout Standard

\family typewriter
UseMethod("lda")
\end_layout

\begin_layout Standard

\family typewriter
<bytecode: 0x103eeca68>
\end_layout

\begin_layout Standard

\family typewriter
<environment: namespace:MASS>
\end_layout

\begin_layout Subsection
Side effect & copy-on-modify rule: 
\end_layout

\begin_layout Standard
R’s function does not and should not have any side effect: local variable
 in function will not affect globally
\end_layout

\begin_layout Standard
EXCEPT: environments and reference classes.
 These can be modified in place, so extra care is needed when working with
 them.)
\end_layout

\begin_layout Subsection
parent.frame(): show the current environment 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

parent.frame()
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
<environment: R_GlobalEnv>
\end_layout

\begin_layout Subsection
where: show which envior the object is in
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

library(pryr) 
\end_layout

\begin_layout Plain Layout

x <- 5 
\end_layout

\begin_layout Plain Layout

where("x") 
\end_layout

\begin_layout Plain Layout

where("mean")
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
with, within: Evaluate an Expression in a Data Environment
\end_layout

\begin_layout Subsection
Never use attach, use with() 
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://rfunction.com/archives/2182
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
with(data, expr, ...)
\end_layout

\begin_layout Standard
The biggest use: no need attach() anymore, any variable in a data.frame can
 be referred without $
\end_layout

\begin_layout Standard
expression can be multiple line using {…}
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

aq <- within(airquality, { # Notice that multiple vars can be changed
\end_layout

\begin_layout Plain Layout

    lOzone <- log(Ozone)
\end_layout

\begin_layout Plain Layout

    Month <- factor(month.abb[Month])
\end_layout

\begin_layout Plain Layout

    cTemp <- round((Temp - 32) * 5/9, 1) # From Fahrenheit to Celsius
\end_layout

\begin_layout Plain Layout

    S.cT <- Solar.R / cTemp # using the newly created variable
\end_layout

\begin_layout Plain Layout

    rm(Day, Temp)
\end_layout

\begin_layout Plain Layout

})
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Section
Environments: Theory
\end_layout

\begin_layout Subsection
new.env(): Create new envir & refer to
\end_layout

\begin_layout Standard
anything you attach (like a loaded library) would be a sub-envir
\end_layout

\begin_layout Standard

\family typewriter
is.str(x) 
\family default
to see objects in envior x
\end_layout

\begin_layout Standard
use $ to refer an object.
\end_layout

\begin_layout Standard
autoloads is used by R to save memory by only loading package objects (like
 big datasets) when needed.
\end_layout

\begin_layout Standard

\family typewriter
e <- new.env() 
\end_layout

\begin_layout Standard

\family typewriter
e$a <- FALSE 
\end_layout

\begin_layout Standard

\family typewriter
e$b <- "a" 
\end_layout

\begin_layout Standard

\family typewriter
e$c <- 2.3 
\end_layout

\begin_layout Standard

\family typewriter
e$d <- 1:3
\end_layout

\begin_layout Subsection
Autoloading
\end_layout

\begin_layout Standard
http://www.inside-r.org/r-doc/base/Autoloads
\end_layout

\begin_layout Standard
Autoloading provides a way of loading packages in the future, only at the
 point at which they are used (if at all).
 So if a function from a package may soon be used, but (for memory reasons,
 perhaps) you don't want to load the package unless absolutely necessary,
 you can use the autoload function to promise to make a function available
 if it is used.
\end_layout

\begin_layout Standard
The Autoloads environment (accessible via as.environment("Autoloads") or
 .AutoloadEnv) stores the functions that it will promise to load and a character
 vector, .Autoloaded, that names the packages that need to be loaded.
\end_layout

\begin_layout Subsection
lexical scoping
\end_layout

\begin_layout Standard
refer word
\end_layout

\begin_layout Subsection
Search Path
\end_layout

\begin_layout Standard
When a package is loaded via library or require, it is automatically attached
 to the search path (typically in position 2).
 
\end_layout

\begin_layout Standard
he first position is reserved for the global environment (i.e., the workspace
 where interactive commands are executed).
 
\end_layout

\begin_layout Standard
When an object (function, data, etc.) is called from the command line, R
 first looks in the global environment, then proceeds up the search path
 until the object is found.
 
\end_layout

\begin_layout Subsection
Environments in function
\end_layout

\begin_layout Itemize
IF function has its own namespace，Then it can have enclosing envior which
 is independent from Global.
 The enclosing environment is the environment where the function was created.
 Every function has one and only one enclosing environment.
 
\end_layout

\begin_layout Itemize
IF function has not namespace（like in global user-defined function） then
 its enclosing envior will be the binding space, which is not independent
 from global.
\end_layout

\begin_layout Itemize
Calling a function creates an ephemeral execution environment that stores
 variables created during execution.
\end_layout

\begin_layout Subsection
Binding & Enclosing environments
\end_layout

\begin_layout Standard
Take the base function sd().
 It’s binding and enclosing environments are different: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

environment(sd) 
\end_layout

\begin_layout Plain Layout

#> <environment: namespace:stats> 
\end_layout

\begin_layout Plain Layout

where("sd") 
\end_layout

\begin_layout Plain Layout

# <environment: package:stats>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The definition of sd() uses var(), but if we make our own version of var()
 it doesn’t affect sd():
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

x <- 1:10
\end_layout

\begin_layout Plain Layout

sd(x) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

var <- function(x, na.rm = TRUE) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sd(x) 
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When we type var into the console, its found first in the global environment.
 When sd() looks for var() it finds it first in its namespace environment,
 so no go further to look into the globalenv().
\end_layout

\begin_layout Standard
• Binding (also called First-Class Environment): The package environment
 contains every publicly accessible function, and is placed on the search
 path.
 Package environment is a subspace of global.
\end_layout

\begin_layout Standard
• Enclosing Through Namespace: The namespace environment contains all functions
 (including internal functions), and its parent environment is a special
 imports environment that contains bindings to all the functions that the
 package needs.
 
\end_layout

\begin_layout Standard
o Namespace is an environment that is entirely independent with Global.
 It is parallel with Global.
 
\end_layout

\begin_layout Standard
• Enclosing through Nested Functions: Some function is created through other
 function。The created function use the creating function as its enclosing
 environment.
 The parent environment of a closure is the execution environment of the
 function that created it, as shown by this code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

# enclosing Example: k’ s enclosing envior is function j
\end_layout

\begin_layout Plain Layout

# .
 It works because k preserves the environment 
\end_layout

\begin_layout Plain Layout

# in which it was defined and because the environment includes the value
 of y.
 
\end_layout

\begin_layout Plain Layout

j <- function(x) {
\end_layout

\begin_layout Plain Layout

y <- 2
\end_layout

\begin_layout Plain Layout

function() {
\end_layout

\begin_layout Plain Layout

c(x, y)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

> k <- j(1)
\end_layout

\begin_layout Plain Layout

> k()
\end_layout

\begin_layout Plain Layout

[1] 1 2
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> 
\end_layout

\begin_layout Plain Layout

> y=1000
\end_layout

\begin_layout Plain Layout

> x=178
\end_layout

\begin_layout Plain Layout

> k()
\end_layout

\begin_layout Plain Layout

[1] 1 2
\end_layout

\begin_layout Plain Layout

> environment(k)
\end_layout

\begin_layout Plain Layout

<environment: 0x7fafa79d0110>
\end_layout

\begin_layout Plain Layout

> where("k")
\end_layout

\begin_layout Plain Layout

<environment: R_GlobalEnv>
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mutable Enclosing
\end_layout

\begin_layout Standard
‘<<-‘ can make values mutable in Enclosing space.
\end_layout

\begin_layout Standard
That means the object you use ‘<<-’ you assign value on is essentially global.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<>>=
\end_layout

\begin_layout Plain Layout

new_counter <- function() {
\end_layout

\begin_layout Plain Layout

i <- 0
\end_layout

\begin_layout Plain Layout

function() {
\end_layout

\begin_layout Plain Layout

i <<- i + 1
\end_layout

\begin_layout Plain Layout

i
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

counter_one <- new_counter()
\end_layout

\begin_layout Plain Layout

counter_two <- new_counter()
\end_layout

\begin_layout Plain Layout

counter_one()
\end_layout

\begin_layout Plain Layout

#> [1] 1
\end_layout

\begin_layout Plain Layout

counter_one()
\end_layout

\begin_layout Plain Layout

#> [1] 2
\end_layout

\begin_layout Plain Layout

counter_two()
\end_layout

\begin_layout Plain Layout

#> [1] 1
\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_body
\end_document
