#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[BoldFont,SlantFont,CJKnumber,fallback]{xeCJK}%使用TexLive自带的xeCJK宏包，并启用加粗、斜体、CJK数字和备用字体选项
\setCJKmainfont{Songti SC}%设置中文衬线字体,若没有该字体,请替换该字符串为系统已有的中文字体,下同
\setCJKsansfont{STXihei}%中文无衬线字体
\setCJKmonofont{SimHei}%中文等宽字体
%中文断行和弹性间距在XeCJK中自动处理了
%\XeTeXlinebreaklocale “zh”%中文断行
%\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt%左右弹性间距
\usepackage{indentfirst}%段落首行缩进

%%%%%%%%%%%
\usepackage{color}
\usepackage{xcolor}
% \definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\usepackage{listings}
\lstset{breaklines}%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题
\lstset{language= R, %用于设置语言为C++
  %背景框
  framexleftmargin=10mm,
  frame=none,
  %背景色
  %backgroundcolor=\color[rgb]{1,1,0.76},
  backgroundcolor=\color[RGB]{245,245,244},
  %样式
  keywordstyle=\bf\color{blue},
  identifierstyle=\bf,
  numberstyle=\color[RGB]{0,192,192},
  commentstyle=\it\color[RGB]{0,96,96},
  stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},
  %显示空格
  showstringspaces=false,
  xleftmargin=2em, %边距
  xrightmargin=2em, 
  aboveskip=1em
}


%%%%%%%%%%%%

\usepackage[multidot]{grffile}
\setlength{\parindent}{2em}%缩进两个字符

\usepackage[BoldFont,SlantFont,CJKnumber,fallback]{xeCJK}%使用TexLive自带的xeCJK宏包，并启用加粗、斜体、CJK数字和备用字体选项
\setCJKmainfont{Songti SC}%设置中文衬线字体,若没有该字体,请替换该字符串为系统已有的中文字体,下同
\setCJKsansfont{STXihei}%中文无衬线字体
\setCJKmonofont{SimHei}%中文等宽字体
%中文断行和弹性间距在XeCJK中自动处理了
%\XeTeXlinebreaklocale “zh”%中文断行
%\XeTeXlinebreakskip = 0pt plus 1pt minus 0.1pt%左右弹性间距
\usepackage{indentfirst}%段落首行缩进

%%%%%%%%%%%
\usepackage{color}
\usepackage{xcolor}
% \definecolor{keywordcolor}{rgb}{0.8,0.1,0.5}
\usepackage{listings}
\lstset{breaklines}%这条命令可以让LaTeX自动将长的代码行换行排版
\lstset{extendedchars=false}%这一条命令可以解决代码跨页时，章节标题，页眉等汉字不显示的问题
\lstset{language= R, %用于设置语言为C++
  %背景框
  framexleftmargin=10mm,
  frame=none,
  %背景色
  %backgroundcolor=\color[rgb]{1,1,0.76},
  backgroundcolor=\color[RGB]{245,245,244},
  %样式
  keywordstyle=\bf\color{blue},
  identifierstyle=\bf,
  numberstyle=\color[RGB]{0,192,192},
  commentstyle=\it\color[RGB]{0,96,96},
  stringstyle=\rmfamily\slshape\color[RGB]{128,0,0},
  %显示空格
  showstringspaces=false,
  xleftmargin=2em, %边距
  xrightmargin=2em, 
  aboveskip=1em
}


%%%%%%%%%%%%

\usepackage[multidot]{grffile}
\setlength{\parindent}{2em}%缩进两个字符
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package auto
\inputencoding utf8-plain
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf4
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 3
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref section
\pdf_pdfusetitle true
\pdf_quoted_options "unicode=false"
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2.5cm
\topmargin 2.5cm
\rightmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes true
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\author -445235034 "yangguodaxia" 
\end_header

\begin_body

\begin_layout Title
Python 1: MOST UPDATED
\end_layout

\begin_layout Author
Fan Yang
\begin_inset Foot
status open

\begin_layout Plain Layout
2014
\end_layout

\end_inset


\end_layout

\begin_layout Standard
http://www.wklken.me/posts/2015/03/03/python-base-datetime.html
\end_layout

\begin_layout Standard
Python for Data Analysis Data Wrangling with Pandas, NumPy, and IPython
 
\end_layout

\begin_layout Standard
In Python, (almost) everything is an object.
 What we commonly refer to as "variables" in Python are more properly called
 names.
 Likewise, "assignment" is really the binding of a name to an object.
 Each binding has a scope that defines its visibility, usually the block
 in which the name originates.
\end_layout

\begin_layout Part
References
\end_layout

\begin_layout Subsection
Books
\end_layout

\begin_layout Itemize
Data Structure and Algorithmic Thinking with Python: Data Structure and
 Algorithmic Puzzles
\end_layout

\begin_layout Itemize
Automate the Boring Stuff with Python: Practical Programming for Total Beginners
\end_layout

\begin_layout Section*
Object types
\end_layout

\begin_layout Itemize
Numbers
\end_layout

\begin_layout Itemize
Strings
\end_layout

\begin_layout Itemize
Lists
\end_layout

\begin_layout Itemize
Dicts
\end_layout

\begin_layout Itemize
Tuples
\end_layout

\begin_layout Itemize
Files
\end_layout

\begin_layout Itemize
Sets
\end_layout

\begin_layout Itemize
Other core types: Booleans, types, None
\end_layout

\begin_layout Itemize
Program unit tyoes: Functions, modules, classes
\end_layout

\begin_layout Itemize
Implementation-related types: Compiled code, stack tracebacks
\end_layout

\begin_layout Part
Date & Time
\end_layout

\begin_layout Subsection
Different Objects
\end_layout

\begin_layout Standard

\series bold
1.
 datetime
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import datetime
\end_layout

\begin_layout Plain Layout

>>> now = datetime.datetime.now()
\end_layout

\begin_layout Plain Layout

>>> now
\end_layout

\begin_layout Plain Layout

datetime.datetime(2015, 1, 12, 23, 9, 12, 946118)
\end_layout

\begin_layout Plain Layout

>>> type(now)
\end_layout

\begin_layout Plain Layout

type 'datetime.datetime'>
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
2.
 timestamp
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import time
\end_layout

\begin_layout Plain Layout

>>> time.time()
\end_layout

\begin_layout Plain Layout

1421075455.568243
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
3.
 time tuple
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import time
\end_layout

\begin_layout Plain Layout

>>> time.localtime()
\end_layout

\begin_layout Plain Layout

time.struct_time(tm_year=2015, tm_mon=1, tm_mday=12, tm_hour=23, tm_min=10,
 tm_sec=30, tm_wday=0, tm_yday=12, tm_isdst=0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
4.
 string
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import datetime
\end_layout

\begin_layout Plain Layout

>>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
\end_layout

\begin_layout Plain Layout

'2015-01-12 23:13:08'
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
5.
 date
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import datetime
\end_layout

\begin_layout Plain Layout

>>> datetime.datetime.now().date()
\end_layout

\begin_layout Plain Layout

datetime.date(2015, 1, 12)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Date
\end_layout

\begin_layout Subsection
today
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> datetime.date.today()
\end_layout

\begin_layout Plain Layout

datetime.date(2015, 1, 12)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
delta of date
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> datetime.date.today() + datetime.timedelta(days=1)
\end_layout

\begin_layout Plain Layout

datetime.date(2015, 1, 13)
\end_layout

\end_inset


\end_layout

\begin_layout Section
timestamp
\end_layout

\begin_layout Standard
5.
 获取两个datetime的时间差
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

(datetime.datetime(2015,1,13,12,0,0) - datetime.datetime.now()).total_seconds()
\end_layout

\begin_layout Plain Layout

44747.768075
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
datetime => string
\end_layout

\begin_layout Subsection
datetime -> string
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import datetime
\end_layout

\begin_layout Plain Layout

>>> datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
\end_layout

\begin_layout Plain Layout

'2015-01-12 23:13:08'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
string -> datetime
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import datetime
\end_layout

\begin_layout Plain Layout

>>> datetime.datetime.strptime("2014-12-31 18:20:10", "%Y-%m-%d %H:%M:%S")
\end_layout

\begin_layout Plain Layout

datetime.datetime(2014, 12, 31, 18, 20, 10)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
datetime => date
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> datetime.datetime.now().date()
\end_layout

\begin_layout Plain Layout

datetime.date(2015, 1, 12)
\end_layout

\end_inset


\end_layout

\begin_layout Part
pandas: refer, index and explore
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

import pandas as pd
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
DataFrame is 2D arrary (see df.values) with index and column as its labels.
\end_layout

\begin_layout Itemize
index is rowname, column is colnames
\end_layout

\begin_layout Section
Create a series
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> s = pd.Series(data, index=index)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, data can be many different things:
\end_layout

\begin_layout Itemize
a Python dict
\end_layout

\begin_layout Itemize
an ndarray (np.arrary)
\end_layout

\begin_layout Itemize
a scalar value (like 5)
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [4]: s = pd.Series([1,3,5,np.nan,6,8])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [5]: s
\end_layout

\begin_layout Plain Layout

Out[5]:
\end_layout

\begin_layout Plain Layout

0    1.0
\end_layout

\begin_layout Plain Layout

1    3.0
\end_layout

\begin_layout Plain Layout

2    5.0
\end_layout

\begin_layout Plain Layout

3    NaN
\end_layout

\begin_layout Plain Layout

4    6.0
\end_layout

\begin_layout Plain Layout

5    8.0
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
with index as label
\end_layout

\begin_layout Standard
# index also must a series.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [45]: s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))
\end_layout

\begin_layout Plain Layout

In [46]: s1
\end_layout

\begin_layout Plain Layout

Out[46]:
\end_layout

\begin_layout Plain Layout

2013-01-02 1
\end_layout

\begin_layout Plain Layout

2013-01-03 2
\end_layout

\begin_layout Plain Layout

2013-01-04 3
\end_layout

\begin_layout Plain Layout

2013-01-05 4
\end_layout

\begin_layout Plain Layout

2013-01-06 5
\end_layout

\begin_layout Plain Layout

2013-01-07 6
\end_layout

\begin_layout Plain Layout

Freq: D, dtype: int64
\end_layout

\begin_layout Plain Layout

In [47]: df['F'] = s1
\end_layout

\end_inset


\end_layout

\begin_layout Section
Create DataFrame
\end_layout

\begin_layout Subsection
create a DataFrame with Index and column
\end_layout

\begin_layout Itemize
when assign a column, not using
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

, use
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
column name not using double quote, use simple 'quote'
\end_layout

\begin_layout Subsection
From
\series bold
one dictionary of Series -- cbind()
\end_layout

\begin_layout Enumerate
each key is the colname
\end_layout

\begin_deeper
\begin_layout Enumerate
each item must a series with the same length (though no need index)
\end_layout

\begin_layout Enumerate
if there are index provided, then pd.DataFrame will align series with their
 index
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# auto alighn by index
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

d = {'one' : pd.Series([ 2., 3.], index=[ 'b', 'c']),
\end_layout

\begin_layout Plain Layout

     'two' : pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pd.DataFrame(d)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[118]:
\end_layout

\begin_layout Plain Layout

   one  two
\end_layout

\begin_layout Plain Layout

a  NaN    1
\end_layout

\begin_layout Plain Layout

b    2    2
\end_layout

\begin_layout Plain Layout

c    3    3
\end_layout

\begin_layout Plain Layout

d  NaN    4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# if one series does not have index
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

d = {'one' : pd.Series([ 2., 3.method 1: From one dictionary of Series]), #
 no index
\end_layout

\begin_layout Plain Layout

     'two' : pd.Series([1., 2., 3., 4.], index=['a', 'b', 'c', 'd'])} # with
 index
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pd.DataFrame(d)     
\end_layout

\begin_layout Plain Layout

Out[117]:
\end_layout

\begin_layout Plain Layout

   one  two
\end_layout

\begin_layout Plain Layout

0    2  NaN
\end_layout

\begin_layout Plain Layout

1    3  NaN
\end_layout

\begin_layout Plain Layout

a  NaN    1
\end_layout

\begin_layout Plain Layout

b  NaN    2
\end_layout

\begin_layout Plain Layout

c  NaN    3
\end_layout

\begin_layout Plain Layout

d  NaN    4
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
From
\series bold
one dictionary of list -- cbind()
\end_layout

\begin_layout Enumerate
each key is the colname.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

d = {'one' : [1., 2., 3., 4.],
\end_layout

\begin_layout Plain Layout

     'two' : [4., 3., 2., 1.]}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pd.DataFrame(d)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[123]: In [124]:
\end_layout

\begin_layout Plain Layout

   one  two
\end_layout

\begin_layout Plain Layout

0    1    4
\end_layout

\begin_layout Plain Layout

1    2    3
\end_layout

\begin_layout Plain Layout

2    3    2
\end_layout

\begin_layout Plain Layout

3    4    1
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
From
\series bold
one list of dicts -- rbind()
\end_layout

\begin_layout Enumerate
each dictionary is a row!
\end_layout

\begin_deeper
\begin_layout Enumerate
dictionaris' keys are colname
\end_layout

\begin_layout Enumerate
DataFrame align each dic using their keys
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

data2 = [{'a': 1, 'b': 2},
\end_layout

\begin_layout Plain Layout

         {'a': 5, 'b': 10, 'c': 20}]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pd.DataFrame(data2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[125]:
\end_layout

\begin_layout Plain Layout

   a   b   c
\end_layout

\begin_layout Plain Layout

0  1   2 NaN
\end_layout

\begin_layout Plain Layout

1  5  10  20
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
From one dictionary
\end_layout

\begin_layout Itemize
wrong way with error
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

pd.DataFrame.from_dict({'a': 1, 'b': 2})
\end_layout

\begin_layout Plain Layout

pd.DataFrame({'a': 1, 'b': 2})
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
correct way
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# key as index
\end_layout

\begin_layout Plain Layout

pd.DataFrame.from_dict({'a': 1, 'b': 2},orient = 'index')
\end_layout

\begin_layout Plain Layout

Out[130]:
\end_layout

\begin_layout Plain Layout

   0
\end_layout

\begin_layout Plain Layout

a  1
\end_layout

\begin_layout Plain Layout

b  2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# key as column
\end_layout

\begin_layout Plain Layout

pd.DataFrame({'a': 1, 'b': 2},index = [0])
\end_layout

\begin_layout Plain Layout

Out[131]:
\end_layout

\begin_layout Plain Layout

   a  b
\end_layout

\begin_layout Plain Layout

0  1  2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
index and colname arguement
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [45]: data2 = [{'a': 1, 'b': 2}, {'a': 5, 'b': 10, 'c': 20}]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [46]: pd.DataFrame(data2)
\end_layout

\begin_layout Plain Layout

Out[46]:
\end_layout

\begin_layout Plain Layout

   a   b   c
\end_layout

\begin_layout Plain Layout

0  1   2 NaN
\end_layout

\begin_layout Plain Layout

1  5  10  20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [47]: pd.DataFrame(data2, index=['first', 'second'])
\end_layout

\begin_layout Plain Layout

Out[47]:
\end_layout

\begin_layout Plain Layout

        a   b   c
\end_layout

\begin_layout Plain Layout

first   1   2 NaN
\end_layout

\begin_layout Plain Layout

second  5  10  20
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [48]: pd.DataFrame(data2, columns=['a', 'b'])
\end_layout

\begin_layout Plain Layout

Out[48]:
\end_layout

\begin_layout Plain Layout

   a   b
\end_layout

\begin_layout Plain Layout

0  1   2
\end_layout

\begin_layout Plain Layout

1  5  10
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
adding a new col
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

df2['E'] = ['one', 'one','two','three','four','three']
\end_layout

\begin_layout Plain Layout

df2.loc[:,'return'] = 1
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
assign a dict to a row of a DataFrame:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [23]: x = pd.DataFrame({'x': [1, 2, 3], 'y': [3, 4, 5]})
\end_layout

\begin_layout Plain Layout

In [24]: x.iloc[1] = dict(x=9, y=99)
\end_layout

\begin_layout Plain Layout

In [25]: x
\end_layout

\begin_layout Plain Layout

Out[25]:
\end_layout

\begin_layout Plain Layout

x y
\end_layout

\begin_layout Plain Layout

0 1 3
\end_layout

\begin_layout Plain Layout

1 9 99
\end_layout

\begin_layout Plain Layout

2 3 5
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
copy explictly, not view
\end_layout

\begin_layout Standard

\family typewriter
df2 = df.copy()
\end_layout

\begin_layout Section
Refer
\end_layout

\begin_layout Itemize
use
\family typewriter
df.loc
\family default
 to specify by label specificly:
\family typewriter
df.loc['20130102':'20130104',['A','B']]
\end_layout

\begin_layout Itemize
use
\family typewriter
df.iloc
\family default
 to specify by location specificly:
\family typewriter
df.iloc[3:5,0:2], df.iloc[[1,2,4],[0,2]]
\end_layout

\begin_layout Subsection
direct slicing with Series
\end_layout

\begin_layout Itemize
single value is to refer a name of series:
\family typewriter
series[name]
\family default
.
 An integer to refere location cannot work here, Python will only think
 integer as you are refering to label.
\end_layout

\begin_deeper
\begin_layout Itemize
As series can be created from dict, it has dict features: access by label
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df3 = pd.DataFrame({'A': ['A8', 'A9', 'A10', 'A11'],
\end_layout

\begin_layout Plain Layout

                     'B': ['B8', 'B9', 'B10', 'B11'],
\end_layout

\begin_layout Plain Layout

                     'C': ['C8', 'C9', 'C10', 'C11'],
\end_layout

\begin_layout Plain Layout

                     'D': ['D8', 'D9', 'D10', 'D11']},
\end_layout

\begin_layout Plain Layout

                     index=[8, 9, 10, 11])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df3["A"][8] # Python will think 8 as label name
\end_layout

\begin_layout Plain Layout

# Out[97]: 'A8'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df3["A"].8 # ERROR
\end_layout

\begin_layout Plain Layout

df3["A"]["8"] # Error, as index name is integer, not character
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df3["A"][0]  # error, as there is no index name as 0
\end_layout

\begin_layout Plain Layout

# KeyError: 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df3["A"][0:] # works, as it refers all labels with name after 0, it doesn't
 mean it refers a location
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[100]:
\end_layout

\begin_layout Plain Layout

8      A8
\end_layout

\begin_layout Plain Layout

9      A9
\end_layout

\begin_layout Plain Layout

10    A10
\end_layout

\begin_layout Plain Layout

11    A11
\end_layout

\begin_layout Plain Layout

Name: A, dtype: object
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
As series can be created from arrary, it has arrary features: access by
 position, but only range of position
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

dates = pd.date_range('1/1/2000', periods=8)
\end_layout

\begin_layout Plain Layout

df = pd.DataFrame(np.random.randn(8, 4), index=dates, columns=['A', 'B', 'C',
 'D'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s = df['A']
\end_layout

\begin_layout Plain Layout

s[1] # wrong
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s[1:10] # correct
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
a single value is to refer label
\end_layout

\begin_layout Itemize
It supports
\family typewriter
s[start:end:jump]
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [27]: s[::2]
\end_layout

\begin_layout Plain Layout

Out[27]:
\end_layout

\begin_layout Plain Layout

2000-01-01   -0.282863
\end_layout

\begin_layout Plain Layout

2000-01-03   -2.104569
\end_layout

\begin_layout Plain Layout

2000-01-05    0.567020
\end_layout

\begin_layout Plain Layout

2000-01-07    0.577046
\end_layout

\begin_layout Plain Layout

Freq: 2D, Name: A, dtype: float64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [28]: s[::-1]
\end_layout

\begin_layout Plain Layout

Out[28]:
\end_layout

\begin_layout Plain Layout

2000-01-08   -1.157892
\end_layout

\begin_layout Plain Layout

2000-01-07    0.577046
\end_layout

\begin_layout Plain Layout

2000-01-06    0.113648
\end_layout

\begin_layout Plain Layout

2000-01-05    0.567020
\end_layout

\begin_layout Plain Layout

2000-01-04   -0.706771
\end_layout

\begin_layout Plain Layout

2000-01-03   -2.104569
\end_layout

\begin_layout Plain Layout

2000-01-02   -0.173215
\end_layout

\begin_layout Plain Layout

2000-01-01   -0.282863
\end_layout

\begin_layout Plain Layout

Freq: -1D, Name: A, dtype: float64
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
direct slicing DataFrame
\end_layout

\begin_layout Itemize
single value direct access []: is to refer a colnam
\family typewriter
 
\family default
for
\family typewriter
 df[colname]
\family default
, or
\family typewriter
label
\family default
 for
\family typewriter
Series
\family default
.
 An integer to refer location cannot work here.
\end_layout

\begin_layout Itemize
series is to refer by rows:
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
df[rowposition1 : rowposition2]
\end_layout

\begin_layout Itemize

\family typewriter
df[row name 1 : row name 2]
\end_layout

\begin_layout Itemize

\family typewriter
df[boolean_arrary/Series] for rows
\end_layout

\begin_layout Itemize

\family typewriter
df[:]
\family default
 is for all rows
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

df1 = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'],
\end_layout

\begin_layout Plain Layout

                    'B': ['B0', 'B1', 'B2', 'B3'],
\end_layout

\begin_layout Plain Layout

                    'C': ['C0', 'C1', 'C2', 'C3'],
\end_layout

\begin_layout Plain Layout

                    'D': ['D0', 'D1', 'D2', 'D3']},
\end_layout

\begin_layout Plain Layout

                    index=[0, 1, 2, 3])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1['A'] # works, refer to a colname
\end_layout

\begin_layout Plain Layout

df1[1] # does not work to refer a ro/col position
\end_layout

\begin_layout Plain Layout

df1[1:] # works to refer a range of rows
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

df[3] # ERROR, no colname == 3
\end_layout

\begin_layout Plain Layout

df[3:] # works, select row position 3 afterwards
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
direct slicing with list and bool_list
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

df1[['A','B']]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[455]:
\end_layout

\begin_layout Plain Layout

    A   B
\end_layout

\begin_layout Plain Layout

0  A0  B0
\end_layout

\begin_layout Plain Layout

1  A1  B1
\end_layout

\begin_layout Plain Layout

2  A2  B2
\end_layout

\begin_layout Plain Layout

3  A3  B3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1[[True,False, True, False]]
\end_layout

\begin_layout Plain Layout

Out[456]:
\end_layout

\begin_layout Plain Layout

    A   B   C   D
\end_layout

\begin_layout Plain Layout

0  A0  B0  C0  D0
\end_layout

\begin_layout Plain Layout

2  A2  B2  C2  D2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
loc: label based: work with list and bool_list
\end_layout

\begin_layout Standard
pandas provides a suite of methods in order to have purely label based indexing.
 This is a strict inclusion based protocol.
 At least 1 of the labels for which you ask, must be in the index or a KeyError
 will be raised!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

df1 = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'],
\end_layout

\begin_layout Plain Layout

                    'B': ['B0', 'B1', 'B2', 'B3'],
\end_layout

\begin_layout Plain Layout

                    'C': ['C0', 'C1', 'C2', 'C3'],
\end_layout

\begin_layout Plain Layout

                    'D': ['D0', 'D1', 'D2', 'D3']},
\end_layout

\begin_layout Plain Layout

                    index=[0, 1, 2, 3])
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
A single label, e.g.
 
\family typewriter
5
\family default
 or
\family typewriter
'a'
\family default
, (note that 5 is interpreted as a label of the index.
 This use is not an integer position along the index)
\end_layout

\begin_layout Itemize
A list or array of labels
\family typewriter
 ['a', 'b', 'c']
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1.loc[:,['A','B']]
\end_layout

\begin_layout Plain Layout

Out[448]:
\end_layout

\begin_layout Plain Layout

    A   B
\end_layout

\begin_layout Plain Layout

0  A0  B0
\end_layout

\begin_layout Plain Layout

1  A1  B1
\end_layout

\begin_layout Plain Layout

2  A2  B2
\end_layout

\begin_layout Plain Layout

3  A3  B3
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
A slice object with labels
\family typewriter
 ['a':'f']
\family default
or
\family typewriter
['a':]
\family default
 
\series bold
(note that contrary to usual python slices, both the start and the stop
 are included!)
\end_layout

\begin_layout Itemize
A boolean array/Series
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

df1.loc[:,[True,False, True, False]]
\end_layout

\begin_layout Plain Layout

Out[449]:
\end_layout

\begin_layout Plain Layout

    A   C
\end_layout

\begin_layout Plain Layout

0  A0  C0
\end_layout

\begin_layout Plain Layout

1  A1  C1
\end_layout

\begin_layout Plain Layout

2  A2  C2
\end_layout

\begin_layout Plain Layout

3  A3  C3
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
iloc: position based slicing, worked with List and Bool_List
\end_layout

\begin_layout Standard
pandas provides a suite of methods in order to get purely integer based
 indexing.
 Trying to use a non-integer, even a valid label will raise a IndexError.
 
\end_layout

\begin_layout Standard
The semantics follow closely python and numpy slicing.
 
\end_layout

\begin_layout Enumerate
These are position-based indexing.
 
\end_layout

\begin_layout Enumerate
When slicing, the start bounds is included, while the upper bound is excluded.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

df1.iloc[:,[True,False, True, False]]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[452]:
\end_layout

\begin_layout Plain Layout

    A   C
\end_layout

\begin_layout Plain Layout

0  A0  C0
\end_layout

\begin_layout Plain Layout

1  A1  C1
\end_layout

\begin_layout Plain Layout

2  A2  C2
\end_layout

\begin_layout Plain Layout

3  A3  C3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1.iloc[:,[1,2]]
\end_layout

\begin_layout Plain Layout

Out[453]:
\end_layout

\begin_layout Plain Layout

    B   C
\end_layout

\begin_layout Plain Layout

0  B0  C0
\end_layout

\begin_layout Plain Layout

1  B1  C1
\end_layout

\begin_layout Plain Layout

2  B2  C2
\end_layout

\begin_layout Plain Layout

3  B3  C3
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Out of range slice
\end_layout

\begin_layout Standard
Out of range slice indexes are handled gracefully just as in Python/Numpy.
\end_layout

\begin_layout Itemize
a range of slicer with : will return empty series/DataFrame if out of boundary
\end_layout

\begin_layout Itemize
A single indexer that is out of bounds will raise an IndexError.
 
\end_layout

\begin_layout Itemize
A list of indexers where any element is out of bounds will raise an IndexError
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# these are allowed in python/numpy.
\end_layout

\begin_layout Plain Layout

# Only works in Pandas starting from v0.14.0.
\end_layout

\begin_layout Plain Layout

In [66]: x = list('abcdef')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [67]: x
\end_layout

\begin_layout Plain Layout

Out[67]: ['a', 'b', 'c', 'd', 'e', 'f']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [68]: x[4:10]
\end_layout

\begin_layout Plain Layout

Out[68]: ['e', 'f']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [69]: x[8:10]
\end_layout

\begin_layout Plain Layout

Out[69]: []
\end_layout

\begin_layout Plain Layout

# Note that this could result in an empty axis (e.g.
 an empty DataFrame being returned)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

dfl = pd.DataFrame(np.random.randn(5,2), columns=list('AB'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [76]: dfl.iloc[:,2:3]
\end_layout

\begin_layout Plain Layout

Out[76]:
\end_layout

\begin_layout Plain Layout

Empty DataFrame
\end_layout

\begin_layout Plain Layout

Columns: []
\end_layout

\begin_layout Plain Layout

Index: [0, 1, 2, 3, 4]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfl.iloc[[4,5,6]]
\end_layout

\begin_layout Plain Layout

IndexError: positional indexers are out-of-bounds
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dfl.iloc[:,4]
\end_layout

\begin_layout Plain Layout

IndexError: single positional indexer is out-of-bounds
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Setting With Enlargement
\end_layout

\begin_layout Standard
The
\family typewriter
.loc / .ix / []
\family default
(no
\family typewriter
iloc
\family default
) operations can perform enlargement when setting a non-existant key for
 that axis.
\end_layout

\begin_layout Itemize
In the Series case this is effectively an appending operation
\end_layout

\begin_layout Itemize
A DataFrame can be enlarged on either axis via .loc
\end_layout

\begin_layout Subsection
Fast scalar value getting and setting
\end_layout

\begin_layout Standard
Since indexing with [] must handle a lot of cases (single-label access,
 slicing, boolean indexing, etc.), it has a bit of overhead in order to figure
 out what you’re asking for.
 If you only want to access a scalar value, the fastest way is to use the
 at and iat methods, which are implemented on all of the data structures.
\end_layout

\begin_layout Standard

\family typewriter
at
\family default
 and
\family typewriter
iat
\family default
have the exact similar use as
\family typewriter
 loc and iloc
\family default
, the only difference is they strictly only refer a scaler; if you give
 a range, then error raises.
\end_layout

\begin_layout Subsection
boolean access
\end_layout

\begin_layout Itemize
direct access
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

df1 = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'],
\end_layout

\begin_layout Plain Layout

                    'B': ['B0', 'B1', 'B2', 'B3'],
\end_layout

\begin_layout Plain Layout

                    'C': ['C0', 'C1', 'C2', 'C3'],
\end_layout

\begin_layout Plain Layout

                    'D': ['D0', 'D1', 'D2', 'D3']},
\end_layout

\begin_layout Plain Layout

                    index=[0, 1, 2, 3])
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1[pd.Series([True,True,False,False])]  # works with a pd.Series
\end_layout

\begin_layout Plain Layout

df1[([True,True,False,False])] # works with a np.array
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
loc
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1 = pd.DataFrame({'A': ['A0', 'A1', 'A2', 'A3'],
\end_layout

\begin_layout Plain Layout

                    'B': ['B0', 'B1', 'B2', 'B3'],
\end_layout

\begin_layout Plain Layout

                    'C': ['C0', 'C1', 'C2', 'C3'],
\end_layout

\begin_layout Plain Layout

                    'D': ['D0', 'D1', 'D2', 'D3']},
\end_layout

\begin_layout Plain Layout

                    index=[0, 1, 2, 3])
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1.loc[pd.Series([True,True,False,False])]  # works with a pd.Series
\change_inserted -445235034 1463882122
 # work with loc
\change_unchanged

\end_layout

\begin_layout Plain Layout

df1.loc[([True,True,False,False])] # works with a np.array
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1.loc[(True,True,False,False)] # error
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
iloc
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

df1.iloc[pd.Series([True,True,False,False])]  # ERROR: dows not work 
\change_deleted -445235034 1463882116
with a pd.Series
\change_inserted -445235034 1463882117
in iloc
\change_unchanged

\end_layout

\begin_layout Plain Layout

df1.iloc[([True,True,False,False])] # works with a np.array
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
When use,
\family typewriter
|
\family default
 for or,
\family typewriter
&
\family default
 for and, and
\family typewriter
~
\family default
 for not.
 These must be grouped by using parentheses.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

s[(s -1) | (s > 0.5)] # WORKS CORRECTLY
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s[s -1 | s > 0.5]  # ERROR
\end_layout

\begin_layout Plain Layout

s[(s -1) | s > 0.5] # WRONG RESULT # will return the whole s
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
attribute like access
\end_layout

\begin_layout Itemize
attribute like access: You may access an
\family typewriter
index
\family default
 on a
\family typewriter
Series
\family default
,
\family typewriter
colname
\family default
 on a
\family typewriter
DataFrame
\family default
, and a
\family typewriter
item
\family default
 on a
\family typewriter
Panel
\family default
 directly as an
\family typewriter
attribute
\family default
.
\end_layout

\begin_deeper
\begin_layout Itemize

\family typewriter
df.A
\end_layout

\end_deeper
\begin_layout Itemize
You can use attribute access to modify an existing element of a Series or
 column of a DataFrame, but be careful; if you try to use attribute access
 to create a new column, it fails silently, creating a new attribute rather
 than a new column.
\end_layout

\begin_layout Itemize
You can use this access only if the index element is a valid python identifier,
 e.g.
 
\family typewriter
s.1
\family default
 is not allowed.
\end_layout

\begin_layout Itemize
The attribute will not be available if it conflicts with an existing method
 name, e.g.
 
\family typewriter
s.min
\family default
is not allowed.
 
\end_layout

\begin_layout Subsection
pd.where: subset with full dimention
\end_layout

\begin_layout Standard
Selecting values from a Series with a boolean vector generally returns a
 subset of the data.
 To guarantee that selection output has the same shape as the original data,
 you can use the where method in Series and DataFrame.
\end_layout

\begin_layout Itemize
By default, where returns a modified copy of the data.
 There is an optional parameter
\family typewriter
inplace=True
\family default
 so that the original data can be modified without creating a copy:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [145]: s[s > 0]
\end_layout

\begin_layout Plain Layout

Out[145]:
\end_layout

\begin_layout Plain Layout

3    1
\end_layout

\begin_layout Plain Layout

2    2
\end_layout

\begin_layout Plain Layout

1    3
\end_layout

\begin_layout Plain Layout

0    4
\end_layout

\begin_layout Plain Layout

dtype: int64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [146]: s.where(s > 0)
\end_layout

\begin_layout Plain Layout

Out[146]:
\end_layout

\begin_layout Plain Layout

4   NaN
\end_layout

\begin_layout Plain Layout

3     1
\end_layout

\begin_layout Plain Layout

2     2
\end_layout

\begin_layout Plain Layout

1     3
\end_layout

\begin_layout Plain Layout

0     4
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Selecting values from a DataFrame with a boolean criterion now also preserves
 input data shape.
 where is used under the hood as the implementation.
 Equivalent is df.where(df 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [147]: df[df < 0]
\end_layout

\begin_layout Plain Layout

Out[147]:
\end_layout

\begin_layout Plain Layout

                   A         B         C         D
\end_layout

\begin_layout Plain Layout

2000-01-01       NaN       NaN -0.863838       NaN
\end_layout

\begin_layout Plain Layout

2000-01-02 -1.048089 -0.025747 -0.988387       NaN
\end_layout

\begin_layout Plain Layout

2000-01-03       NaN       NaN       NaN -0.055758
\end_layout

\begin_layout Plain Layout

2000-01-04       NaN -0.489682       NaN -0.034571
\end_layout

\begin_layout Plain Layout

2000-01-05 -2.484478 -0.281461       NaN       NaN
\end_layout

\begin_layout Plain Layout

2000-01-06       NaN -0.977349       NaN -0.064034
\end_layout

\begin_layout Plain Layout

2000-01-07 -1.282782       NaN -1.071357       NaN
\end_layout

\begin_layout Plain Layout

2000-01-08       NaN       NaN       NaN -0.744471
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
mask: inverse of where
\end_layout

\begin_layout Standard
mask is the inverse boolean operation of where.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

s.mask(s >= 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[127]:
\end_layout

\begin_layout Plain Layout

2000-01-01         NaN
\end_layout

\begin_layout Plain Layout

2000-01-02   -1.438443
\end_layout

\begin_layout Plain Layout

2000-01-03   -1.035434
\end_layout

\begin_layout Plain Layout

2000-01-04         NaN
\end_layout

\begin_layout Plain Layout

2000-01-05   -1.565350
\end_layout

\begin_layout Plain Layout

2000-01-06   -0.010291
\end_layout

\begin_layout Plain Layout

2000-01-07         NaN
\end_layout

\begin_layout Plain Layout

2000-01-08         NaN
\end_layout

\begin_layout Plain Layout

Freq: D, Name: A, dtype: float64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s.where(s >= 0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[128]:
\end_layout

\begin_layout Plain Layout

2000-01-01    0.820513
\end_layout

\begin_layout Plain Layout

2000-01-02         NaN
\end_layout

\begin_layout Plain Layout

2000-01-03         NaN
\end_layout

\begin_layout Plain Layout

2000-01-04    0.184524
\end_layout

\begin_layout Plain Layout

2000-01-05         NaN
\end_layout

\begin_layout Plain Layout

2000-01-06         NaN
\end_layout

\begin_layout Plain Layout

2000-01-07    1.098897
\end_layout

\begin_layout Plain Layout

2000-01-08    0.862552
\end_layout

\begin_layout Plain Layout

Freq: D, Name: A, dtype: float64
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
pd.lookup(rowlabel, columnlabel) : find values corresponding to rowlabels
 and columnlabels
\end_layout

\begin_layout Standard
Sometimes you want to extract a set of values given a sequence of row labels
 and column labels, and the lookup method allows for this and returns a
 numpy array.
 For instance,
\end_layout

\begin_layout Itemize
the row labels and column labels must have the same length!
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [253]: dflookup = pd.DataFrame(np.random.rand(20,4), columns = ['A','B','C','D']
)
\end_layout

\begin_layout Plain Layout

In [254]: dflookup.lookup(list(range(0,10,2)), ['B','C','A','B','D'])
\end_layout

\begin_layout Plain Layout

Out[254]: array([ 0.9242, 0.3338, 0.7562, 0.6023, 0.7212])
\end_layout

\end_inset


\end_layout

\begin_layout Section
Index
\end_layout

\begin_layout Standard
The pandas Index class and its subclasses can be viewed as implementing
 an ordered multiset.
 Duplicates are allowed.
 However, if you try to convert an Index object with duplicate entries into
 a set, an exception will be raised.
\end_layout

\begin_layout Standard
Index also provides the infrastructure necessary for lookups, data alignment,
 and reindexing.
 
\end_layout

\begin_layout Subsection
index is a list
\end_layout

\begin_layout Itemize
To create a data.frame with index, you have to provide a list
\end_layout

\begin_deeper
\begin_layout Itemize
even for a single row DF, a single value as index is wrong
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

pd.DataFrame(dict_china, index = [0]) # OK
\end_layout

\begin_layout Plain Layout

Out[106]:
\end_layout

\begin_layout Plain Layout

   AMCN  BONA   CO  DANG  DATE    EJ  HMIN  JASO  JMEI  KANG  ...
   MOMO  MR  
\backslash

\end_layout

\begin_layout Plain Layout

0     6  13.7  6.4  7.81   7.2  7.38  35.8  9.69     7    25  ...
   18.9  28   
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   QIHU  RENN  SVA  SYT  VNET  XUE  YOKU    YY  
\end_layout

\begin_layout Plain Layout

0    77   4.2    7   94    23  5.5    27  68.5  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

pd.DataFrame(dict_china, index = 0)
\end_layout

\begin_layout Plain Layout

TypeError: Index(...) must be called with a collection of some kind, 0 was
 passed
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
index can have a name attribute
\end_layout

\begin_layout Subsection
The Index class
\end_layout

\begin_layout Standard
The easiest way to create an Index directly is to pass a list or other sequence
 to Inde.
\end_layout

\begin_layout Standard

\series bold
So Index is essentially a special list.
 All list opreations applies here
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [255]: index = pd.Index(['e', 'd', 'a', 'b'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [256]: index
\end_layout

\begin_layout Plain Layout

Out[256]: Index([u'e', u'd', u'a', u'b'], dtype='object')
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Set Index: make a column data into index
\end_layout

\begin_layout Standard
DataFrame has a set_index method which takes a column name (for a regular
 Index) or a list of column names (for a MultiIndex), to create a new, indexed
 DataFrame:
\end_layout

\begin_layout Itemize
drop=False, not drop the column, default is T
\end_layout

\begin_layout Itemize
The append keyword option allow you to keep the existing index and append
 the given columns to a MultiIndex.
 
\family typewriter
append=True
\family default
will not overwrite the existing index, default is F.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [290]: data
\end_layout

\begin_layout Plain Layout

Out[290]:
\end_layout

\begin_layout Plain Layout

a b c d
\end_layout

\begin_layout Plain Layout

0 bar one z 1
\end_layout

\begin_layout Plain Layout

1 bar two y 2
\end_layout

\begin_layout Plain Layout

2 foo one x 3
\end_layout

\begin_layout Plain Layout

3 foo two w 4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [291]: indexed1 = data.set_index('c')
\end_layout

\begin_layout Plain Layout

In [292]: indexed1
\end_layout

\begin_layout Plain Layout

Out[292]:
\end_layout

\begin_layout Plain Layout

a b d
\end_layout

\begin_layout Plain Layout

c
\end_layout

\begin_layout Plain Layout

z bar one 1
\end_layout

\begin_layout Plain Layout

y bar two 2
\end_layout

\begin_layout Plain Layout

x foo one 3
\end_layout

\begin_layout Plain Layout

w foo two 4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [293]: indexed2 = data.set_index(['a', 'b'])
\end_layout

\begin_layout Plain Layout

In [294]: indexed2
\end_layout

\begin_layout Plain Layout

Out[294]:
\end_layout

\begin_layout Plain Layout

c d
\end_layout

\begin_layout Plain Layout

a b
\end_layout

\begin_layout Plain Layout

bar one z 1
\end_layout

\begin_layout Plain Layout

two y 2
\end_layout

\begin_layout Plain Layout

foo one x 3
\end_layout

\begin_layout Plain Layout

two w 4
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
df.index = Anyindex # easist way to sho and rename index
\end_layout

\begin_layout Subsection
reset_index: sets a simple integer index.
 
\end_layout

\begin_layout Standard
This is the inverse operation to set_index
\end_layout

\begin_layout Itemize
for pd.DataFrame, will
\end_layout

\begin_deeper
\begin_layout Enumerate
create a new inex column with the old index
\end_layout

\begin_layout Enumerate
create a new index with simple range(0, len(data))
\end_layout

\end_deeper
\begin_layout Enumerate
For pd.Series, will
\end_layout

\begin_deeper
\begin_layout Enumerate
transform the Series toa new DataFrame.
\end_layout

\begin_layout Enumerate
create a new inex column with the old index, and then create a new index
 with simple range(0, len(data)).
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

index = ['Firefox', 'Chrome', 'Safari', 'IE10', 'Konqueror']
\end_layout

\begin_layout Plain Layout

df = pd.DataFrame({
\end_layout

\begin_layout Plain Layout

 'http_status': [200,200,404,404,301],
\end_layout

\begin_layout Plain Layout

 'response_time': [0.04, 0.02, 0.07, 0.08, 1.0]},
\end_layout

\begin_layout Plain Layout

  index=index)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df
\end_layout

\begin_layout Plain Layout

Out[127]:
\end_layout

\begin_layout Plain Layout

       index  http_status  response_time
\end_layout

\begin_layout Plain Layout

0    Firefox          200           0.04
\end_layout

\begin_layout Plain Layout

1     Chrome          200           0.02
\end_layout

\begin_layout Plain Layout

2     Safari          404           0.07
\end_layout

\begin_layout Plain Layout

3       IE10          404           0.08
\end_layout

\begin_layout Plain Layout

4  Konqueror          301           1.00
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df.reset_index()
\end_layout

\begin_layout Plain Layout

Out[128]:
\end_layout

\begin_layout Plain Layout

       index  http_status  response_time
\end_layout

\begin_layout Plain Layout

0    Firefox          200           0.04
\end_layout

\begin_layout Plain Layout

1     Chrome          200           0.02
\end_layout

\begin_layout Plain Layout

2     Safari          404           0.07
\end_layout

\begin_layout Plain Layout

3       IE10          404           0.08
\end_layout

\begin_layout Plain Layout

4  Konqueror          301           1.00
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.reindex(): index / colname : rename index or column
\end_layout

\begin_layout Itemize
reindex: reset index using provided list, for both index and colname
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [168]: df
\end_layout

\begin_layout Plain Layout

Out[168]:
\end_layout

\begin_layout Plain Layout

        one     three       two
\end_layout

\begin_layout Plain Layout

a -0.626544       NaN -0.351587
\end_layout

\begin_layout Plain Layout

b -0.138894 -0.177289  1.136249
\end_layout

\begin_layout Plain Layout

c  0.011617  0.462215 -0.448789
\end_layout

\begin_layout Plain Layout

d       NaN  1.124472 -1.101558
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [169]: df.reindex(index=['c', 'f', 'b'], columns=['three', 'two', 'one'])
\end_layout

\begin_layout Plain Layout

Out[169]:
\end_layout

\begin_layout Plain Layout

      three       two       one
\end_layout

\begin_layout Plain Layout

c  0.462215 -0.448789  0.011617
\end_layout

\begin_layout Plain Layout

f       NaN       NaN       NaN
\end_layout

\begin_layout Plain Layout

b -0.177289  1.136249 -0.138894
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A.reindex_like(B): re-structure A with the columns and indexes of B
\end_layout

\begin_layout Standard
If A is smaller than B, then expand to B's structure A, if A is bigger 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[195]: df1 = pd.DataFrame(np.random.randn(1, 1), columns=['A'], dtype='float32')
\end_layout

\begin_layout Plain Layout

df2 = pd.DataFrame(dict( A = pd.Series(np.random.randn(2), dtype='float16'),
\end_layout

\begin_layout Plain Layout

                         B = pd.Series(np.random.randn(2)),
\end_layout

\begin_layout Plain Layout

                         C = pd.Series(np.array(np.random.randn(2), dtype='uint8'))
\end_layout

\begin_layout Plain Layout

                         ))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1
\end_layout

\begin_layout Plain Layout

Out[199]: 
\end_layout

\begin_layout Plain Layout

          A
\end_layout

\begin_layout Plain Layout

0  1.250817
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df1.reindex_like(df2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[195]: 
\end_layout

\begin_layout Plain Layout

          A   B   C
\end_layout

\begin_layout Plain Layout

0 -0.389403 NaN NaN
\end_layout

\begin_layout Plain Layout

1       NaN NaN NaN
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[196]: df1 = pd.DataFrame(np.random.randn(3, 1), columns=['A'], dtype='float32')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[197]: df1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[197]: 
\end_layout

\begin_layout Plain Layout

          A
\end_layout

\begin_layout Plain Layout

0 -0.395821
\end_layout

\begin_layout Plain Layout

1 -0.056378
\end_layout

\begin_layout Plain Layout

2  0.578729
\end_layout

\begin_layout Plain Layout

In[198]: df1.reindex_like(df2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[198]: 
\end_layout

\begin_layout Plain Layout

          A   B   C
\end_layout

\begin_layout Plain Layout

0 -0.395821 NaN NaN
\end_layout

\begin_layout Plain Layout

1 -0.056378 NaN NaN
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Columns
\end_layout

\begin_layout Subsection
colname/ rowname :: df.columns, df.index,
\end_layout

\begin_layout Subsection
multiple columns
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> import pandas as pd
\end_layout

\begin_layout Plain Layout

>>> df = pd.DataFrame({'A': {0: 'a', 1: 'b', 2: 'c'},
\end_layout

\begin_layout Plain Layout

...
                    'B': {0: 1, 1: 3, 2: 5},
\end_layout

\begin_layout Plain Layout

...
                    'C': {0: 2, 1: 4, 2: 6}})
\end_layout

\begin_layout Plain Layout

>>> df
\end_layout

\begin_layout Plain Layout

   A  B  C
\end_layout

\begin_layout Plain Layout

0  a  1  2
\end_layout

\begin_layout Plain Layout

1  b  3  4
\end_layout

\begin_layout Plain Layout

2  c  5  6
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> df.columns = [list('ABC'), list('DEF')]
\end_layout

\begin_layout Plain Layout

>>> df
\end_layout

\begin_layout Plain Layout

   A  B  C
\end_layout

\begin_layout Plain Layout

   D  E  F
\end_layout

\begin_layout Plain Layout

0  a  1  2
\end_layout

\begin_layout Plain Layout

1  b  3  4
\end_layout

\begin_layout Plain Layout

2  c  5  6
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
add a new column
\end_layout

\begin_layout Standard
to add a col:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

data_target['price'] = 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
NOT
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

data_target.pirce = 0
\end_layout

\end_inset


\end_layout

\begin_layout Standard
in this case pd will think it is an attribute, not a column
\change_inserted -445235034 1463112469

\end_layout

\begin_layout Standard

\change_inserted -445235034 1463112512
In the case the to-be-assigned object is a series, you need .loc
\end_layout

\begin_layout Standard

\change_inserted -445235034 1463112496
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted -445235034 1463112496

\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463112500

pos_functions2['function_start'] = function_start # WRONG
\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463112496

\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463112505

pos_functions2.loc[:,'function_start'] = function_start # CORRECT
\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463112496

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
explore a DataFrame / Series
\end_layout

\begin_layout Subsection
colname/ rowname :: df.index, df.columns
\end_layout

\begin_layout Subsection
dim: .shape
\end_layout

\begin_layout Subsection
see the value: an array: df.values
\end_layout

\begin_layout Subsection
head(n)/tail(n) :: .head() / .tail(n)
\end_layout

\begin_layout Subsection
summary :: df.describe()
\end_layout

\begin_layout Subsection
check class of each column
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [12]: df2.dtypes
\end_layout

\begin_layout Plain Layout

Out[12]:
\end_layout

\begin_layout Plain Layout

A           float64
\end_layout

\begin_layout Plain Layout

B    datetime64[ns]
\end_layout

\begin_layout Plain Layout

C           float32
\end_layout

\begin_layout Plain Layout

D             int32
\end_layout

\begin_layout Plain Layout

E          category
\end_layout

\begin_layout Plain Layout

F            object
\end_layout

\begin_layout Plain Layout

dtype: object
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
unique:: pd.Series.unique()
\end_layout

\begin_layout Subsection
%in% :: .isin()
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

df2['E'] = ['one', 'one','two','three','four','three']
\end_layout

\begin_layout Plain Layout

df2[df2['E'].isin(['two','four'])]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
DataFrame also has an isin method.
 When calling isin, pass a set of values as either an array or dict.
 If values is an array, isin returns a DataFrame of booleans that is the
 same shape as the original DataFrame, with True wherever the element is
 in the sequence of values.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [137]: df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': ['a', 'b', 'f',
 'n'],
\end_layout

\begin_layout Plain Layout

.....: 'ids2': ['a', 'n', 'c', 'n']})
\end_layout

\begin_layout Plain Layout

.....:
\end_layout

\begin_layout Plain Layout

In [138]: values = ['a', 'b', 1, 3]
\end_layout

\begin_layout Plain Layout

In [139]: df.isin(values)
\end_layout

\begin_layout Plain Layout

Out[139]:
\end_layout

\begin_layout Plain Layout

ids ids2 vals
\end_layout

\begin_layout Plain Layout

0 True True True
\end_layout

\begin_layout Plain Layout

1 True False False
\end_layout

\begin_layout Plain Layout

2 False False True
\end_layout

\begin_layout Plain Layout

3 False False False
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Oftentimes you’ll want to match certain values with certain columns.
 Just make values a dict where the key is the column, and the value is a
 list of items you want to check for.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [140]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}
\end_layout

\begin_layout Plain Layout

In [141]: df.isin(values)
\end_layout

\begin_layout Plain Layout

Out[141]:
\end_layout

\begin_layout Plain Layout

ids ids2 vals
\end_layout

\begin_layout Plain Layout

0 True False True
\end_layout

\begin_layout Plain Layout

1 True False False
\end_layout

\begin_layout Plain Layout

2 False False True
\end_layout

\begin_layout Plain Layout

3 False False False
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Combine DataFrame’s isin with the any() and all() methods to quickly select
 subsets of your data that meet a given criteria.
 To select a row where each column meets its own criterion:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [142]: values = {'ids': ['a', 'b'], 'ids2': ['a', 'c'], 'vals': [1, 3]}
\end_layout

\begin_layout Plain Layout

In [143]: row_mask = df.isin(values).all(1)
\end_layout

\begin_layout Plain Layout

In [144]: df[row_mask]
\end_layout

\begin_layout Plain Layout

Out[144]:
\end_layout

\begin_layout Plain Layout

ids ids2 vals
\end_layout

\begin_layout Plain Layout

0 a a 1
\end_layout

\end_inset


\end_layout

\begin_layout Section
Printing Behavior Options
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Itemize

pd.set_option('display.max_columns', 500) # print max cols
\end_layout

\begin_layout Itemize

pd.set_option('display.width', 200) # print max width, if table is bigger
 than 200 then truncated
\end_layout

\begin_layout Itemize

pd.set_option('expand_frame_repr', True) # for super wide tables, whether
 cross page
\end_layout

\end_inset


\end_layout

\begin_layout Part
pandas: manipulate
\end_layout

\begin_layout Subsection

\change_inserted -445235034 1463031053
delete a column
\end_layout

\begin_layout Standard

\change_inserted -445235034 1463031063
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted -445235034 1463031063

df.drop('column_name', axis=1, inplace=True) 
\change_unchanged

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Assign values to multiple columns / rows
\end_layout

\begin_layout Standard
Assign B table into selected parts of A table.
\end_layout

\begin_layout Itemize
If A table and B table have different indexes or columns, then assignement
 failed: values all becomes NaN
\change_inserted -445235034 1463031001
.
 So make the index same first!
\change_unchanged

\end_layout

\begin_layout Itemize

\change_deleted -445235034 1463031021
So
\change_unchanged
 use B.values to transform B into array 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

A[part] = B.values
\end_layout

\end_inset


\change_inserted -445235034 1463031023

\end_layout

\begin_layout Itemize

\change_inserted -445235034 1463031043
OR use 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted -445235034 1463031043

A.loc[] or A.iloc[] = B 
\change_unchanged

\end_layout

\end_inset


\change_unchanged

\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

data_temp = pd.DataFrame({'ticker': [1,2,3]}) # initiate a STORAGE dataset
\end_layout

\begin_layout Plain Layout

data_temp['price'] = [1,2,30]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

filled = pd.concat([pd.Series([1,2,3]), pd.Series([4,5,6])],axis = 1) 
\end_layout

\begin_layout Plain Layout

# assign values to multiple cols
\end_layout

\begin_layout Plain Layout

filled.index = ['a','b','c']
\end_layout

\begin_layout Plain Layout

filled.columns = ['priceA','tickerA']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[176]: data_test.loc[:, ['ticker', 'price']] = filled.values
\end_layout

\begin_layout Plain Layout

In[177]: data_test
\end_layout

\begin_layout Plain Layout

Out[177]: 
\end_layout

\begin_layout Plain Layout

   ticker  price
\end_layout

\begin_layout Plain Layout

0       1      4
\end_layout

\begin_layout Plain Layout

1       2      5
\end_layout

\begin_layout Plain Layout

2       3      6
\end_layout

\end_inset


\end_layout

\begin_layout Section
Summary Calculation
\end_layout

\begin_layout Standard
Most of these are aggregations (hence producing a lower-dimensional result)
 like sum(), mean(), and quantile(), but some of them, like cumsum() and
 cumprod(), produce an object of the same size.
 
\end_layout

\begin_layout Itemize
summary
\end_layout

\begin_deeper
\begin_layout Standard
describe() like summary() in R
\end_layout

\begin_layout Description
value_counts(): count freq of each unique value
\end_layout

\begin_layout Description
count Number of non-null observations
\end_layout

\begin_layout Description
sum Sum of values
\end_layout

\begin_layout Description
mean Mean of values
\end_layout

\begin_layout Description
mad Mean absolute deviation
\end_layout

\begin_layout Description
median Arithmetic median of values
\end_layout

\end_deeper
\begin_layout Itemize
max/mix: can be used as min or pmin like in R
\end_layout

\begin_deeper
\begin_layout Description
min Minimum
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[218]: min([1,2,3])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[217]: 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[219]: min([1,2,3],[112,33,33])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[218]: [1, 2, 3]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# none or np.nan are always the smallest
\end_layout

\begin_layout Plain Layout

In[225]: min([1,2,3],[0,33,None])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[224]: [0, 33, None]
\end_layout

\begin_layout Plain Layout

In[226]: min([1,2,3],[0,33,np.nan])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[225]: [0, 33, nan]
\end_layout

\end_inset


\end_layout

\begin_layout Description
max Maximum
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# none or np.nan are always the smallest
\end_layout

\begin_layout Plain Layout

In[227]: max([1,2,3],[0,33,np.nan])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[226]: [1, 2, 3]
\end_layout

\begin_layout Plain Layout

In[228]: max([1,2,3],[0,33,None])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[227]: [1, 2, 3]
\end_layout

\end_inset


\end_layout

\begin_layout Description

\family typewriter
idxmin()/idxmax()
\family default
 functions on Series and DataFrame compute the index labels with the minimum
 and maximum corresponding values:
\end_layout

\end_deeper
\begin_layout Itemize
statistics
\end_layout

\begin_deeper
\begin_layout Description
mode Mode
\end_layout

\begin_layout Description
abs Absolute Value
\end_layout

\begin_layout Description
prod Product of values
\end_layout

\begin_layout Description
std Bessel-corrected sample standard deviation
\end_layout

\begin_layout Description
var Unbiased variance
\end_layout

\begin_layout Description
sem Standard error of the mean
\end_layout

\begin_layout Description
skew Sample skewness (3rd moment)
\end_layout

\begin_layout Description
kurt Sample kurtosis (4th moment)
\end_layout

\begin_layout Description
quantile Sample quantile (value at %)
\end_layout

\end_deeper
\begin_layout Itemize
cumulative
\end_layout

\begin_deeper
\begin_layout Description
cumsum Cumulative sum
\end_layout

\begin_layout Description
cumprod Cumulative product
\end_layout

\begin_layout Description
cummax Cumulative maximum
\end_layout

\begin_layout Description
cummin Cumulative minimum
\end_layout

\end_deeper
\begin_layout Subsection
axis argument
\end_layout

\begin_layout Standard
Generally speaking, these methods take an axis argument, just like ndarray.{sum,
 std, ...}, but the axis can be specified by name or integer:
\end_layout

\begin_layout Itemize
Series: no axis argument needed
\end_layout

\begin_layout Itemize
DataFrame: “index” (axis=0, default), “columns” (axis=1)
\end_layout

\begin_layout Itemize
Panel: “items” (axis=0), “major” (axis=1, default), “minor” (axis=2)
\end_layout

\begin_layout Subsection
Discretization and quantiling: cut() / qcut()
\end_layout

\begin_layout Itemize
pd.cut(object, number_of_categories)
\end_layout

\begin_deeper
\begin_layout Itemize
We can also pass infinite values to define the bins::
\begin_inset ERT
status open

\begin_layout Plain Layout

factor = pd.cut(arr, [-np.inf, 0, np.inf])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
pd.qcut(object,[list of quantiles])
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [113]: arr = np.random.randn(20)
\end_layout

\begin_layout Plain Layout

In [114]: factor = pd.cut(arr, 4)
\end_layout

\begin_layout Plain Layout

In [115]: factor Out[115]:  [(-0.645, 0.336], (-2.61, -1.626], (-1.626, -0.645],
 (-1.626, -0.645], (-1.626, -0.645], ..., (0.336, 1.316], (0.336, 1.316], (0.336, 1.316],
 (0.336, 1.316], (-2.61, -1.626]] Length: 20 Categories (4, object): [(-2.61,
 -1.626] (-1.626, -0.645] (-0.645, 0.336] (0.336, 1.316]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [118]: arr = np.random.randn(30)
\end_layout

\begin_layout Plain Layout

In [119]: factor = pd.qcut(arr, [0, .25, .5, .75, 1])
\end_layout

\begin_layout Plain Layout

In [120]: factor
\end_layout

\begin_layout Plain Layout

Out[120]:
\end_layout

\begin_layout Plain Layout

[(-0.139, 1.00736], (1.00736, 1.976], (1.00736, 1.976], [-1.0705, -0.439], [-1.0705,
 -0.439], ..., (1.00736, 1.976], [-1.0705, -0.439], (-0.439, -0.139], (-0.439, -0.139],
 (-0.439, -0.139]]
\end_layout

\begin_layout Plain Layout

Length: 30
\end_layout

\begin_layout Plain Layout

Categories (4, object): [[-1.0705, -0.439] (-0.439, -0.139] (-0.139, 1.00736]
  (1.00736, 1.976]]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Matrix Calculation
\end_layout

\begin_layout Subsection
transpose
\end_layout

\begin_layout Standard
index will become columns, and columns will become indexx
\end_layout

\begin_layout Itemize
transpose: df[:5].T
\end_layout

\begin_layout Subsection
matrix multiplication
\end_layout

\begin_layout Itemize
The dot method on DataFrame implements matrix multiplication:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [96]: df.T.dot(df)
\end_layout

\begin_layout Plain Layout

Out[96]:
\end_layout

\begin_layout Plain Layout

A B C
\end_layout

\begin_layout Plain Layout

A 4.0471 -0.0390 0.1783
\end_layout

\begin_layout Plain Layout

B -0.0390 4.6207 -2.5806
\end_layout

\begin_layout Plain Layout

C 0.1783 -2.5806 7.9431
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
Data Alignment
\end_layout

\begin_layout Standard
Behavior of data alignment is hard to predict, so you'd bettern to only
 do calculations beween already alighned DataFrames
\end_layout

\begin_layout Subsection
Data alignment between Series
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

dates = pd.date_range('1/1/2000', periods=8)
\end_layout

\begin_layout Plain Layout

df = pd.DataFrame(np.random.randn(8, 4), index=dates, columns=['A', 'B', 'C',
 'D'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s = df['A']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

s[1:3] + s[2:4]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[189]:
\end_layout

\begin_layout Plain Layout

2000-01-02         NaN
\end_layout

\begin_layout Plain Layout

2000-01-03   -0.757393
\end_layout

\begin_layout Plain Layout

2000-01-04         NaN
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Data alignment between df
\end_layout

\begin_layout Standard
Data alignment between DataFrame objects automatically align on both the
 columns and the index (row labels).
 Again, the resulting object will have the union of the column and row labels.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [75]: df = pd.DataFrame(np.random.randn(10, 4), columns=['A', 'B', 'C',
 'D'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [76]: df2 = pd.DataFrame(np.random.randn(7, 3), columns=['A', 'B', 'C'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [77]: df + df2
\end_layout

\begin_layout Plain Layout

Out[77]:
\end_layout

\begin_layout Plain Layout

        A       B       C   D
\end_layout

\begin_layout Plain Layout

0 -1.9160 -0.9862 -2.4213 NaN
\end_layout

\begin_layout Plain Layout

1  0.9651  1.6767  0.3298 NaN
\end_layout

\begin_layout Plain Layout

2 -1.6622  2.1966 -1.9169 NaN
\end_layout

\begin_layout Plain Layout

3 -0.1887  0.7653 -0.0010 NaN
\end_layout

\begin_layout Plain Layout

4 -1.0760  0.3969 -1.1774 NaN
\end_layout

\begin_layout Plain Layout

5  2.8104 -0.1792 -0.5705 NaN
\end_layout

\begin_layout Plain Layout

6 -1.2272  0.1963  0.5312 NaN
\end_layout

\begin_layout Plain Layout

7     NaN     NaN     NaN NaN
\end_layout

\begin_layout Plain Layout

8     NaN     NaN     NaN NaN
\end_layout

\begin_layout Plain Layout

9     NaN     NaN     NaN NaN
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Data alignment between df and Series
\end_layout

\begin_layout Standard
When doing an operation between DataFrame and Series, the default behavior
 is to align the Series index on the DataFrame columns, thus broadcasting
 row-wise.
 
\end_layout

\begin_layout Standard
In the special case of working with time series data, and the DataFrame
 index also contains dates, the broadcasting will be column-wise.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [75]: df = pd.DataFrame(np.random.randn(10, 4), columns=['A', 'B', 'C',
 'D'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df.iloc[0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[181]:
\end_layout

\begin_layout Plain Layout

A   -0.278231
\end_layout

\begin_layout Plain Layout

B    0.921258
\end_layout

\begin_layout Plain Layout

C    0.755367
\end_layout

\begin_layout Plain Layout

D   -0.465127
\end_layout

\begin_layout Plain Layout

Name: 0, dtype: float64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [78]: df - df.iloc[0]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[78]:
\end_layout

\begin_layout Plain Layout

A B C D
\end_layout

\begin_layout Plain Layout

0 0.0000 0.0000 0.0000 0.0000
\end_layout

\begin_layout Plain Layout

1 2.3859 1.3585 1.2234 -2.1065
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

8 2.6802 3.1629 1.2977 -1.8177
\end_layout

\begin_layout Plain Layout

9 1.3038 0.1957 3.5899 -0.8671
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In the special case of working with time series data, and the DataFrame
 index also contains dates, the broadcasting will be column-wise:
\end_layout

\begin_layout Section
DataFrame Manipulation
\end_layout

\begin_layout Standard
data used:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [22]: df1 = pd.DataFrame({'key': ['A', 'B', 'C', 'D'],
\end_layout

\begin_layout Plain Layout

   ....:                     'value': np.random.randn(4)})
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [23]: df2 = pd.DataFrame({'key': ['B', 'D', 'D', 'E'],
\end_layout

\begin_layout Plain Layout

   ....:                     'value': np.random.randn(4)})
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

url =
\end_layout

\begin_layout Plain Layout

'https://raw.github.com/pydata/pandas/master/pandas/tests/data/tips.csv'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

tips = pd.read_csv(url)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Transpose t(): df.T
\end_layout

\begin_layout Subsection
sort: .sort_index() , .sort_values(): can work with list
\end_layout

\begin_layout Standard

\family typewriter
price.sort_values(by = ['return','target'])
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

Sorting by an axis
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [21]: df.sort_index(axis=1, ascending=False)
\end_layout

\begin_layout Plain Layout

Out[21]:
\end_layout

\begin_layout Plain Layout

                   D         C         B         A
\end_layout

\begin_layout Plain Layout

2013-01-01 -1.135632 -1.509059 -0.282863  0.469112
\end_layout

\begin_layout Plain Layout

2013-01-02 -1.044236  0.119209 -0.173215  1.212112
\end_layout

\begin_layout Plain Layout

2013-01-03  1.071804 -0.494929 -2.104569 -0.861849
\end_layout

\begin_layout Plain Layout

2013-01-04  0.271860 -1.039575 -0.706771  0.721555
\end_layout

\begin_layout Plain Layout

2013-01-05 -1.087401  0.276232  0.567020 -0.424972
\end_layout

\begin_layout Plain Layout

2013-01-06  0.524988 -1.478427  0.113648 -0.673690
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Sorting by values
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [22]: df.sort_values(by='B')
\end_layout

\begin_layout Plain Layout

Out[22]:
\end_layout

\begin_layout Plain Layout

                   A         B         C         D
\end_layout

\begin_layout Plain Layout

2013-01-03 -0.861849 -2.104569 -0.494929  1.071804
\end_layout

\begin_layout Plain Layout

2013-01-04  0.721555 -0.706771 -1.039575  0.271860
\end_layout

\begin_layout Plain Layout

2013-01-01  0.469112 -0.282863 -1.509059 -1.135632
\end_layout

\begin_layout Plain Layout

2013-01-02  1.212112 -0.173215  0.119209 -1.044236
\end_layout

\begin_layout Plain Layout

2013-01-06 -0.673690  0.113648 -1.478427  0.524988
\end_layout

\begin_layout Plain Layout

2013-01-05 -0.424972  0.567020  0.276232 -1.087401
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
replace values:: pd.Series.replace( [tobereplace], [values])
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [88]: ser = pd.Series([0., 1., 2., 3., 4.])
\end_layout

\begin_layout Plain Layout

# You can replace a list of values by a list of other values:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [90]: ser.replace([0, 1, 2, 3, 4], [4, 3, 2, 1, 0])
\end_layout

\begin_layout Plain Layout

Out[90]:
\end_layout

\begin_layout Plain Layout

0    4.0
\end_layout

\begin_layout Plain Layout

1    3.0
\end_layout

\begin_layout Plain Layout

2    2.0
\end_layout

\begin_layout Plain Layout

3    1.0
\end_layout

\begin_layout Plain Layout

4    0.0
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# You can also specify a mapping dict:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [91]: ser.replace({0: 10, 1: 100})
\end_layout

\begin_layout Plain Layout

Out[91]:
\end_layout

\begin_layout Plain Layout

0     10.0
\end_layout

\begin_layout Plain Layout

1    100.0
\end_layout

\begin_layout Plain Layout

2      2.0
\end_layout

\begin_layout Plain Layout

3      3.0
\end_layout

\begin_layout Plain Layout

4      4.0
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
append rows
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

df = pd.DataFrame(np.random.randn(8, 4), columns=['A','B','C','D'])
\end_layout

\begin_layout Plain Layout

s = df.iloc[3]
\end_layout

\begin_layout Plain Layout

df.append(s, ignore_index=True)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
delete columns
\end_layout

\begin_layout Standard
see more in user-defined function:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

del df1['A'] # in place delete statement
\end_layout

\begin_layout Plain Layout

df1.pop('B') # in place delete, change df1 and at the same time will return
 column B
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
cut Series into intervals by values
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[137]: bins = [0, 25, 50, 75, 100]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[138]: group_names = ['Low', 'Okay', 'Good', 'Great']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[139]: df['categories'] = pd.cut(df['postTestScore'], bins, labels=group_names)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[140]: df.loc[:,['categories','postTestScore']]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[138]: 
\end_layout

\begin_layout Plain Layout

   categories  postTestScore
\end_layout

\begin_layout Plain Layout

0         Low             25
\end_layout

\begin_layout Plain Layout

1       Great             94
\end_layout

\begin_layout Plain Layout

2        Good             57
\end_layout

\begin_layout Plain Layout

3        Good             62
\end_layout

\begin_layout Plain Layout

4        Good             70
\end_layout

\begin_layout Plain Layout

5         Low             25
\end_layout

\begin_layout Plain Layout

6       Great             94
\end_layout

\begin_layout Plain Layout

7        Good             57
\end_layout

\begin_layout Plain Layout

8        Good             62
\end_layout

\begin_layout Plain Layout

9        Good             70
\end_layout

\begin_layout Plain Layout

10       Good             62
\end_layout

\begin_layout Plain Layout

11       Good             70
\end_layout

\end_inset


\end_layout

\begin_layout Section
DataFrame SQL
\end_layout

\begin_layout Subsection
SQL Join
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

pd.merge(left, right, how='inner', on=None, left_on=None, right_on=None,
\end_layout

\begin_layout Plain Layout

      left_index=False, right_index=False, sort=True,
\end_layout

\begin_layout Plain Layout

      suffixes=('_x', '_y'), copy=True, indicator=False)
\end_layout

\end_inset


\end_layout

\begin_layout Description
on on: Columns (names) to join on.
 Must be found in both the left and right DataFrame objects.
 If not passed and left_index and right_index are False, the intersection
 of the columns in the DataFrames will be inferred to be the join keys
\end_layout

\begin_deeper
\begin_layout Standard
could be a list.
\end_layout

\end_deeper
\begin_layout Description
how: One of 'left', 'right', 'outer', 'inner'.
 Defaults to inner.
 
\end_layout

\begin_layout Description
sort: Sort the result DataFrame by the join keys in lexicographical order.
 Defaults to True, setting to False will improve performance substantially
 in many cases
\end_layout

\begin_layout Description
suffixes: A tuple of string suffixes to apply to overlapping columns.
 Defaults to ('_x', '_y').
\end_layout

\begin_layout Description
copy: Always copy data (default True) from the passed DataFrame objects,
 even when reindexing is not necessary.
 Cannot be avoided in many cases but may improve performance / memory usage.
\end_layout

\begin_layout Description
indicator: Add a column to the output DataFrame called _merge with information
 on the source of each row.
 _merge is Categorical-type and takes on a value of
\family typewriter
left_only
\family default
 for observations whose merge key only appears in 'left' DataFrame,
\family typewriter
right_only
\family default
 for observations whose merge key only appears in 'right' DataFrame, and
 
\family typewriter
both
\family default
 if the observation’s merge key is found in both.
\end_layout

\begin_layout Description
left_index: If True, use the index (row labels) from the left DataFrame
 as its join key(s).
 In the case of a DataFrame with a MultiIndex (hierarchical), the number
 of levels must match the number of join keys from the right DataFrame
\end_layout

\begin_layout Itemize
INNER JOIN:
\family typewriter
pd.merge(df1, df2, on='key')
\end_layout

\begin_layout Itemize
LEFT (OUTER) JOIN: -- show all records from df1
\family typewriter
pd.merge(df1, df2, on='key', how='left')
\end_layout

\begin_layout Itemize
Joining on index: remeber
\family typewriter
index
\family default
is the rownames of DataFrame.
 If both
\family typewriter
left
\family default
 and
\family typewriter
right
\family default
data get indexes, we can directly use
\family typewriter
left.join(right, how = 'inner')
\end_layout

\begin_deeper
\begin_layout Itemize
Joining key columns on an index:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# example: left key is index, right key is a col name
\end_layout

\begin_layout Plain Layout

# These two function calls are completely equivalent:
\end_layout

\begin_layout Plain Layout

left.join(right, on=key_or_keys)
\end_layout

\begin_layout Plain Layout

pd.merge(left, right, left_on=key_or_keys, right_index=True,
\end_layout

\begin_layout Plain Layout

      how='left', sort=False)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
SQL Join: fill missing values of left by right
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [88]: df1 = pd.DataFrame([[np.nan, 3., 5.], [-4.6, np.nan, np.nan],
\end_layout

\begin_layout Plain Layout

   ....:                    [np.nan, 7., np.nan]])
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [89]: df2 = pd.DataFrame([[-42.6, np.nan, -8.2], [-5., 1.6, 4]],
\end_layout

\begin_layout Plain Layout

   ....:                    index=[1, 2])
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# Note that this method only takes values from the right DataFrame if they
 are missing in the left DataFrame.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [90]: result = df1.combine_first(df2)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SQL Join: fill missing values of right by left
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [91]: df1.update(df2)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SQL Join: UNION vertically: rbind
\end_layout

\begin_layout Standard
SQL’s UNION is similar to UNION ALL, however UNION will remove duplicate
 rows.
 In pandas, you can use concat() in conjunction with drop_duplicates().
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [30]: df1 = pd.DataFrame({'city': ['Chicago', 'San Francisco', 'New York
 City'],
\end_layout

\begin_layout Plain Layout

   ....:                     'rank': range(1, 4)})
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [31]: df2 = pd.DataFrame({'city': ['Chicago', 'Boston', 'Los Angeles'],
\end_layout

\begin_layout Plain Layout

   ....:                     'rank': [1, 4, 5]})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [33]: pd.concat([df1, df2]).drop_duplicates()
\end_layout

\begin_layout Plain Layout

Out[33]:
\end_layout

\begin_layout Plain Layout

            city  rank
\end_layout

\begin_layout Plain Layout

0        Chicago     1
\end_layout

\begin_layout Plain Layout

1  San Francisco     2
\end_layout

\begin_layout Plain Layout

2  New York City     3
\end_layout

\begin_layout Plain Layout

1         Boston     4
\end_layout

\begin_layout Plain Layout

2    Los Angeles     5
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
cbind() :: UNION horizontally / Combine Series into DataFrame
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

pd.concat([Price, target_china], axis = 1 )
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
where axis = 1 means union horizentally, -0 means union vertically
\end_layout

\begin_layout Section
SQL: groupby
\end_layout

\begin_layout Itemize
SeriesA.groupby(SeriesB) # (A and B must be the same length)
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

list(df['preTestScore'].groupby(df['company']))
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

df['preTestScore'].groupby([df['regiment'], df['company']]).mean()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
df.groupby('A') # 'A' is a col name
\end_layout

\begin_layout Itemize
df.groupby(['A', 'B']) # both 'A' and 'B' are col names
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# Create dataframe
\end_layout

\begin_layout Plain Layout

raw_data = {'regiment': ['Nighthawks', 'Nighthawks', 'Nighthawks', 'Nighthawks',
 'Dragoons', 'Dragoons', 'Dragoons', 'Dragoons', 'Scouts', 'Scouts', 'Scouts',
 'Scouts'], 
\end_layout

\begin_layout Plain Layout

        'company': ['1st', '1st', '2nd', '2nd', '1st', '1st', '2nd', '2nd','1st'
, '1st', '2nd', '2nd'], 
\end_layout

\begin_layout Plain Layout

        'name': ['Miller', 'Jacobson', 'Ali', 'Milner', 'Cooze', 'Jacon',
 'Ryaner', 'Sone', 'Sloan', 'Piger', 'Riani', 'Ali'], 
\end_layout

\begin_layout Plain Layout

        'preTestScore': [4, 24, 31, 2, 3, 4, 24, 31, 2, 3, 2, 3],
\end_layout

\begin_layout Plain Layout

        'postTestScore': [25, 94, 57, 62, 70, 25, 94, 57, 62, 70, 62, 70]}
\end_layout

\begin_layout Plain Layout

df = pd.DataFrame(raw_data, columns = ['regiment', 'company', 'name', 'preTestSco
re', 'postTestScore'])
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

groupby_regiment = df['preTestScore'].groupby(df['company']) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[128]: 
\end_layout

\begin_layout Plain Layout

      regiment company      name  preTestScore  postTestScore
\end_layout

\begin_layout Plain Layout

0   Nighthawks     1st    Miller             4             25
\end_layout

\begin_layout Plain Layout

1   Nighthawks     1st  Jacobson            24             94
\end_layout

\begin_layout Plain Layout

2   Nighthawks     2nd       Ali            31             57
\end_layout

\begin_layout Plain Layout

3   Nighthawks     2nd    Milner             2             62
\end_layout

\begin_layout Plain Layout

4     Dragoons     1st     Cooze             3             70
\end_layout

\begin_layout Plain Layout

5     Dragoons     1st     Jacon             4             25
\end_layout

\begin_layout Plain Layout

6     Dragoons     2nd    Ryaner            24             94
\end_layout

\begin_layout Plain Layout

7     Dragoons     2nd      Sone            31             57
\end_layout

\begin_layout Plain Layout

8       Scouts     1st     Sloan             2             62
\end_layout

\begin_layout Plain Layout

9       Scouts     1st     Piger             3             70
\end_layout

\begin_layout Plain Layout

10      Scouts     2nd     Riani             2             62
\end_layout

\begin_layout Plain Layout

11      Scouts     2nd       Ali             3             70
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
group by columns: axis=1
\end_layout

\begin_layout Itemize
df.groupby(Function, axis = 1) # Function take each column as input, an return
 one value, then we group each column according to that value.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

list(df.groupby(df.dtypes, axis=1))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[(dtype('int64'),     preTestScore  postTestScore
\end_layout

\begin_layout Plain Layout

  0              4             25
\end_layout

\begin_layout Plain Layout

  1             24             94
\end_layout

\begin_layout Plain Layout

  2             31             57
\end_layout

\begin_layout Plain Layout

  ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  [12 rows x 2 columns]), (dtype('O'),       regiment company      name
\end_layout

\begin_layout Plain Layout

  0   Nighthawks     1st    Miller
\end_layout

\begin_layout Plain Layout

  1   Nighthawks     1st  Jacobson
\end_layout

\begin_layout Plain Layout

  2   Nighthawks     2nd       Ali
\end_layout

\begin_layout Plain Layout

 ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  [12 rows x 3 columns])]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.groups: group name and group index
\end_layout

\begin_layout Itemize
group names are the values of key vars: 
\end_layout

\begin_layout Itemize
group index are the index of original dataset corresponding to that key
 var value
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[202]: df.groupby(['regiment']).groups
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[189]: 
\end_layout

\begin_layout Plain Layout

{'Dragoons': [4, 5, 6, 7],
\end_layout

\begin_layout Plain Layout

 'Nighthawks': [0, 1, 2, 3],
\end_layout

\begin_layout Plain Layout

 'Scouts': [8, 9, 10, 11]}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Group.groups.keys() : view the keys
\end_layout

\begin_layout Itemize
Group.groups['name'] : view the index
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[203]: df.groupby(['regiment']).groups.keys()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[190]: ['Dragoons', 'Nighthawks', 'Scouts']
\end_layout

\begin_layout Plain Layout

In[204]: df.groupby(['regiment']).groups['Dragoons'] # return the index
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[191]: [4, 5, 6, 7]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
View a grouping content
\end_layout

\begin_layout Itemize
use 
\family typewriter
list()
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

list(df['preTestScore'].groupby(df['company']))
\end_layout

\begin_layout Plain Layout

[('1st', 0     4
\end_layout

\begin_layout Plain Layout

  1    24
\end_layout

\begin_layout Plain Layout

  4     3
\end_layout

\begin_layout Plain Layout

  5     4
\end_layout

\begin_layout Plain Layout

  8     2
\end_layout

\begin_layout Plain Layout

  9     3
\end_layout

\begin_layout Plain Layout

  Name: preTestScore, dtype: int64), ('2nd', 2     31
\end_layout

\begin_layout Plain Layout

  3      2
\end_layout

\begin_layout Plain Layout

  6     24
\end_layout

\begin_layout Plain Layout

  7     31
\end_layout

\begin_layout Plain Layout

  10     2
\end_layout

\begin_layout Plain Layout

  11     3
\end_layout

\begin_layout Plain Layout

  Name: preTestScore, dtype: int64)]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
see the first or last group
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

groupby_regiment = df['preTestScore'].groupby(df['company']) 
\end_layout

\begin_layout Plain Layout

groupby_regiment.first() 
\end_layout

\begin_layout Plain Layout

groupby_regiment.last() 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
iterate over groups: return a tuple( index, df )
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# Group the dataframe by regiment, and for each regiment,
\end_layout

\begin_layout Plain Layout

for name, group in df.groupby('regiment'): 
\end_layout

\begin_layout Plain Layout

    # print the name of the regiment
\end_layout

\begin_layout Plain Layout

    print(name)
\end_layout

\begin_layout Plain Layout

    # print the data of that regiment
\end_layout

\begin_layout Plain Layout

    print(group)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
summary functions
\end_layout

\begin_layout Standard
The need for custom functions is minimal unless you have very specific requireme
nts.
 The full range of basic statistics that are quickly calculable and built
 into the base Pandas package are:
\end_layout

\begin_layout Description
count 	Number of non-null observations
\end_layout

\begin_layout Description
sum	 Sum of values
\end_layout

\begin_layout Description
mean	 Mean of values
\end_layout

\begin_layout Description
mad	 Mean absolute deviation
\end_layout

\begin_layout Description
median	 Arithmetic median of values
\end_layout

\begin_layout Description
min	 Minimum
\end_layout

\begin_layout Description
max	 Maximum
\end_layout

\begin_layout Description
mode	 Mode
\end_layout

\begin_layout Description
abs	 Absolute Value
\end_layout

\begin_layout Description
prod	 Product of values
\end_layout

\begin_layout Description
std	 Unbiased standard deviation
\end_layout

\begin_layout Description
var	 Unbiased variance
\end_layout

\begin_layout Description
sem	 Unbiased standard error of the mean
\end_layout

\begin_layout Description
skew	 Unbiased skewness (3rd moment)
\end_layout

\begin_layout Description
kurt	 Unbiased kurtosis (4th moment)
\end_layout

\begin_layout Description
quantile	 Sample quantile (value at %)
\end_layout

\begin_layout Description
cumsum 	Cumulative sum
\end_layout

\begin_layout Description
cumprod 	Cumulative product
\end_layout

\begin_layout Description
cummax	 Cumulative maximum
\end_layout

\begin_layout Description
cummin 	Cumulative minimum
\end_layout

\begin_layout Itemize
Descriptive statistics by group 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

df['preTestScore'].groupby(df['company']).describe() 
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
grouped.mean()
\end_layout

\begin_layout Itemize
grouped.sum()
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

groupby_regiment = df['preTestScore'].groupby(df['company']) 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

groupby_regiment.mean() 
\end_layout

\begin_layout Plain Layout

company
\end_layout

\begin_layout Plain Layout

1st         6.666667
\end_layout

\begin_layout Plain Layout

2nd        15.500000
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
n():: size()
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

df.groupby(['regiment', 'company']).size()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
auto omitting "nuisance" columns
\end_layout

\begin_layout Standard
summary functions that may not be applicatable to non-floate columns, so
 those columns will be ignored.
\end_layout

\begin_layout Subsection
unstack(): summary without heirarchical indexing
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

df['preTestScore'].groupby([df['regiment'],df['company']]).mean().unstack()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

company 1st 2nd
\end_layout

\begin_layout Plain Layout

regiment 
\end_layout

\begin_layout Plain Layout

Dragoons 3.5 27.5
\end_layout

\begin_layout Plain Layout

Nighthawks 14.0 16.5
\end_layout

\begin_layout Plain Layout

Scouts 2.5 2.5
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
aggregate/ agg function
\end_layout

\begin_layout Standard
Summrize each group.
 Take a dictionary as argument:
\end_layout

\begin_layout Itemize
key is the col name
\end_layout

\begin_layout Itemize
value is the action: sumamrized function 
\end_layout

\begin_deeper
\begin_layout Itemize
if the action function is from the default summary function, then you need
 to quote it
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

df.groupby(['regiment']).aggregate({'preTestScore': 'median',
\end_layout

\begin_layout Plain Layout

                                    'postTestScore': 'count'
\end_layout

\begin_layout Plain Layout

                                    })
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[213]: 
\end_layout

\begin_layout Plain Layout

            postTestScore  preTestScore
\end_layout

\begin_layout Plain Layout

regiment                               
\end_layout

\begin_layout Plain Layout

Dragoons                4          14.0
\end_layout

\begin_layout Plain Layout

Nighthawks              4          14.0
\end_layout

\begin_layout Plain Layout

Scouts                  4           2.5
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df.groupby('regiment')['preTestScore'].aggregate({
\end_layout

\begin_layout Plain Layout

    'mean' : np.mean, 'variance' : np.var})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[214]: 
\end_layout

\begin_layout Plain Layout

              variance   mean
\end_layout

\begin_layout Plain Layout

regiment                     
\end_layout

\begin_layout Plain Layout

Dragoons    200.333333  15.50
\end_layout

\begin_layout Plain Layout

Nighthawks  208.916667  15.25
\end_layout

\begin_layout Plain Layout

Scouts        0.333333   2.50
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df.groupby('regiment').agg(aggregations)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[215]: 
\end_layout

\begin_layout Plain Layout

            postTestScore  preTestScore
\end_layout

\begin_layout Plain Layout

regiment                               
\end_layout

\begin_layout Plain Layout

Dragoons               94            62
\end_layout

\begin_layout Plain Layout

Nighthawks             94            61
\end_layout

\begin_layout Plain Layout

Scouts                 70            10
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
OR, we can use nested dictionaries.
\end_layout

\begin_layout Standard
under each key as col name, there is another dictionary
\end_layout

\begin_layout Itemize
key is the col name
\end_layout

\begin_layout Itemize
value is the action function
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

aggregations = {
\end_layout

\begin_layout Plain Layout

    'preTestScore':{
\end_layout

\begin_layout Plain Layout

        'sum1': 'sum',
\end_layout

\begin_layout Plain Layout

        'average1': 'mean'
\end_layout

\begin_layout Plain Layout

    },
\end_layout

\begin_layout Plain Layout

    'postTestScore':
\end_layout

\begin_layout Plain Layout

        {'sum2': 'sum', 'average2': 'mean'
\end_layout

\begin_layout Plain Layout

         }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

print df.groupby('regiment').agg(aggregations)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

           postTestScore          preTestScore     
\end_layout

\begin_layout Plain Layout

                    sum2 average2     average1 sum1
\end_layout

\begin_layout Plain Layout

regiment                                           
\end_layout

\begin_layout Plain Layout

Dragoons             246     61.5        15.50   62
\end_layout

\begin_layout Plain Layout

Nighthawks           238     59.5        15.25   61
\end_layout

\begin_layout Plain Layout

Scouts               264     66.0         2.50   10
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Group.transform()
\end_layout

\begin_layout Standard
Like mutate in dply2:: calculate (not summarize) each group.
 It will return a df with the same dimention as the original one.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[231]: df.groupby(['regiment']).transform(zscore)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[218]: 
\end_layout

\begin_layout Plain Layout

    preTestScore  postTestScore
\end_layout

\begin_layout Plain Layout

0         -11.25          -34.5
\end_layout

\begin_layout Plain Layout

1           8.75           34.5
\end_layout

\begin_layout Plain Layout

2          15.75           -2.5
\end_layout

\begin_layout Plain Layout

3         -13.25            2.5
\end_layout

\begin_layout Plain Layout

4         -12.50            8.5
\end_layout

\begin_layout Plain Layout

5         -11.50          -36.5
\end_layout

\begin_layout Plain Layout

6           8.50           32.5
\end_layout

\begin_layout Plain Layout

7          15.50           -4.5
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Section
Duplicate
\end_layout

\begin_layout Subsection
drop_duplicates() 
\end_layout

\begin_layout Standard
If you want to identify and remove duplicate rows in a DataFrame, there
 are two methods that will help: duplicated and drop_duplicates.
 Each takes as an argument the columns to use to identify duplicated rows.
\end_layout

\begin_layout Itemize
duplicated returns a boolean vector whose length is the number of rows,
 and which indicates whether a row is duplicated.
\end_layout

\begin_layout Itemize
drop_duplicates() removes duplicate rows.
\end_layout

\begin_layout Standard
By default, the first observed row of a duplicate set is considered unique,
 but each method has a keep parameter to specify targets to be kept.
\end_layout

\begin_layout Itemize
keep='first' (default): mark / drop duplicates except for the first occurrence.
\end_layout

\begin_layout Itemize
keep='last': mark / drop duplicates except for the last occurrence.
\end_layout

\begin_layout Itemize
keep=False: mark / drop all duplicates.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [233]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'two', 'two', 'three',
 'four'],
\end_layout

\begin_layout Plain Layout

   .....:                     'b': ['x', 'y', 'x', 'y', 'x', 'x', 'x'],
\end_layout

\begin_layout Plain Layout

   .....:                     'c': np.random.randn(7)})
\end_layout

\begin_layout Plain Layout

   .....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [234]: df2
\end_layout

\begin_layout Plain Layout

Out[234]:
\end_layout

\begin_layout Plain Layout

       a  b         c
\end_layout

\begin_layout Plain Layout

0    one  x -0.599770
\end_layout

\begin_layout Plain Layout

1    one  y -0.120145
\end_layout

\begin_layout Plain Layout

2    two  x -1.403265
\end_layout

\begin_layout Plain Layout

3    two  y  0.162169
\end_layout

\begin_layout Plain Layout

4    two  x  0.232777
\end_layout

\begin_layout Plain Layout

5  three  x  1.048589
\end_layout

\begin_layout Plain Layout

6   four  x  0.070084
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [235]: df2.duplicated('a')
\end_layout

\begin_layout Plain Layout

Out[235]:
\end_layout

\begin_layout Plain Layout

0    False
\end_layout

\begin_layout Plain Layout

1     True
\end_layout

\begin_layout Plain Layout

2    False
\end_layout

\begin_layout Plain Layout

3     True
\end_layout

\begin_layout Plain Layout

4     True
\end_layout

\begin_layout Plain Layout

5    False
\end_layout

\begin_layout Plain Layout

6    False
\end_layout

\begin_layout Plain Layout

dtype: bool
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [241]: df2.duplicated(['a', 'b'])
\end_layout

\begin_layout Plain Layout

Out[241]:
\end_layout

\begin_layout Plain Layout

0    False
\end_layout

\begin_layout Plain Layout

1    False
\end_layout

\begin_layout Plain Layout

2    False
\end_layout

\begin_layout Plain Layout

3    False
\end_layout

\begin_layout Plain Layout

4     True
\end_layout

\begin_layout Plain Layout

5    False
\end_layout

\begin_layout Plain Layout

6    False
\end_layout

\begin_layout Plain Layout

dtype: bool
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [242]: df2.drop_duplicates(['a', 'b'])
\end_layout

\begin_layout Plain Layout

Out[242]:
\end_layout

\begin_layout Plain Layout

       a  b         c
\end_layout

\begin_layout Plain Layout

0    one  x -0.599770
\end_layout

\begin_layout Plain Layout

1    one  y -0.120145
\end_layout

\begin_layout Plain Layout

2    two  x -1.403265
\end_layout

\begin_layout Plain Layout

3    two  y  0.162169
\end_layout

\begin_layout Plain Layout

5  three  x  1.048589
\end_layout

\begin_layout Plain Layout

6   four  x  0.070084
\end_layout

\end_inset


\end_layout

\begin_layout Part
pandas: pipe apply
\end_layout

\begin_layout Subsection
pipe
\end_layout

\begin_layout Standard
DataFrames and Series can of course just be passed into functions.
 However, if the function needs to be called in a chain, consider using
 the pipe() method.
 Compare the following
\end_layout

\begin_layout Standard
# f, g, and h are functions taking and returning ``DataFrames``
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> f(g(h(df), arg1=1), arg2=2, arg3=3)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
with the equivalent
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> (df.pipe(h)
\end_layout

\begin_layout Plain Layout

.pipe(g, arg1=1)
\end_layout

\begin_layout Plain Layout

.pipe(f, arg2=2, arg3=3)
\end_layout

\begin_layout Plain Layout

)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Pandas encourages the second style, which is known as method chaining.
 pipe makes it easy to use your own or another library’s functions in method
 chains, alongside pandas’ methods.
\end_layout

\begin_layout Standard
In the example above, the functions f, g, and h each expected the DataFrame
 as the first positional argument.
 What if the function you wish to apply takes its data as, say, the second
 argument? In this case, provide pipe with a tuple of (callable, data_keyword).
 .pipe will route the DataFrame to the argument specified in the tuple.
\end_layout

\begin_layout Standard
For example, we can fit a regression using statsmodels.
 Their API expects a formula first and a DataFrame as the second argument,
 data.
 We pass in the function, keyword pair (sm.poisson, 'data') to pipe: (so
 'data' is a keyword argument of sm.position, thought not the first argument;
 thus the last step's result will be piped to the data argument)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [125]: import statsmodels.formula.api as sm
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [126]: bb = pd.read_csv('data/baseball.csv', index_col='id')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [127]: (bb.query('h > 0')
\end_layout

\begin_layout Plain Layout

   .....:    .assign(ln_h = lambda df: np.log(df.h))
\end_layout

\begin_layout Plain Layout

   .....:    .pipe((sm.poisson, 'data'), 'hr ~ ln_h + year + g + C(lg)')
\end_layout

\begin_layout Plain Layout

   .....:    .fit()
\end_layout

\begin_layout Plain Layout

   .....:    .summary()
\end_layout

\begin_layout Plain Layout

   .....: )
\end_layout

\begin_layout Plain Layout

   .....:
\end_layout

\end_inset


\end_layout

\begin_layout Section
apply
\end_layout

\begin_layout Itemize
Not like R, most Python functions cannot deal with series, they can only
 deal with element.
 So that is the place you need
\family typewriter
apply
\end_layout

\begin_layout Itemize
Arbitrary functions can be applied along the axes of a DataFrame or Panel
 using the apply() method, which, like the descriptive statistics methods,
 take an optional axis argument:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [128]: df.apply(np.mean)
\end_layout

\begin_layout Plain Layout

Out[128]:
\end_layout

\begin_layout Plain Layout

one     -0.251274
\end_layout

\begin_layout Plain Layout

three    0.469799
\end_layout

\begin_layout Plain Layout

two     -0.191421
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [129]: df.apply(np.mean, axis=1)
\end_layout

\begin_layout Plain Layout

Out[129]:
\end_layout

\begin_layout Plain Layout

a   -0.489066
\end_layout

\begin_layout Plain Layout

b    0.273355
\end_layout

\begin_layout Plain Layout

c    0.008348
\end_layout

\begin_layout Plain Layout

d    0.011457
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
apply with addtional arguments
\end_layout

\begin_layout Standard
Series.apply(func, convert_dtype=True, args=(), **kwds)
\end_layout

\begin_layout Standard
Parameters:
\end_layout

\begin_layout Itemize
func : function
\end_layout

\begin_deeper
\begin_layout Itemize
convert_dtype : boolean, default True: Try to find better dtype for elementwise
 function results.
 If False, leave as dtype=object
\end_layout

\begin_layout Itemize
args :
\series bold
tuple
\series default
: Positional arguments to pass to function in addition to the value
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
note that one element tuple is (element,) not (element), to let Python know
 it is a tuple rather than instance itself
\end_layout

\end_deeper
\begin_layout Itemize
Additional keyword arguments will be passed as keywords to the function
\end_layout

\end_deeper
\begin_layout Itemize
Returns:
\end_layout

\begin_deeper
\begin_layout Itemize
y : Series or DataFrame if func returns a Series
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

def subtract_and_divide(x, sub, divide=1):
\end_layout

\begin_layout Plain Layout

    return (x - sub) / divide
\end_layout

\begin_layout Plain Layout

#Since not all functions can be vectorized (accept NumPy arrays and return
 another array or value),
\end_layout

\begin_layout Plain Layout

# the methods applymap() on DataFrame and analogously map() on Series accept
 any Python function
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

df.apply(subtract_and_divide, args=(5,), divide=3)
\end_layout

\begin_layout Plain Layout

# note that one element tuple is (element,) not (element), to let Python
 know it is a tuple rather than instance itself
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Applying elementwise Python functions: pd
\end_layout

\begin_layout Subsection
SeriesA.map(function): apply function to each element
\end_layout

\begin_layout Standard
Since not all functions can be vectorized (accept NumPy arrays and return
 another array or value), the methods
\series bold
applymap()
\series default
 on DataFrame and analogously
\series bold
map()
\series default
 on Series accept any Python function taking a single value and returning
 a single value.
 For example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [137]: df4
\end_layout

\begin_layout Plain Layout

Out[137]:
\end_layout

\begin_layout Plain Layout

one three two
\end_layout

\begin_layout Plain Layout

a -0.626544 NaN -0.351587
\end_layout

\begin_layout Plain Layout

b -0.138894 -0.177289 1.136249
\end_layout

\begin_layout Plain Layout

c 0.011617 0.462215 -0.448789
\end_layout

\begin_layout Plain Layout

d NaN 1.124472 -1.101558
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [138]: f = lambda x: len(str(x))
\end_layout

\begin_layout Plain Layout

In [139]: df4['one'].map(f)
\end_layout

\begin_layout Plain Layout

Out[139]:
\end_layout

\begin_layout Plain Layout

a 14
\end_layout

\begin_layout Plain Layout

b 15
\end_layout

\begin_layout Plain Layout

c 15
\end_layout

\begin_layout Plain Layout

d 3
\end_layout

\begin_layout Plain Layout

Name: one, dtype: int64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [140]: df4.applymap(f)
\end_layout

\begin_layout Plain Layout

Out[140]:
\end_layout

\begin_layout Plain Layout

one three two
\end_layout

\begin_layout Plain Layout

a 14 3 15
\end_layout

\begin_layout Plain Layout

b 15 15 11
\end_layout

\begin_layout Plain Layout

c 15 14 15
\end_layout

\begin_layout Plain Layout

d 3 13 14
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SeriesA.map(SeriesB): replace A's value with B's index.
\end_layout

\begin_layout Standard
Series.map() has an additional feature which is that it can be used to easily
 “link” or “map” values defined by a secondary series.
 This is closely related to merging/joining functionality:
\end_layout

\begin_layout Itemize
A and B are both series.
\end_layout

\begin_layout Itemize
A.map(B): replace A's value with B's index.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [141]: A = pd.Series(['six', 'seven', 'six', 'seven', 'six'],
\end_layout

\begin_layout Plain Layout

.....:                     index=['a', 'b', 'c', 'd', 'e'])
\end_layout

\begin_layout Plain Layout

.....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [143]: A
\end_layout

\begin_layout Plain Layout

Out[143]:
\end_layout

\begin_layout Plain Layout

a six
\end_layout

\begin_layout Plain Layout

b seven
\end_layout

\begin_layout Plain Layout

c six
\end_layout

\begin_layout Plain Layout

d seven
\end_layout

\begin_layout Plain Layout

e six
\end_layout

\begin_layout Plain Layout

dtype: object
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [142]: B = pd.Series({'six' : 6., 'seven' : 7.})
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [144]: A.map(B)
\end_layout

\begin_layout Plain Layout

Out[144]:
\end_layout

\begin_layout Plain Layout

a 6.0
\end_layout

\begin_layout Plain Layout

b 7.0
\end_layout

\begin_layout Plain Layout

c 6.0
\end_layout

\begin_layout Plain Layout

d 7.0
\end_layout

\begin_layout Plain Layout

e 6.0
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
http://www.wklken.me/posts/2015/03/03/python-base-datetime.html
\end_layout

\begin_layout Standard
Python for Data Analysis Data Wrangling with Pandas, NumPy, and IPython
 
\end_layout

\begin_layout Section
Shallow and Deep Copy
\end_layout

\begin_layout Standard
Python has a strange behaviour - in comparison with other programming languages
 - when assigning and copying simple data types like integers and strings.
 The difference between shallow and deep copying is only relevant for
\series bold
compound objects, which are objects containing other objects, like lists
 or class instances.
 
\end_layout

\begin_layout Itemize
compound/mutable objects: list, dict, set
\end_layout

\begin_layout Itemize
immutable: string, numbers, tuple.
\end_layout

\begin_layout Subsection
Changing the view in place will also change the original.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> colours1 = ["red", "green"]
\end_layout

\begin_layout Plain Layout

>>> colours2 = colours1
\end_layout

\begin_layout Plain Layout

>>> colours2[1] = "blue"
\end_layout

\begin_layout Plain Layout

>>> colours1
\end_layout

\begin_layout Plain Layout

['red', 'blue']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Reassigning the view will NOT change the original
\end_layout

\begin_layout Standard
Reassigning the view to a new instance will break the reference link between
 view and origin, which will not affect the original.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> colours1 = ["red", "green"]
\end_layout

\begin_layout Plain Layout

>>> colours2 = colours1
\end_layout

\begin_layout Plain Layout

>>> colours2 = ["rouge", "vert"]
\end_layout

\begin_layout Plain Layout

>>> print colours1
\end_layout

\begin_layout Plain Layout

['red', 'green']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Force Copy by slicing: a shallow copy
\end_layout

\begin_layout Itemize
It's possible to completely copy shallow list structures with the slice
 operator without having any of the side effects, which we have described
 above:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> list1 = ['a','b','c','d']
\end_layout

\begin_layout Plain Layout

>>> list2 = list1[:]
\end_layout

\begin_layout Plain Layout

>>> list2[1] = 'x'
\end_layout

\begin_layout Plain Layout

>>> print list2
\end_layout

\begin_layout Plain Layout

['a', 'x', 'c', 'd']
\end_layout

\begin_layout Plain Layout

>>> print list1
\end_layout

\begin_layout Plain Layout

['a', 'b', 'c', 'd']
\end_layout

\begin_layout Plain Layout

>>>
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
But as soon as a list contains sublists, we have the same difficulty, i.e.
 just pointers to the sublists.
 If you assign a new value to the 0th Element of one of the two lists, there
 will be no side effect.
 Problems arise, if you change one of the elements of the sublist.
\end_layout

\begin_deeper
\begin_layout Itemize
This is because copying by slicing all rows is a shallow copy: Shallow copies
 duplicate as little as possible.
 A shallow copy of a collection is a copy of the collection structure, not
 the elements.
 With a shallow copy, two collections now share the individual elements.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> lst1 = ['a','b',['ab','ba']]
\end_layout

\begin_layout Plain Layout

>>> lst2 = lst1[:]
\end_layout

\begin_layout Plain Layout

>>> lst2[0] = 'c'
\end_layout

\begin_layout Plain Layout

>>> lst2[2][1] = 'd'
\end_layout

\begin_layout Plain Layout

>>> print(lst1)
\end_layout

\begin_layout Plain Layout

['a', 'b', ['ab', 'd']]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
shallow copy from the Module copy
\end_layout

\begin_layout Itemize
Shallow copies duplicate as little as possible.
 A shallow copy of a collection is a copy of the collection structure, not
 the elements.
 With a shallow copy, two collections now share the individual elements.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

lst1 = ['a','b',['ab','ba']]
\end_layout

\begin_layout Plain Layout

lst2 = copy(lst1)
\end_layout

\begin_layout Plain Layout

lst2[0] = 'c'
\end_layout

\begin_layout Plain Layout

lst2[2][1] = 'd'
\end_layout

\begin_layout Plain Layout

print(lst1) # lst1 has been changed!
\end_layout

\begin_layout Plain Layout

['a', 'b', ['ab', 'd']]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
deepcopy from the Module copy: a real copy
\end_layout

\begin_layout Standard
Deep copies duplicate everything.
 A deep copy of a collection is two collections with all of the elements
 in the original collection duplicated.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from copy import deepcopy
\end_layout

\begin_layout Plain Layout

lst1 = ['a','b',['ab','ba']]
\end_layout

\begin_layout Plain Layout

lst2 = deepcopy(lst1)
\end_layout

\begin_layout Plain Layout

lst2[2][1] = "d"
\end_layout

\begin_layout Plain Layout

lst2[0] = "c";
\end_layout

\begin_layout Plain Layout

print lst2
\end_layout

\begin_layout Plain Layout

print lst1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

['c', 'b', ['ab', 'd']]
\end_layout

\begin_layout Plain Layout

['a', 'b', ['ab', 'ba']]
\end_layout

\end_inset


\end_layout

\begin_layout Part
Scipy
\end_layout

\begin_layout Standard
The scipy package contains various toolboxes dedicated to common issues
 in scientific computing.
 Its different submodules correspond to different applications, such as
 interpolation, integration, optimization, image processing, statistics,
 special functions, etc.
\end_layout

\begin_layout Standard
scipy can be compared to other standard scientific-computing libraries,
 such as the GSL (GNU Scientific Library for C and C++), or Matlab’s toolboxes.
 scipy is the core package for scientific routines in Python; it is meant
 to operate efficiently on numpy arrays, so that numpy and scipy work hand
 in hand.
\end_layout

\begin_layout Standard
Before implementing a routine, it is worth checking if the desired data
 processing is not already implemented in Scipy.
 As non-professional programmers, scientists often tend to re-invent the
 wheel, which leads to buggy, non-optimal, difficult-to-share and unmaintainable
 code.
 By contrast, Scipy‘s routines are optimized and tested, and should therefore
 be used when possible.
\end_layout

\begin_layout Description
scipy is composed of task-specific sub-modules:
\end_layout

\begin_layout Description
scipy.cluster Vector quantization / Kmeans
\end_layout

\begin_layout Description
scipy.constants Physical and mathematical constants
\end_layout

\begin_layout Description
scipy.fftpack Fourier transform
\end_layout

\begin_layout Description
scipy.integrate Integration routines
\end_layout

\begin_layout Description
scipy.interpolate Interpolation
\end_layout

\begin_layout Description
scipy.io Data input and output
\end_layout

\begin_layout Description
scipy.linalg Linear algebra routines
\end_layout

\begin_layout Description
scipy.ndimage n-dimensional image package
\end_layout

\begin_layout Description
scipy.odr Orthogonal distance regression
\end_layout

\begin_layout Description
scipy.optimize Optimization
\end_layout

\begin_layout Description
scipy.signal Signal processing
\end_layout

\begin_layout Description
scipy.sparse Sparse matrices
\end_layout

\begin_layout Description
scipy.spatial Spatial data structures and algorithms
\end_layout

\begin_layout Description
scipy.special Any special mathematical functions
\end_layout

\begin_layout Description
scipy.stats Statistics
\end_layout

\begin_layout Subsection
Website
\end_layout

\begin_layout Itemize
http://central.scipy.org/: SciPy Central is a collection of code snippets,
 modules and links for solving scientific problems with SciPy and related
 Python tools.
\end_layout

\begin_layout Itemize
Numpy’s and Scipy’s documentations can be browsed online on http://docs.scipy.org/
doc.
 The search button is quite useful inside the reference documentation of
 the two packages (http://docs.scipy.org/doc/numpy/reference/ and http://docs.scipy.
org/doc/scipy/reference/).
\end_layout

\begin_layout Itemize
Numpy’s and Scipy’s documentation is enriched and updated on a regular basis
 by users on a wiki http://docs.scipy.org/doc/numpy/.
 As a result, some docstrings are clearer or more detailed on the wiki,
 and you may want to read directly the documentation on the wiki instead
 of the official documentation website.
 Note that anyone can create an account on the wiki and write better documentati
on; this is an easy way to contribute to an open-source project and improve
 the tools you are using!
\end_layout

\begin_layout Part
Base
\end_layout

\begin_layout Section
Python vs R
\end_layout

\begin_layout Standard
R is a language dedicated to statistics.
 Python is a general-purpose language with statistics modules.
 R has more statistical analysis features than Python, and specialized syntaxes.
 However, when it comes to building complex analysis pipelines that mix
 statistics with e.g.
 image analysis, text mining, or control of a physical experiment, the richness
 of Python is an invaluable asset.
\end_layout

\begin_layout Section
Hierarchy of codes
\end_layout

\begin_layout Standard
Modules, statements, expressions, objects
\end_layout

\begin_layout Enumerate
Programs are composed of modules.
\end_layout

\begin_layout Enumerate
Modules contain statements.
\end_layout

\begin_layout Enumerate
Statements contain expressions.
\end_layout

\begin_layout Enumerate
Expressions create and process objects.
\end_layout

\begin_layout Section
Basic Syntax
\end_layout

\begin_layout Subsection
line of code
\end_layout

\begin_layout Itemize

\series bold
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

 to squeeze lines
\end_layout

\begin_deeper
\begin_layout Standard
it is possible to squeeze more than one statement onto a single line in
 Python by separating them with semicolons:
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

a = 1; b = 2; print(a + b)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Multi-line code in loop, if ot function:
\begin_inset Quotes eld
\end_inset

:
\begin_inset Quotes erd
\end_inset

 or { }
\end_layout

\begin_layout Itemize
Multi-line for text:
\begin_inset Quotes eld
\end_inset


\backslash

\begin_inset Quotes erd
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> long_line = "Here is a very very long line
\backslash

\end_layout

\begin_layout Plain Layout

...
 that we break in two parts."
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
All Python compound statements---statements that have other statements nested
 inside them
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

Header line:
\end_layout

\begin_layout Plain Layout

    Nested statement block
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Python
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset ERT
status open

\begin_layout Plain Layout

if x   y:
\end_layout

\begin_layout Plain Layout

    x= 1
\end_layout

\begin_layout Plain Layout

    y= 2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
C:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

if (x   y) {
\end_layout

\begin_layout Plain Layout

    x = 1;
\end_layout

\begin_layout Plain Layout

    y = 2;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Parentheses are optional
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

if (x y)
\end_layout

\end_inset

 is the same as
\begin_inset ERT
status open

\begin_layout Plain Layout

if x y
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection

\series bold
Indention
\end_layout

\begin_layout Standard
Indentation is really part of Python syntax, not just a stylistic suggestion:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

	x = 'SPAM' # Error: first line indented
\end_layout

\begin_layout Plain Layout

if 'rubbery' in 'shrubbery':
\end_layout

\begin_layout Plain Layout

	print(x * 8)
\end_layout

\begin_layout Plain Layout

		x += 'NI' # Error: unexpected indentation
\end_layout

\begin_layout Plain Layout

	if x.endswith('NI'):
\end_layout

\begin_layout Plain Layout

		x *= 2
\end_layout

\begin_layout Plain Layout

	print(x) # Error: inconsistent indentation
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
End of indentation is end of block
\end_layout

\begin_deeper
\begin_layout Standard
unless you do so consistently; use tabs or spaces in a given block, but
 not both (in fact, Python 3.X now issues an error for inconsistent use of
 tabs and spaces
\end_layout

\end_deeper
\begin_layout Standard
expected an indented block
\end_layout

\begin_layout Standard
unexpected unindent
\end_layout

\begin_layout Standard
One of the unfortunate side-effects of Python's use of whitespace for denoting
 blocks is that sometimes you get scripts that have tabs and spaces mixed
 up throughout the source code.
\end_layout

\begin_layout Standard
Since this script is pretty small, you could try deleting the whitespace
 preceding each line's code and then reindent it properly.
\end_layout

\begin_layout Standard
To add to this, you can load up your code in Python's IDLE, select all your
 code and then hit Format->Untabify Region.
 After you've done that try saving your code and then try run it again.
 – Shazer2 May 19 '13 at 1:02
\end_layout

\begin_layout Subsection

\series bold
Indention
\series default
 when copy multiline code from elsewhere
\end_layout

\begin_layout Standard
usually seemingly correct code will return you error
\begin_inset Quotes eld
\end_inset

SyntaxError: invalid syntax
\begin_inset Quotes erd
\end_inset

 at the indentation place.
 Two ways to solve it
\end_layout

\begin_layout Enumerate
redo the indentation mannualy
\end_layout

\begin_layout Enumerate
copy the code to IPython first, then copy it back to source
\end_layout

\begin_layout Subsection
Pass
\end_layout

\begin_layout Standard
pass
\begin_inset space ~
\end_inset

is a null operation - when it is executed, nothing happens.
 It is useful as a placeholder when a statement is required syntactically
 (语法句法), but no code needs to be executed, for example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

for letter in 'Python':
\end_layout

\begin_layout Plain Layout

   if letter == 'h':
\end_layout

\begin_layout Plain Layout

      pass
\end_layout

\begin_layout Plain Layout

      print 'This is pass block'
\end_layout

\begin_layout Plain Layout

   print 'Current Letter :', letter
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print "Good bye!"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Current Letter : P
\end_layout

\begin_layout Plain Layout

Current Letter : y
\end_layout

\begin_layout Plain Layout

Current Letter : t
\end_layout

\begin_layout Plain Layout

This is pass block
\end_layout

\begin_layout Plain Layout

Current Letter : h
\end_layout

\begin_layout Plain Layout

Current Letter : o
\end_layout

\begin_layout Plain Layout

Current Letter : n
\end_layout

\begin_layout Plain Layout

Good bye!
\end_layout

\end_inset


\end_layout

\begin_layout Section

\change_inserted -445235034 1463279267
Run code in Ipython
\end_layout

\begin_layout Standard

\change_inserted -445235034 1463279275
Run the following code in Ipython
\end_layout

\begin_layout Standard

\change_inserted -445235034 1463279265
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\change_inserted -445235034 1463279265

%cpaste
\end_layout

\begin_layout Plain Layout

\change_inserted -445235034 1463279265

%autoindent
\change_unchanged

\end_layout

\end_inset


\end_layout

\begin_layout Standard

\change_inserted -445235034 1463278419
Direct run code into Ipython without worrying about indentation.
\end_layout

\begin_layout Section
print
\end_layout

\begin_layout Standard
print is like paste() in R with auto collapse
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[101]: print([1,2],'a')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

([1, 2], 'a')
\end_layout

\end_inset


\end_layout

\begin_layout Section
Assignment Statement 多种等于号
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interpretation
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
spam = 'Spam'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Basic form
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
spam, ham = 'yum', 'YUM'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Tuple assignment (positional)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
[spam, ham] = ['yum', 'YUM']
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
List assignment (positional)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
a, b, c, d = 'spam'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Sequence assignment, generalized
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
a, *b = 'spam'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Extended sequence unpacking (Python 3.X)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
spam = ham = 'lunch'
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Multiple-target assignment
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
spams += 42
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Augmented assignment (equivalent to spams = spams + 42)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection

\series bold
sequence assignment
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

string = 'SPAM'â¨
\end_layout

\begin_layout Plain Layout

a, b, c, d = string
\end_layout

\begin_layout Plain Layout

a, d
\end_layout

\begin_layout Plain Layout

    # â¨('S', 'M')
\end_layout

\begin_layout Plain Layout

a, b, c = stringâ¨
\end_layout

\begin_layout Plain Layout

    # ...error text omitted...
\end_layout

\end_inset

We can even assign nested sequences, and Python unpacks their parts according
 to their shape, as expected.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

((a, b), c) = ('SP', 'AM') # Paired by shape and position
\end_layout

\begin_layout Plain Layout

 a, b, c
\end_layout

\begin_layout Plain Layout

# ('S', 'P', 'AM')
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Multiple-target assignment and shared references
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

a = b = 0
\end_layout

\begin_layout Plain Layout

b = b + 1
\end_layout

\begin_layout Plain Layout

a, b
\end_layout

\begin_layout Plain Layout

# (0, 1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As long as the object assigned is immutable, it's irrelevant if more than
 one name references it.
\end_layout

\begin_layout Subsection
Special, *rest = List Extended sequence unpacking: In Python 3.X (only):
\end_layout

\begin_layout Standard
The fifth line in Table 11-1, for example, matches a with the first character
 in the string on the right and b with the rest: a is assigned 's', and
 b is assigned 'pam'.
\end_layout

\begin_layout Standard
Basic Syntax
\end_layout

\begin_layout Standard
Special, *rest = List
\end_layout

\begin_layout Itemize
*rest will always has the format of list.
 If nothing left, then empty list.
 
\end_layout

\begin_layout Itemize
Can only have one *rest, not two or more
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

a, *b = [1, 2, 3, 4]
\end_layout

\begin_layout Plain Layout

a
\end_layout

\begin_layout Plain Layout

# 1
\end_layout

\begin_layout Plain Layout

b
\end_layout

\begin_layout Plain Layout

# [2, 3, 4]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When a starred name is used, the number of items in the target on the left
 need not match the length of the subject sequence.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

a, *b, c = seq
\end_layout

\begin_layout Plain Layout

a
\end_layout

\begin_layout Plain Layout

# 1
\end_layout

\begin_layout Plain Layout

b
\end_layout

\begin_layout Plain Layout

# [2, 3]
\end_layout

\begin_layout Plain Layout

# c
\end_layout

\begin_layout Plain Layout

4
\end_layout

\end_inset


\end_layout

\begin_layout Standard
whichever *rest appears, it will be assigned to the rest of the part after
 assigning its previous and after objects.
\end_layout

\begin_layout Subsection
spam += 42 Augmented assignments
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

spam += 42
\end_layout

\end_inset

, for example, has the same effect as
\begin_inset ERT
status open

\begin_layout Plain Layout

spam = spam + 42
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 11-2.
 Augmented assignment statements
\end_layout

\begin_layout Itemize
X += Y
\end_layout

\begin_layout Itemize
X &= Y
\end_layout

\begin_layout Itemize
X −= Y
\end_layout

\begin_layout Itemize
X |= Y
\end_layout

\begin_layout Itemize
X *= Y
\end_layout

\begin_layout Itemize
X ^= Y
\end_layout

\begin_layout Itemize
X /= Y
\end_layout

\begin_layout Itemize
X >>= Y
\end_layout

\begin_layout Itemize
X %= Y
\end_layout

\begin_layout Itemize
X <<= Y
\end_layout

\begin_layout Itemize
X **= Y
\end_layout

\begin_layout Itemize
X //= Y
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

S = "spam"
\end_layout

\begin_layout Plain Layout

S += "SPAM" # Implied concatenation
\end_layout

\begin_layout Plain Layout

S
\end_layout

\begin_layout Plain Layout

# 'spamSPAM'
\end_layout

\end_inset


\end_layout

\begin_layout Section
Logical
\end_layout

\begin_layout Standard
python
\family typewriter
 uses
\family default
 and
\family typewriter
or
\family default
; there is no
\family typewriter
 & | && ||
\family default
 in python
\end_layout

\begin_layout Standard
not means !
\end_layout

\begin_layout Description
== If the values of two operands are equal, then the condition becomes true.
 (a == b) is not true.
\end_layout

\begin_layout Description
!= If values of two operands are not equal, then condition becomes true.
\end_layout

\begin_layout Description
> If values of two operands are not equal, then condition becomes true.
 (a > b) is true.
 This is similar to != operator.
\end_layout

\begin_layout Description
> If the value of left operand is greater than the value of right operand,
 then condition becomes true.
 (a > b) is not true.
\end_layout

\begin_layout Description
If the value of left operand is less than the value of right operand, then
 condition becomes true.
 (a b) is true.
\end_layout

\begin_layout Description
>= If the value of left operand is greater than or equal to the value of
 right operand, then condition becomes true.
 (a >= b) is not true.
\end_layout

\begin_layout Description
= If the value of left operand is less than or equal to the value of right
 operand, then condition becomes true.
 (a = b) is true.
 
\end_layout

\begin_layout Itemize
a == b:
\end_layout

\begin_deeper
\begin_layout Standard
Tests equality, with logics:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>
\end_layout

\begin_layout Plain Layout

>>> 1 == 1.
\end_layout

\begin_layout Plain Layout

True
\end_layout

\begin_layout Plain Layout

a is b:
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
is: Tests identity: both sides are the same object:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>
\end_layout

\begin_layout Plain Layout

>>> 1 is 1.
\end_layout

\begin_layout Plain Layout

False
\end_layout

\begin_layout Plain Layout

>>> a = 1
\end_layout

\begin_layout Plain Layout

>>> b = 1
\end_layout

\begin_layout Plain Layout

>>> a is b
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
True is 1, False is 0.
 can be used in calculation
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[45]: True == 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[45]: True
\end_layout

\begin_layout Plain Layout

In[46]: False == 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[46]: True
\end_layout

\end_inset


\end_layout

\begin_layout Standard
But in pd.Series, + or - still works, but 
\end_layout

\begin_layout Section
Comments
\end_layout

\begin_layout Itemize
single line: # 
\end_layout

\begin_layout Itemize
You can use triple-quoted strings.
 When they're not a docstring (first thing in a class/function/module),
 they are ignored.
\end_layout

\begin_layout Itemize
''' This is a multiline comment.
 ''' Guido van Rossum (creator of Python) tweeted this as a "pro tip".
\end_layout

\begin_layout Section
Code Block Rules
\end_layout

\begin_layout Itemize
begin 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# <editor-fold desc="Description ======== "> 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
end: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

# </editor-fold> 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When the code blocks do not work, most likely it is becuase there is synsatic
 bugs inside the blocks.
\end_layout

\begin_layout Standard
Or it is affected by other comments, so we suggest you use ''' ...
 ''' for comments!
\end_layout

\begin_layout Section
Reserved Words
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

False class finally is return
\end_layout

\begin_layout Plain Layout

None continue for lambda try
\end_layout

\begin_layout Plain Layout

True def from nonlocal while
\end_layout

\begin_layout Plain Layout

and del global not with
\end_layout

\begin_layout Plain Layout

as elif if or yield
\end_layout

\begin_layout Plain Layout

assert else import pass
\end_layout

\begin_layout Plain Layout

break except in raise
\end_layout

\end_inset


\end_layout

\begin_layout Section
Opreators
\end_layout

\begin_layout Standard
Table 5-2.
 Python expression operators and precedence
\end_layout

\begin_layout Itemize

\family typewriter
yield x
\family default
 Generator function send protocol
\end_layout

\begin_layout Itemize

\family typewriter
lambda args
\family default
: expression Anonymous function generation
\end_layout

\begin_layout Itemize

\family typewriter
x if y else z
\family default
 Ternary selection (x is evaluated only if y is true)
\end_layout

\begin_layout Itemize

\family typewriter
x or y
\family default
 Logical OR (y is evaluated only if x is false)
\end_layout

\begin_layout Itemize

\family typewriter
x and y
\family default
 Logical AND (y is evaluated only if x is true)
\end_layout

\begin_layout Itemize

\family typewriter
not x
\family default
 Logical negation
\end_layout

\begin_layout Itemize

\family typewriter
x in y, x not in y
\family default
 Membership (iterables, sets)
\end_layout

\begin_layout Itemize

\family typewriter
x is y, x is not y
\family default
 Object identity tests
\end_layout

\begin_layout Itemize

\family typewriter
x < y, x <= y, x > y, x >= y
\end_layout

\begin_layout Itemize

\family typewriter
x == y, x != y
\end_layout

\begin_deeper
\begin_layout Itemize
Magnitude comparison, set subset and superset;
\end_layout

\begin_layout Itemize
Value equality operators
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
\series bold
x | y
\family default
\series default
 Bitwise OR, set union
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
x ^ y
\family default
\series default
Bitwise XOR, set symmetric difference
\end_layout

\begin_layout Itemize

\family typewriter
\series bold
x & y
\family default
\series default
 Bitwise AND, set intersection
\end_layout

\begin_layout Itemize

\family typewriter
x << y, x >> y
\family default
 Shift x left or right by y bits
\end_layout

\begin_layout Itemize

\family typewriter
x + y ; x – y
\end_layout

\begin_deeper
\begin_layout Itemize
Addition, concatenation;
\end_layout

\begin_layout Itemize
Subtraction, set difference
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
x * y; x % y; x / y, x // y
\end_layout

\begin_deeper
\begin_layout Itemize
Multiplication, repetition;
\end_layout

\begin_layout Itemize
Remainder, format;
\end_layout

\begin_layout Itemize
Division: true and floor
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
−x, +x
\family default
 Negation, identity
\end_layout

\begin_layout Itemize

\family typewriter
˜x
\family default
 Bitwise NOT (inversion)
\end_layout

\begin_layout Itemize

\family typewriter
x ** y
\family default
 Power (exponentiation)
\end_layout

\begin_layout Itemize

\family typewriter
x[i]
\family default
 Indexing (sequence, mapping, others)
\end_layout

\begin_layout Itemize

\family typewriter
x[i:j:k
\family default
] Slicing
\end_layout

\begin_layout Itemize

\family typewriter
x(...)
\family default
 Call (function, method, class, other callable)
\end_layout

\begin_layout Itemize

\family typewriter
x.attr
\family default
 Attribute reference
\end_layout

\begin_layout Itemize

\family typewriter
(...)
\family default
 Tuple, expression, generator expression
\end_layout

\begin_layout Itemize

\family typewriter
[...]
\family default
 List, list comprehension
\end_layout

\begin_layout Itemize

\family typewriter
{...}
\family default
 Dictionary, set, set and dictionary comprehensions
\end_layout

\begin_layout Part
NA, NULL
\end_layout

\begin_layout Subsection
None: placeholder
\end_layout

\begin_layout Itemize
None is the python-wide placeholder.
\end_layout

\begin_layout Itemize
None is frequently used to represent the absence of a value, as when default
 arguments are not passed to a function.
\end_layout

\begin_layout Itemize
A special placeholder object called [None] commonly used to initialize names
 and objects:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

L = [None] * 100
\end_layout

\begin_layout Plain Layout

L
\end_layout

\begin_layout Plain Layout

[None, None, None, None, None, None, None, None, None, None, None, None,
 None, None, None, None, None, None, None, None, ...a list of 100 Nones...]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
np.nan and None are the smallest numbers
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[227]: max([1,2,3],[0,33,np.nan])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[226]: [1, 2, 3]
\end_layout

\begin_layout Plain Layout

In[228]: max([1,2,3],[0,33,None])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[227]: [1, 2, 3]
\end_layout

\end_inset


\end_layout

\begin_layout Section
in np and pandas
\end_layout

\begin_layout Subsection
np.NaN : NA values for both numeric and character, also used in Pandas
\end_layout

\begin_layout Standard
Warning
\end_layout

\begin_layout Standard
One has to be mindful that in python (and numpy), the nan's don’t compare
 equal, but None's do.
 Note that Pandas/numpy uses the fact that np.nan != np.nan, and treats None
 like np.nan.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [11]: None == None
\end_layout

\begin_layout Plain Layout

Out[11]: True
\end_layout

\begin_layout Plain Layout

In [12]: np.nan == np.nan
\end_layout

\begin_layout Plain Layout

Out[12]: False
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
cacluation on NaN
\end_layout

\begin_layout Itemize
When summing data, NA (missing) values will be treated as zero
\end_layout

\begin_layout Itemize
If the data are all NA, the result will be NA
\end_layout

\begin_layout Itemize
Methods like cumsum and cumprod ignore NA values, but preserve them in the
 resulting arrays
\end_layout

\begin_layout Itemize
NA groups in GroupBy are automatically excluded.
\end_layout

\begin_layout Section
decide whehter nonsense: 
\family typewriter
pd.isnull()
\end_layout

\begin_layout Standard

\family typewriter
pd.isnull()
\family default
 is most reliable and can be used in series 
\end_layout

\begin_layout Standard

\family typewriter
x is None or x is np.nan
\family default
 is not reliable
\end_layout

\begin_layout Section
fill or drop
\end_layout

\begin_layout Subsection
pandas: drop rows with missing value
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

f2.dropna()
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
fill missing value - pd.fillna( value ) or Series.fillna( value )
\end_layout

\begin_layout Itemize
pd.fillna( value ) will replace NA in the whole DataFrame by the 'value'
 for
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [39]: df
\end_layout

\begin_layout Plain Layout

Out[39]:
\end_layout

\begin_layout Plain Layout

        one       two     three
\end_layout

\begin_layout Plain Layout

a       NaN -0.282863 -1.509059
\end_layout

\begin_layout Plain Layout

c       NaN  1.212112 -0.173215
\end_layout

\begin_layout Plain Layout

e  0.119209 -1.044236 -0.861849
\end_layout

\begin_layout Plain Layout

f -2.104569 -0.494929  1.071804
\end_layout

\begin_layout Plain Layout

h       NaN -0.706771 -1.039575
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [40]: df.fillna(method='pad')
\end_layout

\begin_layout Plain Layout

Out[40]:
\end_layout

\begin_layout Plain Layout

        one       two     three
\end_layout

\begin_layout Plain Layout

a       NaN -0.282863 -1.509059
\end_layout

\begin_layout Plain Layout

c       NaN  1.212112 -0.173215
\end_layout

\begin_layout Plain Layout

e  0.119209 -1.044236 -0.861849
\end_layout

\begin_layout Plain Layout

f -2.104569 -0.494929  1.071804
\end_layout

\begin_layout Plain Layout

h -2.104569 -0.706771 -1.039575
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Series.fillna( value )
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [14]: df3 = df.copy()
\end_layout

\begin_layout Plain Layout

In [15]: mean = df3['float_col'].mean()
\end_layout

\begin_layout Plain Layout

In [16]: df3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[16]:
\end_layout

\begin_layout Plain Layout

float_col int_col str_col
\end_layout

\begin_layout Plain Layout

0 0.1 1 a
\end_layout

\begin_layout Plain Layout

1 0.2 2 b
\end_layout

\begin_layout Plain Layout

2 0.2 6 None
\end_layout

\begin_layout Plain Layout

3 10.1 8 c
\end_layout

\begin_layout Plain Layout

4 NaN -1 a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [17]: df3['float_col'].fillna(mean)
\end_layout

\begin_layout Plain Layout

Out[17]:
\end_layout

\begin_layout Plain Layout

0 0.10
\end_layout

\begin_layout Plain Layout

1 0.20
\end_layout

\begin_layout Plain Layout

2 0.20
\end_layout

\begin_layout Plain Layout

3 10.10
\end_layout

\begin_layout Plain Layout

4 2.65
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
fill missing in time series / ordered data
\end_layout

\begin_layout Itemize
pad / ffill Fill values forward
\end_layout

\begin_layout Itemize
bfill / backfill Fill values backward
\end_layout

\begin_layout Subsection
Interpolation: interpolate()
\end_layout

\begin_layout Standard

\family typewriter
df.interpolate(method='spline', order=2)
\end_layout

\begin_layout Standard

\family typewriter
etc....
\end_layout

\begin_layout Part
Math and Numerics
\end_layout

\begin_layout Section
Basics
\end_layout

\begin_layout Subsection
Calculation
\end_layout

\begin_layout Itemize
x% y： reminder (if -3 % 10 then result would be 7)
\end_layout

\begin_layout Itemize
x ** y: power
\end_layout

\begin_layout Itemize
x // y: like floor in SQL this operator always truncates fractional remainders
 down to their floor,
\end_layout

\begin_layout Itemize

\series bold
floor
\series default
 method
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import math
\end_layout

\begin_layout Plain Layout

>>> math.floor(2.5)
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

 >>> math.floor(-2.5)
\end_layout

\begin_layout Plain Layout

-3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> import math
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> math.sqrt(85)
\end_layout

\begin_layout Plain Layout

9.219544457292887
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
pi:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> math.pi
\end_layout

\begin_layout Plain Layout

3.141592653589793
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
square
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> math.sqrt(85)
\end_layout

\begin_layout Plain Layout

9.219544457292887
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
range: a continuous series of numbers : return a list
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> list(range(5)), list(range(2, 5)), list(range(0, 10, 2))
\end_layout

\begin_layout Plain Layout

([0, 1, 2, 3, 4], [2, 3, 4], [0, 2, 4, 6, 8])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
尝试使用 range()创建整数列表（导致“TypeError: 'range' object does not support item assignment
”）
\end_layout

\begin_layout Standard
有时你想要得到一个有序的整数列表，所以 range() 看上去是生成此列表的不错方式。然而，你需要记住 range() 返回的是 “range
 object”，而不是实际的 list 值。
\end_layout

\begin_layout Standard
该错误发生在如下代码中：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

spam = range(10)
\end_layout

\begin_layout Plain Layout

spam[4] = -1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
也许这才是你想做：
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

spam = list(range(10))
\end_layout

\begin_layout Plain Layout

spam[4] = -1
\end_layout

\end_inset


\end_layout

\begin_layout Standard
（注意：在 Python 2 中 spam = range(10) 是能行的，因为在 Python 2 中 range() 返回的是list值，但是在
 Python 3 中就会产生以上错误）
\end_layout

\begin_layout Section
Decimal /Fraction / Integers
\end_layout

\begin_layout Subsection
make to integer
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> math.floor(2.567), math.floor(-2.567)
\end_layout

\begin_layout Plain Layout

(2, −3)
\end_layout

\begin_layout Plain Layout

>>> math.trunc(2.567), math.trunc(−2.567)
\end_layout

\begin_layout Plain Layout

(2, −2)
\end_layout

\begin_layout Plain Layout

>>> int(2.567), int(−2.567)
\end_layout

\begin_layout Plain Layout

(2, −2)
\end_layout

\begin_layout Plain Layout

>>> round(2.567), round(2.467), round(2.567, 2)
\end_layout

\begin_layout Plain Layout

(3, 2, 2.57)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Floating-point math is less than exact because of the limited space used
 to store values.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> 0.1 + 0.1 + 0.1 - 0.3 # Python 3.3
\end_layout

\begin_layout Plain Layout

5.551115123125783e-17
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Decimal modual
\end_layout

\begin_layout Itemize

\series bold
Decimal(string_input)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> from decimal import Decimal 
\end_layout

\begin_layout Plain Layout

>>> Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
\end_layout

\begin_layout Plain Layout

Decimal('0.0')
\end_layout

\begin_layout Plain Layout

>>> Decimal('0.1') + Decimal('0.10') + Decimal('0.10') - Decimal('0.30')
\end_layout

\begin_layout Plain Layout

Decimal('0.00')
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Fixed Precision for decimal module
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> decimal.getcontext().prec = 4
\end_layout

\begin_layout Plain Layout

 >>> decimal.Decimal(1) / decimal.Decimal(7)
\end_layout

\begin_layout Plain Layout

Decimal('0.1429')
\end_layout

\begin_layout Plain Layout

>>> Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3)
\end_layout

\begin_layout Plain Layout

Decimal('1.110E-17')
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Fraction module: math functions
\series default
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> decimal.getcontext().prec = 4
\end_layout

\begin_layout Plain Layout

 >>> decimal.Decimal(1) / decimal.Decimal(7)
\end_layout

\begin_layout Plain Layout

Decimal('0.1429')
\end_layout

\begin_layout Plain Layout

>>> Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3)
\end_layout

\begin_layout Plain Layout

Decimal('1.110E-17')
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Convert fraction - float-point system
\series default
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x=Fraction(1, 3)
\end_layout

\begin_layout Plain Layout

float(x)
\end_layout

\begin_layout Plain Layout

0.3333333333333333
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Precision
\end_layout

\begin_layout Standard
Python 3.X's integer type automatically provides extra precision for large
 numbers like this when needed (in 2.X, a separate long integer type handles
 numbers too large for the normal integer type in similar ways).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>  2 ** 100
\end_layout

\begin_layout Plain Layout

1267650600228229401496703205376
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Format (number of decimals )
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> num = 1 / 3.0
\end_layout

\begin_layout Plain Layout

>>> '%e' % num  #output is string
\end_layout

\begin_layout Plain Layout

'3.333333e-01' 
\end_layout

\begin_layout Plain Layout

>>> '%4.2f' % num  #output is string
\end_layout

\begin_layout Plain Layout

'0.33'
\end_layout

\begin_layout Plain Layout

# String formatting method: Python 2.6, 3.0, and later
\end_layout

\begin_layout Plain Layout

>>> '{0:4.2f}'.format(num)
\end_layout

\begin_layout Plain Layout

'0.33'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Print Behavior
\end_layout

\begin_layout Itemize
With full precision (as in the first result shown here)
\end_layout

\begin_layout Standard
\SpecialChar \textcompwordmark{}

\begin_inset ERT
status open

\begin_layout Plain Layout

>>> 3.1415 * 2 # repr: as code (Pythons 2.7 and 3.1)
\end_layout

\begin_layout Plain Layout

6.2830000000000004 
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
In a user-friendly form (as in the second).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> print(3.1415 * 2) # str: user-friendly 6.283
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Print precision according to input
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>  10 // 4
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

>>>  10 // 4.0
\end_layout

\begin_layout Plain Layout

2.0
\end_layout

\end_inset


\end_layout

\begin_layout Section
Other Numeric Formats
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

bool
\begin_inset Quotes erd
\end_inset

 class: Booleans
\end_layout

\begin_layout Standard
Predefined True and False objects that are essentially just the integers
 1 and 0 with custom display logic)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

bool(X), True, False
\end_layout

\begin_layout Plain Layout

>>> True + 4
\end_layout

\begin_layout Plain Layout

 5
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Hexadecimal, octal, and binary literals
\end_layout

\begin_layout Standard
Integers may be coded in decimal (base 10), hexadecimal (base 16), octal
 (base 8), or binary (base 2), the last three of which are common in some
 programming do- mains.
\end_layout

\begin_layout Itemize
Hexadecimals start with a leading 0x or 0X, followed by a string of hexa-
 decimal digits (0--9 and A--F).
 
\end_layout

\begin_layout Itemize
Octal literals start with a leading 0o or 0O (zero and lower- or uppercase
 letter o), followed by a string of digits (0--7).
 
\end_layout

\begin_layout Itemize
Binary literals, new as of 2.6 and 3.0, begin with a leading 0b or 0B, followed
 by binary digits (0--1).
 
\end_layout

\begin_layout Standard
Relation with normal integer type
\end_layout

\begin_layout Standard
Note that all of these literals produce integer objects in program code;
 they are just alternative syntaxes for specifying values.
\end_layout

\begin_layout Standard
The built-in calls
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

hex(I), oct(I), and bin(I)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
convert an integer to its representation string in these three bases, and
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

int(str, base)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
converts a runtime string to an integer per a given base.
\end_layout

\begin_layout Subsection
Complex Number
\end_layout

\begin_layout Standard
complex(
\emph on
real
\emph default
,
\emph on
imag
\emph default
)
\end_layout

\begin_layout Standard
3+4j, 3.0+4.0j, 3J
\end_layout

\begin_layout Section
Random Numbers
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

n_samples, n_features = 10, 5
\end_layout

\begin_layout Plain Layout

# sample a matrix with x rows and y
\end_layout

\begin_layout Plain Layout

X = np.random.randn(n_samples, n_features)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Random Generator: random modual
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

import random
\end_layout

\begin_layout Plain Layout

random.random()
\end_layout

\begin_layout Plain Layout

0.5566014960423105
\end_layout

\begin_layout Plain Layout

random.random()
\end_layout

\begin_layout Plain Layout

0.051308506597373515
\end_layout

\begin_layout Plain Layout

random.randint(1, 10)
\end_layout

\begin_layout Plain Layout

5
\end_layout

\begin_layout Plain Layout

random.randint(1, 10)
\end_layout

\begin_layout Plain Layout

9
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Random Choice and Shuffle
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>> random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life'])
\end_layout

\begin_layout Plain Layout

'Holy Grail'
\end_layout

\begin_layout Plain Layout

 >>> random.choice(['Life of Brian', 'Holy Grail', 'Meaning of Life'])
\end_layout

\begin_layout Plain Layout

'Life of Brian'
\end_layout

\begin_layout Plain Layout

>>> suits = ['hearts', 'clubs', 'diamonds', 'spades']
\end_layout

\begin_layout Plain Layout

>>> random.shuffle(suits)
\end_layout

\begin_layout Plain Layout

 >>> suits
\end_layout

\begin_layout Plain Layout

 ['spades', 'hearts', 'diamonds', 'clubs']
\end_layout

\begin_layout Plain Layout

>>> random.shuffle(suits) 
\end_layout

\begin_layout Plain Layout

>>> suits
\end_layout

\begin_layout Plain Layout

 ['clubs', 'diamonds', 'hearts', 'spades']
\end_layout

\end_inset


\end_layout

\begin_layout Part
np.array([])
\end_layout

\begin_layout Itemize
Numpy is like the sequence in R
\end_layout

\begin_deeper
\begin_layout Itemize
Why it is useful: Memory-efficient container that provides fast numerical
 operations.
 
\end_layout

\begin_layout Itemize
It has
\end_layout

\end_deeper
\begin_layout Itemize
syntax: created from
\family typewriter
list[]
\family default
 with function
\family typewriter
np.array()
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import numpy as np
\end_layout

\begin_layout Plain Layout

>>> a = np.array([0, 1, 2, 3])
\end_layout

\begin_layout Plain Layout

>>> a
\end_layout

\begin_layout Plain Layout

array([0, 1, 2, 3])
\end_layout

\end_inset


\end_layout

\begin_layout Section
dynamic class
\end_layout

\begin_layout Itemize
dynamic class
\end_layout

\begin_layout Section
Basics
\end_layout

\begin_layout Subsection
dimentions: .dim() / .shape()
\end_layout

\begin_layout Subsection
2d/3d arrary ([ [...],[...] ])
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> b = np.array([[0, 1, 2], [3, 4, 5]])    # 2 x 3 array
\end_layout

\begin_layout Plain Layout

>>> b
\end_layout

\begin_layout Plain Layout

array([[0, 1, 2],
\end_layout

\begin_layout Plain Layout

       [3, 4, 5]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> b.ndim
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

>>> b.shape
\end_layout

\begin_layout Plain Layout

(2, 3)
\end_layout

\begin_layout Plain Layout

>>> len(b)     # returns the size of the first dimension
\end_layout

\begin_layout Plain Layout

2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
slicer in multi-dimentional array
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a = np.diag(np.arange(3))
\end_layout

\begin_layout Plain Layout

>>> a
\end_layout

\begin_layout Plain Layout

array([[0, 0, 0],
\end_layout

\begin_layout Plain Layout

       [0, 1, 0],
\end_layout

\begin_layout Plain Layout

       [0, 0, 2]])
\end_layout

\begin_layout Plain Layout

>>> a[1, 1]
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

>>> a[1]
\end_layout

\begin_layout Plain Layout

array([0, 1, 0])
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
range of arrary
\end_layout

\begin_layout Itemize
np.arange(1, 9, 2) # start, end (exclusive), step
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a = np.arange(10) # 0 ..
 n-1 (!)
\end_layout

\begin_layout Plain Layout

>>> a
\end_layout

\begin_layout Plain Layout

array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) # there is no 10
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> b = np.arange(1, 9, 2) # start, end (exclusive), step
\end_layout

\begin_layout Plain Layout

>>> b
\end_layout

\begin_layout Plain Layout

array([1, 3, 5, 7])
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
np.linspace(0, 1, 6) # start, end, number of elements points
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> c = np.linspace(0, 1, 6)   # start, end, num-points
\end_layout

\begin_layout Plain Layout

>>> c
\end_layout

\begin_layout Plain Layout

array([ 0.
 ,  0.2,  0.4,  0.6,  0.8,  1.
 ])
\end_layout

\begin_layout Plain Layout

>>> d = np.linspace(0, 1, 5, endpoint=False)
\end_layout

\begin_layout Plain Layout

>>> d
\end_layout

\begin_layout Plain Layout

array([ 0.
 ,  0.2,  0.4,  0.6,  0.8])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
special arrarys/matrix
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a = np.ones((3, 3))  # reminder: (3, 3) is a tuple
\end_layout

\begin_layout Plain Layout

>>> a
\end_layout

\begin_layout Plain Layout

array([[ 1.,  1.,  1.],
\end_layout

\begin_layout Plain Layout

       [ 1.,  1.,  1.],
\end_layout

\begin_layout Plain Layout

       [ 1.,  1.,  1.]])
\end_layout

\begin_layout Plain Layout

>>> b = np.zeros((2, 2))
\end_layout

\begin_layout Plain Layout

>>> b
\end_layout

\begin_layout Plain Layout

array([[ 0.,  0.],
\end_layout

\begin_layout Plain Layout

       [ 0.,  0.]])
\end_layout

\begin_layout Plain Layout

>>> c = np.eye(3)
\end_layout

\begin_layout Plain Layout

>>> c
\end_layout

\begin_layout Plain Layout

array([[ 1.,  0.,  0.],
\end_layout

\begin_layout Plain Layout

       [ 0.,  1.,  0.],
\end_layout

\begin_layout Plain Layout

       [ 0.,  0.,  1.]])
\end_layout

\begin_layout Plain Layout

>>> d = np.diag(np.array([1, 2, 3, 4]))
\end_layout

\begin_layout Plain Layout

>>> d
\end_layout

\begin_layout Plain Layout

array([[1, 0, 0, 0],
\end_layout

\begin_layout Plain Layout

       [0, 2, 0, 0],
\end_layout

\begin_layout Plain Layout

       [0, 0, 3, 0],
\end_layout

\begin_layout Plain Layout

       [0, 0, 0, 4]])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sort
\end_layout

\begin_layout Standard
Sorting along an axis:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>
\end_layout

\begin_layout Plain Layout

>>> a = np.array([[4, 3, 5], [1, 2, 1]])
\end_layout

\begin_layout Plain Layout

>>> b = np.sort(a, axis=1)
\end_layout

\begin_layout Plain Layout

>>> b
\end_layout

\begin_layout Plain Layout

array([[3, 4, 5],
\end_layout

\begin_layout Plain Layout

[1, 1, 2]])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In-place sort:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a.sort(axis=1)
\end_layout

\begin_layout Plain Layout

>>> a
\end_layout

\begin_layout Plain Layout

array([[3, 4, 5],
\end_layout

\begin_layout Plain Layout

       [1, 1, 2]])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
return positions by sorting
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a = np.array([4, 3, 1, 2])
\end_layout

\begin_layout Plain Layout

>>> j = np.argsort(a)
\end_layout

\begin_layout Plain Layout

>>> j
\end_layout

\begin_layout Plain Layout

array([2, 3, 1, 0])
\end_layout

\begin_layout Plain Layout

>>> a[j]
\end_layout

\begin_layout Plain Layout

array([1, 2, 3, 4])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
which( List == True) :: np.where(conditions)
\end_layout

\begin_layout Standard
Show the True positions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Out[48]: (array([0], dtype=int64),)
\end_layout

\begin_layout Plain Layout

In[49]: np.where([True, False])
\end_layout

\begin_layout Plain Layout

Out[49]: (array([0], dtype=int64),)
\end_layout

\begin_layout Plain Layout

In[50]: np.where([True, True])
\end_layout

\begin_layout Plain Layout

Out[50]: (array([0, 1], dtype=int64),)
\end_layout

\begin_layout Plain Layout

In[51]: np.where([True, True, True])
\end_layout

\begin_layout Plain Layout

Out[51]: (array([0, 1, 2], dtype=int64),)
\end_layout

\begin_layout Plain Layout

In[52]: np.where([True, True, False])
\end_layout

\begin_layout Plain Layout

Out[52]: (array([0, 1], dtype=int64),)
\end_layout

\begin_layout Plain Layout

In[53]: np.where([[True, False], [True, True]])
\end_layout

\begin_layout Plain Layout

Out[53]: (array([0, 1, 1], dtype=int64), array([0, 0, 1], dtype=int64))
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
which(condition, x, y):: np.where(bool_list, list1, list2) : Choose either
 items in x or y according to condition
\end_layout

\begin_layout Standard
Return elements, either from x or y, depending on condition.
\end_layout

\begin_layout Standard
x, y : array_like, optional: Values from which to choose.
 x and y need to have the same shape as condition.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[57]: np.where([True, True, False],[1,1,1], [100,100,100])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[57]: array([  1,   1, 100])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# if true at position i, the choose item i in x, otherwise choose item i
 in y
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[56]: np.where(
\end_layout

\begin_layout Plain Layout

    [[True, False], [True, True]],
\end_layout

\begin_layout Plain Layout

    [[1, 2], [3, 4]],
\end_layout

\begin_layout Plain Layout

    [[9, 8], [7, 6]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[56]:
\end_layout

\begin_layout Plain Layout

array([[1, 8],
\end_layout

\begin_layout Plain Layout

       [3, 4]])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
np.ravel: make multi-dim arrary into a flat list
\end_layout

\begin_layout Standard
argument:
\end_layout

\begin_layout Itemize
order = 'C' or Default: in row order
\end_layout

\begin_layout Itemize
order = 'F': in col order
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[84]: x = np.array([[1, 2, 3], [4, 5, 6]])
\end_layout

\begin_layout Plain Layout

print np.ravel(x)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[1 2 3 4 5 6]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

print np.ravel(x, order = 'F')
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
np.flatnonzero( arrary ): flatern it, then return the non-zero positions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[100]: np.flatnonzero(np.array([[0, 2, 3], [4, 5, 6]]))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[94]: array([1, 2, 3, 4, 5], dtype=int64)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
numpy.nonzero(a): positions of non-zero
\end_layout

\begin_layout Standard
Return the indices of the elements that are non-zero.
\end_layout

\begin_layout Standard
The corresponding non-zero values can be obtained with:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

a[nonzero(a)]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
for single dimention arrary like object, return the position of non-zero
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[58]: np.nonzero([1,0,1])
\end_layout

\begin_layout Plain Layout

Out[58]: (array([0, 2], dtype=int64),)
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
For multi-dimention array: Returns a tuple of arrays, one for each dimension
 of a, containing the indices of the non-zero elements in that dimension.
 The values in a are always tested and returned in row-major, C-style order.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> x = np.eye(3)
\end_layout

\begin_layout Plain Layout

>>> x
\end_layout

\begin_layout Plain Layout

array([[ 1.,  0.,  0.],
\end_layout

\begin_layout Plain Layout

       [ 0.,  1.,  0.],
\end_layout

\begin_layout Plain Layout

       [ 0.,  0.,  1.]])
\end_layout

\begin_layout Plain Layout

>>> np.nonzero(x)
\end_layout

\begin_layout Plain Layout

(	array([0, 1, 2]), # x-axis of the three non-zero elemenents
\end_layout

\begin_layout Plain Layout

	array([0, 1, 2])) # y-axis of the three non-zero elements
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
To group the indices by element, rather than dimension, use:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

transpose(nonzero(a))
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
numpy.count_nonzero(a): Counts the number of non-zero values in the array
 a.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> np.count_nonzero(np.eye(4))
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

>>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])
\end_layout

\begin_layout Plain Layout

5
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
np.repeat
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> x = np.array([[1,2],[3,4]])
\end_layout

\begin_layout Plain Layout

>>> np.repeat(x, 2)
\end_layout

\begin_layout Plain Layout

array([1, 1, 2, 2, 3, 3, 4, 4])
\end_layout

\begin_layout Plain Layout

>>> np.repeat(x, 3, axis=1)
\end_layout

\begin_layout Plain Layout

array([[1, 1, 1, 2, 2, 2],
\end_layout

\begin_layout Plain Layout

       [3, 3, 3, 4, 4, 4]])
\end_layout

\begin_layout Plain Layout

>>> np.repeat(x, [1, 2], axis=0)
\end_layout

\begin_layout Plain Layout

array([[1, 2],
\end_layout

\begin_layout Plain Layout

       [3, 4],
\end_layout

\begin_layout Plain Layout

       [3, 4]])
\end_layout

\end_inset


\end_layout

\begin_layout Section
Combine
\end_layout

\begin_layout Subsection
numpy.concatenate: concatenate arrays, same as pd.concat
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> a = np.array([[1, 2], [3, 4]])
\end_layout

\begin_layout Plain Layout

>>> b = np.array([[5, 6]])
\end_layout

\begin_layout Plain Layout

>>> np.concatenate((a, b), axis=0)
\end_layout

\begin_layout Plain Layout

array([[1, 2],
\end_layout

\begin_layout Plain Layout

       [3, 4],
\end_layout

\begin_layout Plain Layout

       [5, 6]])
\end_layout

\begin_layout Plain Layout

>>> np.concatenate((a, b.T), axis=1)
\end_layout

\begin_layout Plain Layout

array([[1, 2, 5],
\end_layout

\begin_layout Plain Layout

       [3, 4, 6]])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
numpy.hstack(tup): Stack arrays in sequence horizontally (column wise).
\end_layout

\begin_layout Standard
Equivalent to
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

np.concatenate(tup, axis=1)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Examples
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> a = np.array((1,2,3))
\end_layout

\begin_layout Plain Layout

>>> b = np.array((2,3,4))
\end_layout

\begin_layout Plain Layout

>>> np.hstack((a,b))
\end_layout

\begin_layout Plain Layout

array([1, 2, 3, 2, 3, 4])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> a = np.array([[1],[2],[3]])
\end_layout

\begin_layout Plain Layout

In[16]: a
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[16]:
\end_layout

\begin_layout Plain Layout

array([[1],
\end_layout

\begin_layout Plain Layout

       [2],
\end_layout

\begin_layout Plain Layout

       [3]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> b = np.array([[2],[3],[4]])
\end_layout

\begin_layout Plain Layout

>>> np.hstack((a,b))
\end_layout

\begin_layout Plain Layout

array([[1, 2],
\end_layout

\begin_layout Plain Layout

       [2, 3],
\end_layout

\begin_layout Plain Layout

       [3, 4]])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
vstackStack arrays in sequence vertically (row wise)
\end_layout

\begin_layout Section
np.matrix
\end_layout

\begin_layout Subsection
diagnoal matrix: np.eye(3)
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

>>> x = np.eye(3)
\end_layout

\begin_layout Plain Layout

>>> x
\end_layout

\begin_layout Plain Layout

array([[ 1., 0., 0.],
\end_layout

\begin_layout Plain Layout

[ 0., 1., 0.],
\end_layout

\begin_layout Plain Layout

[ 0., 0., 1.]])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Create a matrix
\end_layout

\begin_layout Itemize
np.matrix() : convert an arrary-like object to matrix
\end_layout

\begin_deeper
\begin_layout Itemize
np.mat(): similar, but change in place with no return
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x = np.matrix( ((2,3), (3, 5)) )
\end_layout

\begin_layout Plain Layout

y = np.matrix( ((1,2), (5, -1)) )
\end_layout

\begin_layout Plain Layout

z = np.matrix( ((1,2,0), (5, -1,0)) )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type(x).__name__
\end_layout

\begin_layout Plain Layout

Out[95]: 'matrix'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

Out[96]:
\end_layout

\begin_layout Plain Layout

matrix([[2, 3],
\end_layout

\begin_layout Plain Layout

        [3, 5]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

y
\end_layout

\begin_layout Plain Layout

Out[97]:
\end_layout

\begin_layout Plain Layout

matrix([[ 1,  2],
\end_layout

\begin_layout Plain Layout

        [ 5, -1]])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
create from a string of list, with each col seperated by ;:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

m = np.matrix('[1, 2; 3, 4]'); m
\end_layout

\begin_layout Plain Layout

Out[101]:
\end_layout

\begin_layout Plain Layout

matrix([[1, 2],
\end_layout

\begin_layout Plain Layout

        [3, 4]])
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
inverse: m.getI() / m.I
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> m = np.matrix('[1, 2; 3, 4]');
\end_layout

\begin_layout Plain Layout

matrix([[1, 2],
\end_layout

\begin_layout Plain Layout

        [3, 4]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

m.I
\end_layout

\begin_layout Plain Layout

Out[109]:
\end_layout

\begin_layout Plain Layout

matrix([[-2.
 ,  1.
 ],
\end_layout

\begin_layout Plain Layout

        [ 1.5, -0.5]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> m.getI()
\end_layout

\begin_layout Plain Layout

matrix([[-2.
 ,  1.
 ],
\end_layout

\begin_layout Plain Layout

        [ 1.5, -0.5]])
\end_layout

\begin_layout Plain Layout

>>> m.getI() * m
\end_layout

\begin_layout Plain Layout

matrix([[ 1.,  0.],
\end_layout

\begin_layout Plain Layout

        [ 0.,  1.]])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
transpose: m.getT() / / m.T
\end_layout

\begin_layout Subsection
transpose: np.transpose(array) or array.transpose()
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> m = np.matrix('[1, 2; 3, 4]')
\end_layout

\begin_layout Plain Layout

>>> m
\end_layout

\begin_layout Plain Layout

matrix([[1, 2],
\end_layout

\begin_layout Plain Layout

        [3, 4]])
\end_layout

\begin_layout Plain Layout

>>> m.getT()
\end_layout

\begin_layout Plain Layout

matrix([[1, 3],
\end_layout

\begin_layout Plain Layout

        [2, 4]])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

m.T
\end_layout

\begin_layout Plain Layout

Out[106]:
\end_layout

\begin_layout Plain Layout

matrix([[1, 3],
\end_layout

\begin_layout Plain Layout

        [2, 4]])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
matrix product, dot, and cross
\end_layout

\begin_layout Itemize
matrix production
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x * y
\end_layout

\begin_layout Plain Layout

Out[98]:
\end_layout

\begin_layout Plain Layout

matrix([[17,  1],
\end_layout

\begin_layout Plain Layout

        [28,  1]])
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
np.dot(x,y): dot product of arrary : If we want to perform matrix multiplication
 with two numpy arrays (ndarray), we have to use the dot product:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> x = np.array( ((2,3), (3, 5)) )
\end_layout

\begin_layout Plain Layout

>>> y = np.matrix( ((1,2), (5, -1)) )
\end_layout

\begin_layout Plain Layout

>>> np.dot(x,y)
\end_layout

\begin_layout Plain Layout

matrix([[17,  1],
\end_layout

\begin_layout Plain Layout

        [28,  1]])
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
np.cross(): cross product
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> x = np.array([0,0,1])
\end_layout

\begin_layout Plain Layout

>>> y = np.array([0,1,0])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> np.cross(x,y)
\end_layout

\begin_layout Plain Layout

array([-1,  0,  0])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> np.cross(y,x)
\end_layout

\begin_layout Plain Layout

array([1, 0, 0])
\end_layout

\end_inset


\end_layout

\begin_layout Section
Fancy Indexing
\end_layout

\begin_layout Subsection
Refer by boolean
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> np.random.seed(3)
\end_layout

\begin_layout Plain Layout

>>> a = np.random.random_integers(0, 20, 15)
\end_layout

\begin_layout Plain Layout

>>> a
\end_layout

\begin_layout Plain Layout

array([10,  3,  8,  0, 19, 10, 11,  9, 10,  6,  0, 20, 12,  7, 14])
\end_layout

\begin_layout Plain Layout

>>> (a % 3 == 0)
\end_layout

\begin_layout Plain Layout

array([False,  True, False,  True, False, False, False,  True, False,
\end_layout

\begin_layout Plain Layout

        True,  True, False,  True, False, False], dtype=bool)
\end_layout

\begin_layout Plain Layout

>>> mask = (a % 3 == 0)
\end_layout

\begin_layout Plain Layout

>>> extract_from_a = a[mask] # or,  a[a%3==0]
\end_layout

\begin_layout Plain Layout

>>> extract_from_a           # extract a sub-array with the mask
\end_layout

\begin_layout Plain Layout

array([ 3,  0,  9,  6,  0, 12])
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Refer by (list of) position integeres
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a = np.arange(0, 100, 10)
\end_layout

\begin_layout Plain Layout

>>> a
\end_layout

\begin_layout Plain Layout

array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90])
\end_layout

\begin_layout Plain Layout

# Indexing can be done with an array of integers, where the same index is
 repeated several time:
\end_layout

\begin_layout Plain Layout

>>>
\end_layout

\begin_layout Plain Layout

>>> a[[2, 3, 2, 4, 2]]  # note: [2, 3, 2, 4, 2] is a Python list
\end_layout

\begin_layout Plain Layout

array([20, 30, 20, 40, 20])
\end_layout

\end_inset


\end_layout

\begin_layout Section
Calculations
\end_layout

\begin_layout Standard
Arrary operations are similar like sequence in R
\end_layout

\begin_layout Subsection
Summary functions
\end_layout

\begin_layout Itemize
x.sum
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> x = np.array([1, 3, 2])
\end_layout

\begin_layout Plain Layout

>>> x.min()
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

>>> x.max()
\end_layout

\begin_layout Plain Layout

3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> x.argmin()  # index of minimum
\end_layout

\begin_layout Plain Layout

0
\end_layout

\begin_layout Plain Layout

>>> x.argmax()  # index of maximum
\end_layout

\begin_layout Plain Layout

1
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Logical operations:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> np.all([True, True, False])
\end_layout

\begin_layout Plain Layout

False
\end_layout

\begin_layout Plain Layout

>>> np.any([True, True, False])
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Statistics:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>
\end_layout

\begin_layout Plain Layout

>>> x = np.array([1, 2, 3, 1])
\end_layout

\begin_layout Plain Layout

>>> y = np.array([[1, 2, 3], [5, 6, 1]])
\end_layout

\begin_layout Plain Layout

>>> x.mean()
\end_layout

\begin_layout Plain Layout

1.75
\end_layout

\begin_layout Plain Layout

>>> np.median(x)
\end_layout

\begin_layout Plain Layout

1.5
\end_layout

\begin_layout Plain Layout

>>> np.median(y, axis=-1) # last axis
\end_layout

\begin_layout Plain Layout

array([ 2., 5.])
\end_layout

\begin_layout Plain Layout

>>> x.std() # full population standard dev.
\end_layout

\begin_layout Plain Layout

0.82915619758884995
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Math
\end_layout

\begin_layout Itemize
np.log(), np.exp()
\end_layout

\begin_layout Itemize
np.sin(), np.cos()
\end_layout

\begin_layout Subsection
Comparisons
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a = np.array([1, 2, 3, 4])
\end_layout

\begin_layout Plain Layout

>>> b = np.array([4, 2, 2, 4])
\end_layout

\begin_layout Plain Layout

>>> a == b
\end_layout

\begin_layout Plain Layout

array([False,  True, False,  True], dtype=bool)
\end_layout

\begin_layout Plain Layout

>>> a > b
\end_layout

\begin_layout Plain Layout

array([False, False,  True, False], dtype=bool)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Array-wise comparisons:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a = np.array([1, 2, 3, 4])
\end_layout

\begin_layout Plain Layout

>>> b = np.array([4, 2, 2, 4])
\end_layout

\begin_layout Plain Layout

>>> c = np.array([1, 2, 3, 4])
\end_layout

\begin_layout Plain Layout

>>> np.array_equal(a, b)
\end_layout

\begin_layout Plain Layout

False
\end_layout

\begin_layout Plain Layout

>>> np.array_equal(a, c)
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Broadcasting
\end_layout

\begin_layout Standard
http://docs.scipy.org/doc/numpy-1.10.1/user/basics.broadcasting.html
\end_layout

\begin_layout Standard
The term broadcasting describes how numpy treats arrays with different shapes
 during arithmetic operations.
 Subject to certain constraints, the smaller array is “broadcast” across
 the larger array so that they have compatible shapes.
 Broadcasting provides a means of vectorizing array operations so that looping
 occurs in C instead of Python.
\end_layout

\begin_layout Section
Copies and views
\end_layout

\begin_layout Subsection
A slicing operation creates a view on the original array
\end_layout

\begin_layout Standard
A slicing operation creates a view on the original array, which is just
 a way of accessing array data.
 Thus the original array is not copied in memory.
 You can use np.may_share_memory() to check if two arrays share the same
 memory block.
 Note however, that this uses heuristics and may give you false positives.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> a = np.arange(10)
\end_layout

\begin_layout Plain Layout

>>> a
\end_layout

\begin_layout Plain Layout

array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
\end_layout

\begin_layout Plain Layout

>>> b = a[::2]
\end_layout

\begin_layout Plain Layout

>>> b
\end_layout

\begin_layout Plain Layout

array([0, 2, 4, 6, 8])
\end_layout

\begin_layout Plain Layout

>>> np.may_share_memory(a, b)
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
When modifying the view, the original array is modified as well
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> b[0] = 12
\end_layout

\begin_layout Plain Layout

>>> b
\end_layout

\begin_layout Plain Layout

array([12,  2,  4,  6,  8])
\end_layout

\begin_layout Plain Layout

>>> a   # (!)
\end_layout

\begin_layout Plain Layout

array([12,  1,  2,  3,  4,  5,  6,  7,  8,  9])
\end_layout

\end_inset


\end_layout

\begin_layout Section
Universal functions
\end_layout

\begin_layout Itemize
Ufunc performs and elementwise operation on all elements of an array.
\end_layout

\begin_layout Itemize
Examples:
\begin_inset ERT
status open

\begin_layout Plain Layout

np.add, np.subtract, scipy.special.*, ...
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Automatically support: broadcasting, casting, ...
\end_layout

\begin_layout Itemize
The author of an ufunc only has to supply the elementwise operation, Numpy
 takes care of the rest.
\end_layout

\begin_layout Itemize
The elementwise operation needs to be implemented in C (or, e.g., Cython)
\end_layout

\begin_layout Section
Help
\end_layout

\begin_layout Standard
numpy.lookfor looks for keywords inside the docstrings of specified modules.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [45]: numpy.lookfor('convolution')
\end_layout

\begin_layout Plain Layout

Search results for 'convolution'
\end_layout

\begin_layout Plain Layout

--------------------------------
\end_layout

\begin_layout Plain Layout

numpy.convolve
\end_layout

\begin_layout Plain Layout

    Returns the discrete, linear convolution of two one-dimensional
\end_layout

\begin_layout Plain Layout

sequences.
\end_layout

\begin_layout Plain Layout

numpy.bartlett
\end_layout

\begin_layout Plain Layout

    Return the Bartlett window.
\end_layout

\begin_layout Plain Layout

numpy.correlate
\end_layout

\begin_layout Plain Layout

    Discrete, linear correlation of two 1-dimensional sequences.
\end_layout

\begin_layout Plain Layout

In [46]: numpy.lookfor('remove', module='os')
\end_layout

\begin_layout Plain Layout

Search results for 'remove'
\end_layout

\begin_layout Plain Layout

---------------------------
\end_layout

\begin_layout Plain Layout

os.remove
\end_layout

\begin_layout Plain Layout

    remove(path)
\end_layout

\begin_layout Plain Layout

os.removedirs
\end_layout

\begin_layout Plain Layout

    removedirs(path)
\end_layout

\begin_layout Plain Layout

os.rmdir
\end_layout

\begin_layout Plain Layout

    rmdir(path)
\end_layout

\begin_layout Plain Layout

os.unlink
\end_layout

\begin_layout Plain Layout

    unlink(path)
\end_layout

\begin_layout Plain Layout

os.walk
\end_layout

\begin_layout Plain Layout

    Directory tree generator.
\end_layout

\end_inset


\end_layout

\begin_layout Part
Sets { }
\end_layout

\begin_layout Standard
Part of the class `Numbers'
\end_layout

\begin_layout Itemize
Neither mappings nor sequences;
\end_layout

\begin_layout Itemize
They are
\series bold
unordered
\series default
 collections of unique and immutable objects.
 
\end_layout

\begin_layout Itemize
Sets can only contain
\series bold
immutable
\series default
 (a.k.a.
 
\begin_inset Quotes eld
\end_inset


\series bold
hashable
\series default

\begin_inset Quotes erd
\end_inset

) object types.
 Hence, lists and dictionaries cannot be embedded in sets, but tuples can
 if you need to store compound values.
 
\end_layout

\begin_layout Itemize
Sets are also convenient when you're dealing with
\series bold
large data sets
\series default
 (database query results, for example)---the
\series bold
intersection
\series default
 of two sets contains objects common to both categories, and the
\series bold
union
\series default
 contains all items in either set.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x = set('spam')
\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

Out[3]: {'a', 'm', 'p', 's'}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

y = {'h','a','m'}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Intersection, Union, Difference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x & y
\end_layout

\begin_layout Plain Layout

Out[9]: {'a', 'm'}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x|y
\end_layout

\begin_layout Plain Layout

Out[10]: {'a', 'h', 'm', 'p', 's'}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x- y
\end_layout

\begin_layout Plain Layout

Out[11]: {'p', 's'}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
whether a superset
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x>y
\end_layout

\begin_layout Plain Layout

Out[13]: False
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
add, update (merge), remove
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

x.add('A') # add can only insert one item
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x
\end_layout

\begin_layout Plain Layout

Out[25]: {'A', 'a', 'm', 'p', 's'}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x.add({'A','B'}) # add can only insert one item
\end_layout

\begin_layout Plain Layout

TypeError: unhashable type: 'set'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x.update(y) # two union merger
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x.remove({'A','m'}) # remove only one item
\end_layout

\begin_layout Plain Layout

KeyError: set(['A', 'm'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

x.remove({'A') # remove only one item
\end_layout

\begin_layout Plain Layout

SyntaxError: invalid syntax
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
create a set: set() to Remove duplicates
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

L = [1, 2, 1, 3, 2, 4, 5]
\end_layout

\begin_layout Plain Layout

L = list(set(L))
\end_layout

\begin_layout Plain Layout

L
\end_layout

\begin_layout Plain Layout

[1, 2, 3, 4, 5]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
set(A)-set(B) isolate differences
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6])
\end_layout

\begin_layout Plain Layout

{3, 7}
\end_layout

\begin_layout Plain Layout

set('abcdefg') - set('abdghij')
\end_layout

\begin_layout Plain Layout

{'c', 'e', 'f'}
\end_layout

\begin_layout Plain Layout

set('spam') - set(['h', 'a', 'm'])
\end_layout

\begin_layout Plain Layout

{'p', 's'}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
set(A) == set(B) order-neutral equality
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

L1, L2 = [1, 3, 5, 2, 4], [2, 5, 3, 4, 1]
\end_layout

\begin_layout Plain Layout

L1 == L2â¨
\end_layout

\begin_layout Plain Layout

False
\end_layout

\end_inset


\end_layout

\begin_layout Part
String
\end_layout

\begin_layout Standard
In fact, 3.X defines
\series bold
str
\series default
 strings formally as sequences of Unicode code points, not bytes.
\end_layout

\begin_layout Section
string is immutable
\end_layout

\begin_layout Standard

\series bold
Immutable object cannot be changed, it can only be replaced, or generate
 new one
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S = 'spam' 
\end_layout

\begin_layout Plain Layout

>>> S[0] = 'x' # Raises an error!
\end_layout

\begin_layout Plain Layout

TypeError: 'str' object does not support item assignment
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Three ways to
\change_inserted -445235034 1463373592

\series bold
 
\change_unchanged
change
\series default
 to a string
\end_layout

\begin_layout Standard
1.
 by concatenation and assign the new value to S
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S 'spamSPAM!' 
\end_layout

\begin_layout Plain Layout

>>> S = S[:4] + 'Burger' + S[−1]
\end_layout

\begin_layout Plain Layout

>>> S
\end_layout

\begin_layout Plain Layout

'spamBurger!'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
2.
 by S.replace
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S = 'splot'
\end_layout

\begin_layout Plain Layout

 >>> S = S.replace('pl', 'pamal')
\end_layout

\begin_layout Plain Layout

>>> S 
\end_layout

\begin_layout Plain Layout

'spamalot'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
3, Change to List, then joint back to string
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S = 'spammy' 
\end_layout

\begin_layout Plain Layout

>>> L = list(S) 
\end_layout

\begin_layout Plain Layout

>>> L 
\end_layout

\begin_layout Plain Layout

['s', 'p', 'a', 'm', 'm', 'y']
\end_layout

\begin_layout Plain Layout

>>> L[3] = 'x' # Works for lists, not strings
\end_layout

\begin_layout Plain Layout

>>> L[4] = 'x'
\end_layout

\begin_layout Plain Layout

>>> L ['s', 'p', 'a', 'x', 'x', 'y']
\end_layout

\begin_layout Plain Layout

>>> S = ''.join(L)
\end_layout

\begin_layout Plain Layout

>>> S
\end_layout

\begin_layout Plain Layout

 'spaxxy'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
multi-line string
\end_layout

\begin_layout Standard
Are you talking about multi-line strings? Easy, use triple quotes to start
 and end them.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

s = """ this is a very
\end_layout

\begin_layout Plain Layout

    long string if I had the
\end_layout

\begin_layout Plain Layout

    energy to type more and more ...""
\end_layout

\end_inset

You can use single quotes too (3 of them of course at start and end) and
 treat the resulting string s just like any other string.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

s = ("this is a very"
\end_layout

\begin_layout Plain Layout

        "long string too"
\end_layout

\begin_layout Plain Layout

        "for sure ..."
\end_layout

\begin_layout Plain Layout

        )
\end_layout

\begin_layout Plain Layout

'this is a verylong string toofor sure ...'
\end_layout

\end_inset


\end_layout

\begin_layout Section
Quotes
\end_layout

\begin_layout Subsection
Multiline Block Strings: Triple Quotes Code
\end_layout

\begin_layout Standard
Usage:
\end_layout

\begin_layout Itemize
If you wish to turn off a few lines of code and run your script again, simply
 put three quotes above and below them.
 
\end_layout

\begin_layout Itemize
Triple-quoted strings are useful anytime you need
\series bold
multiline text
\series default
 in your program; for example, to embed multiline error messages or HTML,
 XML, or JSON code in your Python source code files.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> mantra = """Always look
\end_layout

\begin_layout Plain Layout

...
 on the bright
\end_layout

\begin_layout Plain Layout

...
 side of life."""
\end_layout

\begin_layout Plain Layout

>>>
\end_layout

\begin_layout Plain Layout

>>> mantra
\end_layout

\begin_layout Plain Layout

'Always look
\backslash
n on the bright
\backslash
nside of life.'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

print(mantra)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Always look
\end_layout

\begin_layout Plain Layout

    on the bright
\end_layout

\begin_layout Plain Layout

side of life.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In fact, triple-quoted strings will
\series bold
retain all the enclosed text
\series default
, including any to the right of your code that you might intend as
\series bold
comments
\series default
.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

To allow comments, use
\end_layout

\begin_layout Plain Layout

    menu = (
\end_layout

\begin_layout Plain Layout

...
 "spam
\backslash
n" # comments here ignored
\end_layout

\begin_layout Plain Layout

...
 "eggs
\backslash
n" # but newlines not automatic
\end_layout

\begin_layout Plain Layout

...
 )
\end_layout

\begin_layout Plain Layout

    menu
\end_layout

\begin_layout Plain Layout

'spam
\backslash
neggs
\backslash
n'
\end_layout

\end_inset


\end_layout

\begin_layout Section
Regular Expression: MOVE
\end_layout

\begin_layout Subsection
Whether string is all digits / characters: isalpha, isdigit, etc.: Content
 Test
\end_layout

\begin_layout Itemize
Return true if all characters in the string are digits and there is at least
 one character, false otherwise.
\end_layout

\begin_layout Itemize
Return true if all characters in the string are alphabetic and there is
 at least one character, false otherwise.
\end_layout

\begin_layout Subsection
rstrip : Remove whitespace on the right side
\end_layout

\begin_layout Subsection
split(,): split into list by
\begin_inset Quotes eld
\end_inset

,
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> line = 'aaa,bbb,ccccc,dd
\backslash
n'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> line.rstrip()  # rstrip : Remove whitespace on the right side
\end_layout

\begin_layout Plain Layout

'aaa,bbb,ccccc,dd'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> line.rstrip().split(',')
\end_layout

\begin_layout Plain Layout

['aaa', 'bbb', 'ccccc', 'dd']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
string.join(list): add delimiter (string) into list, and make whole list
 into string.
\end_layout

\begin_layout Standard
It is called through the desired delimiter.
 join puts the strings in a list (or other iterable) together.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# String.Join(List)
\end_layout

\begin_layout Plain Layout

'SPAM'.join(['eggs', 'sausage', 'ham', 'toast']) # start with egg, end with
 toast
\end_layout

\begin_layout Plain Layout

'eggsSPAMsausageSPAMhamSPAMtoast'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
check end with/start with
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> line = "The knights who say Ni!
\backslash
n"
\end_layout

\begin_layout Plain Layout

>>> line.isalpha()
\end_layout

\begin_layout Plain Layout

False
\end_layout

\begin_layout Plain Layout

>>> line.endswith('Ni!
\backslash
n')
\end_layout

\begin_layout Plain Layout

True
\end_layout

\begin_layout Plain Layout

>>> line.startswith('The')
\end_layout

\begin_layout Plain Layout

True
\end_layout

\end_inset


\end_layout

\begin_layout Section
String with List
\end_layout

\begin_layout Subsection
convert to list
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S = 'spammy' 
\end_layout

\begin_layout Plain Layout

>>> L = list(S) 
\end_layout

\begin_layout Plain Layout

>>> L 
\end_layout

\begin_layout Plain Layout

['s', 'p', 'a', 'm', 'm', 'y']
\end_layout

\end_inset


\end_layout

\begin_layout Section
Convert to other Types
\end_layout

\begin_layout Subsection
Numeric to string and vice versa
\end_layout

\begin_layout Standard
str() is like paste() in R
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

Numeric to string and vice versa
\end_layout

\begin_layout Plain Layout

>>> int("42"), str(42) # Convert from/to string
\end_layout

\begin_layout Plain Layout

(42, '42')
\end_layout

\begin_layout Plain Layout

>>> text = "1.234E-10" 
\end_layout

\begin_layout Plain Layout

>>> float(text) # Shows more digits before 2.7 and 3.1
\end_layout

\begin_layout Plain Layout

1.234e-10
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Convert to its underlying ASCII byte value
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>  ord('s')
\end_layout

\begin_layout Plain Layout

115
\end_layout

\begin_layout Plain Layout

>>>  chr(115)
\end_layout

\begin_layout Plain Layout

's'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Convert from Binary/or other base system
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> int('1101', 2) # Convert binary to integer: built-in
\end_layout

\begin_layout Plain Layout

13 
\end_layout

\begin_layout Plain Layout

>>> bin(13) # Convert integer to binary: built-in
\end_layout

\begin_layout Plain Layout

'0b1101'
\end_layout

\end_inset


\end_layout

\begin_layout Part
Formatting '...%s...' % (values)
\end_layout

\begin_layout Standard
The result of formatting is a new string object, not a modified one.
\end_layout

\begin_layout Standard
# Formatting expression (all)
\end_layout

\begin_layout Subsection
'...%s...' % (values)
\end_layout

\begin_layout Itemize

\series bold
%s
\series default
 is the place to insert values.
 It can be anything in the Table 7-4.
 String formatting type codes
\end_layout

\begin_layout Itemize

\series bold
%
\series default
 is just a symbol to separate Target String in left, and to-be-Instead values
 in left.
 
\end_layout

\begin_layout Itemize
On the left of the % operator, provide a format string containing one or
 more embedded conversion targets, each of which starts with a % (e.g., %d).
 
\end_layout

\begin_layout Itemize
On the right of the % operator, provide the object (or objects, embedded
 in a tuple) that you want Python to insert into the format string on the
 left in place of the conversion target (or targets).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> 'That is %d %s bird!' % (1, 'dead') # Format expression
\end_layout

\begin_layout Plain Layout

That is 1 dead bird!
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> exclamation = 'Ni' 
\end_layout

\begin_layout Plain Layout

>>> 'The knights who say %s!' % exclamation
\end_layout

\begin_layout Plain Layout

'The knights who say Ni!'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
typecode
\end_layout

\begin_layout Standard
you cannot mix use
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

'That is %d bird!' % ('dead') # Format expression
\end_layout

\begin_layout Plain Layout

TypeError: %d format: a number is required, not str
\end_layout

\end_inset


\end_layout

\begin_layout Description
s String (or any object’s str(X) string)
\end_layout

\begin_layout Description
r Same as s, but uses repr, not str
\end_layout

\begin_layout Description
c Character (int or str)
\end_layout

\begin_layout Description
d Decimal (base-10 integer)
\end_layout

\begin_layout Description
i Integer
\end_layout

\begin_layout Description
u Same as d (obsolete: no longer unsigned)
\end_layout

\begin_layout Description
o Octal integer (base 8)
\end_layout

\begin_layout Description
x Hex integer (base 16)
\end_layout

\begin_layout Description
X Same as x, but with uppercase letters
\end_layout

\begin_layout Description
e Floating point with exponent, lowercase
\end_layout

\begin_layout Description
E Same as e, but uses uppercase letters
\end_layout

\begin_layout Description
f Floating-point decimal
\end_layout

\begin_layout Description
F Same as f, but uses uppercase letters
\end_layout

\begin_layout Description
g Floating-point e or f
\end_layout

\begin_layout Description
G Floating-point E or F
\end_layout

\begin_layout Description
% Literal % (coded as %%)
\end_layout

\begin_layout Subsection
full structure of the tobeplaced
\end_layout

\begin_layout Standard

\series bold
%[(keyname)][flags][width][.precision]typecode
\end_layout

\begin_layout Itemize
Provide a key name for indexing the dictionary used on the right side of
 the expression
\end_layout

\begin_layout Itemize
List flags that specify things like left justification (−), numeric sign
 (+), a blank before positive numbers and a – for negatives (a space), and
 zero fills (0)
\end_layout

\begin_layout Itemize
Give a total minimum field width for the substituted text
\end_layout

\begin_layout Itemize
Set the number of digits (precision) to display after a decimal point for
 floating point numbers
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> x = 1234 
\end_layout

\begin_layout Plain Layout

>>> res = 'integers: ...%d...%−6d...%06d' % (x, x, x)
\end_layout

\begin_layout Plain Layout

>>> res 
\end_layout

\begin_layout Plain Layout

'integers: ...1234...1234 ...001234'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> x = 1.23456789
\end_layout

\begin_layout Plain Layout

>>> '%−6.2f | %05.2f | %+06.1f' % (x, x, x)
\end_layout

\begin_layout Plain Layout

'1.23 | 01.23 | +001.2'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Dictionary-Based Formatting Expressions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> '%(qty)d more %(food)s' % {'qty': 1, 'food': 'spam'}  # where (qty)
 and (food) are key names.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

'1 more spam'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> # Template with substitution targets
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> reply = """
\end_layout

\begin_layout Plain Layout

Greetings...
\end_layout

\begin_layout Plain Layout

Hello %(name)s!
\end_layout

\begin_layout Plain Layout

Your age is %(age)s
\end_layout

\begin_layout Plain Layout

"""
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> values = {'name': 'Bob', 'age': 40} # Build up values to substitute
\end_layout

\begin_layout Plain Layout

>>> print(reply % values) # Perform substitutions
\end_layout

\begin_layout Plain Layout

Greetings...
\end_layout

\begin_layout Plain Layout

Hello Bob!
\end_layout

\begin_layout Plain Layout

Your age is 40
\end_layout

\end_inset


\end_layout

\begin_layout Section
'...{}...'.format(values)
\end_layout

\begin_layout Standard
Python 2.6 and 3.0 introduced a new way to format strings
\end_layout

\begin_layout Standard

\series bold
'...{}...'.format(values)
\end_layout

\begin_layout Itemize
` ' is the sentence you want to apply some formats on.
 
\end_layout

\begin_layout Itemize
{} is the place in that sentence you want to be replaced by format
\end_layout

\begin_layout Itemize
format{values} is the format.
 
\end_layout

\begin_layout Subsection
# By position
\end_layout

\begin_layout Standard
Replace position 0, 1, and 2 by spam, ham and egg
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

tobereplced = '{0}, {1} and {2
\end_layout

\begin_layout Plain Layout

tobereplced.format('spam', 'ham', 'eggs')
\end_layout

\begin_layout Plain Layout

'spam, ham and eggs'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
# By keyword
\end_layout

\begin_layout Standard
Like dictionary-based formatting expression, at the positions of '{motto},
 {pork} and {food}', replace the relative words ('spam', 'ham', 'eggs').
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

tobereplced = '{motto}, {pork} and {food}
\end_layout

\begin_layout Plain Layout

tobereplced.format(motto='spam', pork='ham', food='eggs')
\end_layout

\begin_layout Plain Layout

'spam, ham and eggs'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
# By both
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

template = '{motto}, {0} and {food}
\end_layout

\begin_layout Plain Layout

template.format('ham', motto='spam', food='eggs')
\end_layout

\begin_layout Plain Layout

'spam, ham and eggs'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
# By relative position
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

template = '{}, {} and {}
\end_layout

\begin_layout Plain Layout

template.format('spam', 'ham', 'eggs')
\end_layout

\begin_layout Plain Layout

'spam, ham and eggs'
\end_layout

\begin_layout Plain Layout

'{motto}, {0} and {food}'.format(42, motto=3.14, food=[1, 2])
\end_layout

\begin_layout Plain Layout

'3.14, 42 and [1, 2]'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Advanced: Square brackets in format strings can refer dictionary
\end_layout

\begin_layout Standard
{1[kind]} 表 引用format中position=1 处的dictionary，其中keyword=kind的对应值。
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> import sys
\end_layout

\begin_layout Plain Layout

>>> 'My {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})
\end_layout

\begin_layout Plain Layout

'My laptop runs win32'
\end_layout

\begin_layout Plain Layout

>>> 'My {map[kind]} runs {sys.platform}'.format(sys=sys, map={'kind': 'laptop'})
 
\end_layout

\begin_layout Plain Layout

'My laptop runs win32'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Advanced: Square brackets in format strings can refer list
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> somelist = list('SPAM') >>> somelist ['S', 'P', 'A', 'M']
\end_layout

\begin_layout Plain Layout

>>> 'first={0[0]}, third={0[2]}'.format(somelist) 'first=S, third=A'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Advanced : Square brackets in format strings can name list (and other sequence)
\end_layout

\begin_layout Subsection
More Advanced: p 277
\end_layout

\begin_layout Subsection
r or
\backslash
: Raw Strings Suppress Escapes
\end_layout

\begin_layout Standard
# Python will think
\backslash
n as a new line in code below
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

myfile = open('C:
\backslash
new
\backslash
text.dat', 'w')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To suppress Escapes, use
\series bold
r
\series default
 to represent raw string
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

myfile = open(r'C:
\backslash
new
\backslash
text.dat', 'w')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Alternatively, because
\series bold
two backslashes
\series default
 are really an escape sequence for one backslash, you can keep your backslashes
 by simply doubling them up:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

myfile = open('C:
\backslash

\backslash
new
\backslash

\backslash
text.dat', 'w')
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In fact, Python itself sometimes uses this doubling scheme when it prints
 strings with embedded backslashes:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

path = r'C:
\backslash
new
\backslash
text.dat'
\end_layout

\begin_layout Plain Layout

path # Show as Python code
\end_layout

\begin_layout Plain Layout

'C:
\backslash

\backslash
new
\backslash

\backslash
text.dat'
\end_layout

\begin_layout Plain Layout

print(path) # User-friendly format
\end_layout

\begin_layout Plain Layout

C:
\backslash
new
\backslash
text.dat
\end_layout

\end_inset


\end_layout

\begin_layout Part
Tuples ()
\end_layout

\begin_layout Standard
元组 复表 值组 固定有序列
\end_layout

\begin_layout Standard

\series bold
like a list that cannot be changed---
\end_layout

\begin_layout Itemize

\series bold
tuples are sequences, like lists,
\end_layout

\begin_layout Itemize

\series bold
but they are immutable, like strings.
\end_layout

\begin_layout Itemize
items in tuples can be duplicated
\end_layout

\begin_layout Standard
Tuples can also be used in places that lists cannot---for example, as dictionary
 keys (as the dict keys must be unique and immutable).
\end_layout

\begin_layout Subsection
Create
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

T = range(1,5)
\end_layout

\begin_layout Plain Layout

T = tuple(T)
\end_layout

\begin_layout Plain Layout

T
\end_layout

\begin_layout Plain Layout

Out[43]: (1, 2, 3, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Section
Operators
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> (1, 2) * 4  # Repetition
\end_layout

\begin_layout Plain Layout

(1, 2, 1, 2, 1, 2, 1, 2)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

T
\end_layout

\begin_layout Plain Layout

Out[44]: (1, 2, 3, 4)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

T + (5,6) # concatenate
\end_layout

\begin_layout Plain Layout

Out[45]: (1, 2, 3, 4, 5, 6)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

T[0] # indexing/slicing
\end_layout

\begin_layout Plain Layout

Out[46]: 1
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
offset/position
\end_layout

\begin_layout Standard
T.index(4) # 4 apprears at offet 3
\end_layout

\begin_layout Standard
Out[48]: 3
\end_layout

\begin_layout Subsection
Count number of appearness
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

T.count(4) # 4 appears once
\end_layout

\begin_layout Plain Layout

Out[47]: 1
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Joint
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> T = (2,) + T[1:]
\end_layout

\begin_layout Plain Layout

# Make a new tuple for a new value
\end_layout

\begin_layout Plain Layout

>>> T
\end_layout

\begin_layout Plain Layout

 (2, 2, 3, 4)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Enumerate
Fixed-lengthrange
\end_layout

\begin_layout Enumerate
heterogeneous,
\end_layout

\begin_layout Enumerate
arbitrarily nestable
\end_layout

\begin_layout Enumerate

\series bold
immutable
\end_layout

\begin_layout Standard
The
\series bold
parentheses
\series default
 enclosing a tuple's items can usually be omitted, as done here:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>  T = 'spam', 3.0, [11, 22, 33]
\end_layout

\begin_layout Plain Layout

>>>  T[1]
\end_layout

\begin_layout Plain Layout

3.0
\end_layout

\begin_layout Plain Layout

# Nesting
\end_layout

\begin_layout Plain Layout

>>>  T[2][1]
\end_layout

\begin_layout Plain Layout

 22
\end_layout

\begin_layout Plain Layout

>>> b * 3, b / 2
\end_layout

\begin_layout Plain Layout

(12, 2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
immutable
\end_layout

\begin_layout Standard
They don't grow and shrink because they are immutable
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>  T.append(4) 
\end_layout

\begin_layout Plain Layout

AttributeError: 'tuple' object has no attribute 'append'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Single item tuple
\end_layout

\begin_layout Standard

\series bold
x = (40)
\series default
 # An integer!
\end_layout

\begin_layout Standard

\series bold
y = (40,)
\series default
 # A tuple containing an integer
\end_layout

\begin_layout Subsection
Conversion
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> T = tuple(tmp)  # Make a tuple from the list's items
\end_layout

\begin_layout Plain Layout

# List comprehensions can also be used to convert tuples.
\end_layout

\begin_layout Plain Layout

>>> T = (1, 2, 3, 4, 5) 
\end_layout

\begin_layout Plain Layout

>>> L = [x + 20 for x in T]
\end_layout

\begin_layout Plain Layout

>>> L
\end_layout

\begin_layout Plain Layout

 [21, 22, 23, 24, 25]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
index(value)
\end_layout

\begin_layout Standard
Accessed by offset 
\end_layout

\begin_layout Standard
Like strings and lists, items in a tuple are accessed by offset (not by
 key); they support all the offset-based access operations, such as indexing
 and slicing.
\end_layout

\begin_layout Standard

\series bold
return the position of the value
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> T = (1, 2, 3, 2, 4, 2)
\end_layout

\begin_layout Plain Layout

>>> T.index(2)
\end_layout

\begin_layout Plain Layout

 1
\end_layout

\begin_layout Plain Layout

# Offset of appearance after offset 2
\end_layout

\begin_layout Plain Layout

 >>> T.index(2, 2)
\end_layout

\begin_layout Plain Layout

3
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
namedtuple: accessed by both position and key
\end_layout

\begin_layout Standard
The namedtuple utility, available in the standard library's collections
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> from collections import namedtuple # Import extension type
\end_layout

\begin_layout Plain Layout

>>> Rec = namedtuple('Rec', ['name', 'age', 'jobs']) # Make a generated
 class
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> bob = Rec('Bob', age=40.5, jobs=['dev', 'mgr']) # A named-tuple record
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> bob
\end_layout

\begin_layout Plain Layout

Rec(name='Bob', age=40.5, jobs=['dev', 'mgr'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> bob[0], bob[2] # Access by position
\end_layout

\begin_layout Plain Layout

('Bob', ['dev', 'mgr'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> bob.name, bob.jobs # Access by attribute
\end_layout

\begin_layout Plain Layout

('Bob', ['dev', 'mgr'])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Converting to a dictionary supports key-based behavior when needed:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> O = bob._asdict() # Dictionary-like form
\end_layout

\begin_layout Plain Layout

>>> O['name'], O['jobs'] # Access by key too
\end_layout

\begin_layout Plain Layout

('Bob', ['dev', 'mgr'])
\end_layout

\begin_layout Plain Layout

>>> O
\end_layout

\begin_layout Plain Layout

OrderedDict([('name', 'Bob'), ('age', 40.5), ('jobs', ['dev', 'mgr'])])
\end_layout

\end_inset


\end_layout

\begin_layout Part
List [ ]
\end_layout

\begin_layout Standard

\series bold
List is of the category
\begin_inset Quotes eld
\end_inset

mutable sequence
\begin_inset Quotes erd
\end_inset

, variable-length, heterogeneous, and arbitrarily nestable.
\end_layout

\begin_layout Subsection
Empty list
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

L = [] # An empty list
\end_layout

\begin_layout Plain Layout

L[i][j] # refer nested list
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
create a list: list(sequence)
\end_layout

\begin_layout Standard
just use [Sequence] is not robust, as Python will think you treat the Sequence
 as one single element of the list
\end_layout

\begin_layout Subsection
range(start, end, jump): range of numbers
\end_layout

\begin_layout Itemize
put any thing inside the hard bracket
\begin_inset Quotes eld
\end_inset

[..]
\begin_inset Quotes erd
\end_inset

 and they will become a list.
\end_layout

\begin_deeper
\begin_layout Itemize
for a string, use
\family typewriter
list()
\family default
 and they will become a list for each cahracter
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

In [Out[28]: 'p'29]: list("Spam")[1]
\end_layout

\begin_layout Plain Layout

Out[29]: 'p'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> list(range(4)) # 0..3 (list() required in 3.X)
\end_layout

\begin_layout Plain Layout

[0, 1, 2, 3]
\end_layout

\begin_layout Plain Layout

>>> list(range(−6,7,2)) # −6 to +6 by 2 (need list() in 3.X) # not include
 the end!
\end_layout

\begin_layout Plain Layout

[−6, −4, −2, 0, 2,4,6]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

L = [123,'spam',1.23]
\end_layout

\begin_layout Plain Layout

L
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Transform to List (from string): list()
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S = 'shrubbery' 
\end_layout

\begin_layout Plain Layout

>>> L = list(S)
\end_layout

\begin_layout Plain Layout

>>> L
\end_layout

\begin_layout Plain Layout

 ['s', 'h', 'r', 'u', 'b', 'b', 'e', 'r', 'y']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

list(S)
\end_layout

\begin_layout Plain Layout

 >>> L ['s', 'h', 'r', 'u', 'b', 'b', 'e', 'r', 'y']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> L = [1,3,6]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Nesting: List of lists:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> breakfast = [
\end_layout

\begin_layout Plain Layout

...
 'Monday', ['coffee', 'rice crispies'], # Remember the spaces!
\end_layout

\begin_layout Plain Layout

...
 'Tuesday', ['orange juice', 'toast', 'marmalade'],
\end_layout

\begin_layout Plain Layout

...
 'Wednesday', ['coffee'] ]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> breakfast[3]
\end_layout

\begin_layout Plain Layout

['orange juice', 'toast', 'marmalade']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> breakfast[3][0]
\end_layout

\begin_layout Plain Layout

'orange juice'
\end_layout

\begin_layout Plain Layout

juice'
\end_layout

\end_inset


\end_layout

\begin_layout Section
List Iteration and Comprehensions
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> for x in [1, 2, 3]:
\end_layout

\begin_layout Plain Layout

...
 print(x, end=' ')
\end_layout

\begin_layout Plain Layout

.. .
\end_layout

\begin_layout Plain Layout

12 3
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
enumerate (sequence, start=0) : adds a counter to an iterable.
\end_layout

\begin_layout Standard
Return an
\family typewriter
enumerate
\family default
 object.
 sequence must be a sequence, an iterator, or some other object which supports
 iteration.
 
\end_layout

\begin_layout Standard
The
\family typewriter
next()
\family default
method of the iterator returned by
\family typewriter
enumerate()
\family default
 returns a
\family typewriter
tuple
\family default
 containing a count (from start which defaults to 0) and the values obtained
 from iterating over sequence:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type(enumerate(seasons))
\end_layout

\begin_layout Plain Layout

Out[114]: enumerate
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> list(enumerate(seasons))
\end_layout

\begin_layout Plain Layout

[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
\end_layout

\begin_layout Plain Layout

>>> list(enumerate(seasons, start=1))
\end_layout

\begin_layout Plain Layout

[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
\end_layout

\end_inset


\end_layout

\begin_layout Part
Sequence-Specific Method: use List as example
\end_layout

\begin_layout Standard
List, String are all sequence and shares the following method
\end_layout

\begin_layout Section
Sequence Operation
\end_layout

\begin_layout Standard
Every string operation we've studied so far is really a sequence operation---tha
t is, these operations will work on other sequences in Python as well, including
lists and tuples.
\end_layout

\begin_layout Itemize
Len # length
\end_layout

\begin_layout Itemize
[] return a character according to its location in the string
\end_layout

\begin_layout Itemize
Concatenation
\end_layout

\begin_layout Quote
\begin_inset ERT
status open

\begin_layout Plain Layout

S + 'xyz'
\end_layout

\begin_layout Plain Layout

'Spamxyz'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[2, 3, 4, 1, 5, 6, 7] + [8, 9, 10]
\end_layout

\begin_layout Plain Layout

Out[19]: [2, 3, 4, 1, 5, 6, 7, 8, 9, 10]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# same as
\end_layout

\begin_layout Plain Layout

L = [2, 3, 4, 1, 5, 6, 7]
\end_layout

\begin_layout Plain Layout

L.extend([8, 9, 10])
\end_layout

\begin_layout Plain Layout

L # not nested
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[2, 3, 4, 1, 5, 6, 7, 8, 9, 10]
\end_layout

\begin_layout Plain Layout

Out[18]: [2, 3, 4, 1, 5, 6, 7, 8, 9, 10]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Repetition
\end_layout

\begin_layout Quote
\begin_inset ERT
status open

\begin_layout Plain Layout

S * 8
\end_layout

\begin_layout Plain Layout

'SpamSpamSpamSpamSpamSpamSpamSpam'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
all() :: iterable.all(iterable) 
\end_layout

\begin_layout Standard
Return True if all elements of the iterable are true (or if the iterable
 is empty).
 Equivalent to:
\end_layout

\begin_layout Standard
def all(iterable): for element in iterable: if not element: return False
 return True New in version 2.5.
\end_layout

\begin_layout Subsection
any():: iterable.any(iterable)
\end_layout

\begin_layout Standard
Return True if any element of the iterable is true.
 If the iterable is empty, return False.
 Equivalent to:
\end_layout

\begin_layout Standard
def any(iterable): for element in iterable: if element: return True return
 False
\end_layout

\begin_layout Subsection
\begin_inset Quotes eld
\end_inset

in
\begin_inset Quotes erd
\end_inset

 opreator: to test membership
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> "k" in myjob
\end_layout

\begin_layout Plain Layout

 True
\end_layout

\begin_layout Plain Layout

# for list
\end_layout

\begin_layout Plain Layout

3 in L
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.count() : Number of occurrences
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 >>> L.count('spam')
\end_layout

\begin_layout Plain Layout

 1
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.sort() / .reverse() / oldlist[::-1]
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> M = ['bb', 'aa', 'cc']
\end_layout

\begin_layout Plain Layout

>>> M.sort()
\end_layout

\begin_layout Plain Layout

 >>> M 
\end_layout

\begin_layout Plain Layout

['aa', 'bb', 'cc']
\end_layout

\begin_layout Plain Layout

>>> M.reverse()
\end_layout

\begin_layout Plain Layout

 >>> M ['cc', 'bb', 'aa']
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Sort method returns nothing and cannot change the list.
\end_layout

\begin_layout Standard
To return a list, use sort as a function sort(), rather than a method L.sort
\end_layout

\begin_layout Itemize
Force copy
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

newlist = oldlist[::-1]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
len(): number of characters/member
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> len(S)
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

>>> len('Sw')
\end_layout

\begin_layout Plain Layout

2
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
max() and pmax() in R:: max()
\end_layout

\begin_layout Standard
accept as many as iterables as arguments
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

c = range(2,5)
\end_layout

\begin_layout Plain Layout

a = range(1,4)
\end_layout

\begin_layout Plain Layout

b = range(0,3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# one iterable
\end_layout

\begin_layout Plain Layout

max(a)
\end_layout

\begin_layout Plain Layout

Out[61]: 3
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# multiple iterable with same length
\end_layout

\begin_layout Plain Layout

max(a,b,c)
\end_layout

\begin_layout Plain Layout

Out[62]: [2, 3, 4]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# multiple iterable with different lengths
\end_layout

\begin_layout Plain Layout

max(a,b,c,[100,100,100,-100])
\end_layout

\begin_layout Plain Layout

Out[64]: [100, 100, 100, -100]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
zip()
\end_layout

\begin_layout Standard
zip(*iterables)
\end_layout

\begin_layout Standard
Make an iterator that aggregates elements from each of the iterables.
\end_layout

\begin_layout Standard
Returns an iterator of tuples, where the i-th tuple contains the i-th element
 from each of the argument sequences or iterables.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[14]: zip([1,2,3],[2,3,4,5])
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[14]: [(1, 2), (2, 3), (3, 4)]
\end_layout

\end_inset


\end_layout

\begin_layout Section
Change
\end_layout

\begin_layout Subsection
in place change for mutable items
\end_layout

\begin_layout Standard
Because lists are mutable, most list methods
\series bold
also change the list object in place, instead of creating a new one:
\end_layout

\begin_layout Itemize
One warning here: beware that
\series bold
append
\series default
 and
\series bold
sort
\series default
 change the associated list object in place, but don't return the list as
 a result (technically, they both return a value called None).
 If you say something like
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

L = L.append(X) # wrong
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You won't get the modified value of L (in fact, you'll lose the reference
 to the list altogether!, as .append returns a None!!)
\end_layout

\end_deeper
\begin_layout Subsection
.append() vs .extend() : add items at end of list
\end_layout

\begin_layout Itemize
extend(List) will add each of the element in the new list to the end of
 old list
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

L = [2, 3, 4, 1, 5, 6, 7]
\end_layout

\begin_layout Plain Layout

L.extend([8, 9, 10])
\end_layout

\begin_layout Plain Layout

L # not nested
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[2, 3, 4, 1, 5, 6, 7, 8, 9, 10]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[18]: [2, 3, 4, 1, 5, 6, 7, 8, 9, 10]
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
.append(List) will add the whole List as one single element to the end of
 old list.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

L = [123, 'spam', 1.23]
\end_layout

\begin_layout Plain Layout

L.append('NI') # append one element
\end_layout

\begin_layout Plain Layout

L # still a simple list
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[16]: [123, 'spam', 1.23, 'NI']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

L = [123, 'spam', 1.23]
\end_layout

\begin_layout Plain Layout

L.append(['NI','NI2']) # append a list
\end_layout

\begin_layout Plain Layout

L # NESTEST
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[17]: [123, 'spam', 1.23, ['NI', 'NI2']]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.remove() : Shrinking/ delete
\end_layout

\begin_layout Standard
# Delete by value
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L ['spam', 'toast', 'eggs', 'ham']
\end_layout

\begin_layout Plain Layout

>>> L.remove('eggs')
\end_layout

\begin_layout Plain Layout

 >>> L
\end_layout

\begin_layout Plain Layout

 ['spam', 'toast', 'ham']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.pop (integer): Delete by position
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L.pop(1)
\end_layout

\begin_layout Plain Layout

 'toast' 
\end_layout

\begin_layout Plain Layout

>>> L
\end_layout

\begin_layout Plain Layout

 ['spam', 'ham']
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Concatenation: A + B
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

 S + 'xyz'
\end_layout

\begin_layout Plain Layout

'Spamxyz'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Repetition itself: A * integer
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

S * 8
\end_layout

\begin_layout Plain Layout

'SpamSpamSpamSpamSpamSpamSpamSpam'
\end_layout

\end_inset


\end_layout

\begin_layout Section
Selections
\end_layout

\begin_layout Subsection
filter(None,B) :: filter out None from sequential object B
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

List = ["pineapple", "pineapple", "kumquat",None,"plum"]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

filter(None,List)
\end_layout

\begin_layout Plain Layout

Out[25]: ['pineapple', 'pineapple', 'kumquat', 'plum']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
filter with function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> numbers = [1, 6, 3, 8, 4, 9]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, we’ll define a function to act as our criteria to filter on:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def lessThanFive(element):
\end_layout

\begin_layout Plain Layout

...
 return element < 5
\end_layout

\begin_layout Plain Layout

...
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notice that in order to work properly, our criteria function must take a
 single argument (filter() will call it on each element of the iterable,
 one at a time).
 Using our newly defined lessThanFive() criteria function, we expect filter()
 to return a list of only the elements with a value of less than 5.
 and that’s exactly what we get.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> filter(lessThanFive, numbers)
\end_layout

\begin_layout Plain Layout

[1, 3, 4]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> filter(lambda x: x < 5, numbers)
\end_layout

\begin_layout Plain Layout

[1, 3, 4]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
get any item by any position
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L = range(0, 101, 10)
\end_layout

\begin_layout Plain Layout

>>> L
\end_layout

\begin_layout Plain Layout

[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
\end_layout

\begin_layout Plain Layout

>>> from operator import itemgetter
\end_layout

\begin_layout Plain Layout

>>> itemgetter(2, 5)(L)
\end_layout

\begin_layout Plain Layout

(20, 50)
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
which(a in b ) in R :: ["foo", "bar", "baz"].index("bar")
\end_layout

\begin_layout Standard
For a list ["foo", "bar", "baz"] and an item in the list "bar", what's the
 cleanest way to get its index (1) in Python?
\end_layout

\begin_layout Section
Slice / Reference [start:end:jump]
\end_layout

\begin_layout Subsection
a function to explain python slicer
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

In [98]: def slicer(seq, start=None, stop=None, step=None):
\end_layout

\begin_layout Plain Layout

   ....:     """Implement basic python slicing."""
\end_layout

\begin_layout Plain Layout

   ....:     return seq[start:stop:step]
\end_layout

\begin_layout Plain Layout

   ....:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [102]: rhyme
\end_layout

\begin_layout Plain Layout

Out[102]: ['one', 'fish,', 'two', 'fish,', 'red', 'fish,', 'blue', 'fish']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [103]: slicer(rhyme)
\end_layout

\begin_layout Plain Layout

Out[103]: ['one', 'fish,', 'two', 'fish,', 'red', 'fish,', 'blue', 'fish']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [104]: slicer(rhyme, step=2)
\end_layout

\begin_layout Plain Layout

Out[104]: ['one', 'two', 'red', 'blue']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [105]: slicer(rhyme, 1, step=2)
\end_layout

\begin_layout Plain Layout

Out[105]: ['fish,', 'fish,', 'fish,', 'fish']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [106]: slicer(rhyme, start=1, stop=4, step=2)
\end_layout

\begin_layout Plain Layout

Out[106]: ['fish,', 'fish,']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
[single position]: return one element according to its location in the string
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S=['Spam']
\end_layout

\begin_layout Plain Layout

>>> S[0]
\end_layout

\begin_layout Plain Layout

'S'
\end_layout

\begin_layout Plain Layout

>>> S[1]
\end_layout

\begin_layout Plain Layout

'p'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
# The last item in S
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>  S[-1]
\end_layout

\begin_layout Plain Layout

'm'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
choose a range
\series bold
[A:B] in Python means [A:B] ! it means stop at one position before B
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

menu[1:3]
\end_layout

\begin_layout Plain Layout

['eggs', 'chips'] # Take items 1 & 2, stop at 3.
\end_layout

\begin_layout Plain Layout

    menu[:2]
\end_layout

\begin_layout Plain Layout

['spam', 'eggs'] # Start at the beginning if you don't say.
\end_layout

\begin_layout Plain Layout

    menu[2:]
\end_layout

\begin_layout Plain Layout

['chips', 'beans'] # End at the end if you don't say.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
choose a range :
\end_layout

\begin_layout Standard
# Everything past the first (1:len(S))
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S[1:]
\end_layout

\begin_layout Plain Layout

'pam'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
From 1 to 2, including the start (1), but not including the end (3)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S[1:3] # Slice of S from offsets 1 through 2 (not 3)
\end_layout

\begin_layout Plain Layout

'pa'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
# Same as S[0:3]
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S[:3]
\end_layout

\begin_layout Plain Layout

'Spa'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
# Everything but the last again, but simpler (0:-1)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S[:-1]
\end_layout

\begin_layout Plain Layout

'Spa'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
jump
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S = 'abcdefghijklmnop'
\end_layout

\begin_layout Plain Layout

>>> S[1:10:2]  # from 1 to 10 by 2
\end_layout

\begin_layout Plain Layout

'bdfhj'
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# REVERSE JUMP: rhyme[::-1] # from the end to begin, jump by 1
\end_layout

\begin_layout Plain Layout

rhyme =  ['one', 'fish,', 'two', 'fish,', 'red', 'fish,', 'blue', 'fish']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

rhyme[::-1]
\end_layout

\begin_layout Plain Layout

Out[25]: ['fish', 'blue', 'fish,', 'red', 'fish,', 'two', 'fish,', 'one']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
slice function
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

# Same to the slice behavior
\end_layout

\begin_layout Plain Layout

>>> 'spam'[1:3]
\end_layout

\begin_layout Plain Layout

 'pa' 
\end_layout

\begin_layout Plain Layout

>>> 'spam'[slice(1, 3)] 
\end_layout

\begin_layout Plain Layout

'pa'
\end_layout

\begin_layout Plain Layout

 >>> 'spam'[::-1] 
\end_layout

\begin_layout Plain Layout

'maps'
\end_layout

\begin_layout Plain Layout

 >>> 'spam'[slice(None, None, −1)]
\end_layout

\begin_layout Plain Layout

'maps'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Replacement / insertion with slicing
\end_layout

\begin_layout Itemize

\series bold
replacement
\series default
 (delete and then insert)
\end_layout

\begin_deeper
\begin_layout Itemize
L[1:2] = [4,5] replaces one item with two—Python first deletes the one-item
 slice at [1:2] (from offset 1, up to but not including offset 2), then
 inserts both 4 and 5 where the deleted slice used to be.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L = [1, 2, 3]
\end_layout

\begin_layout Plain Layout

>>> L[1:2] = [4, 5]
\end_layout

\begin_layout Plain Layout

>>> L 
\end_layout

\begin_layout Plain Layout

[1, 4, 5, 3]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Insert: delete an empty slice at [1], (as [1:1] does not include the upper
 bound 1, thus it is empty.), then insert 6 and 7
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L[1:1] = [6, 7]
\end_layout

\begin_layout Plain Layout

>>> L
\end_layout

\begin_layout Plain Layout

[1, 6, 7, 4, 5, 3]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
insert from left
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> L[:0] = [2, 3, 4] 
\end_layout

\begin_layout Plain Layout

>>> L 
\end_layout

\begin_layout Plain Layout

[2, 3, 4, 1]
\end_layout

\begin_layout Plain Layout

 >>> L[len(L):] = [5, 6, 7] 
\end_layout

\begin_layout Plain Layout

>>> L
\end_layout

\begin_layout Plain Layout

 [2, 3, 4, 1, 5, 6, 7]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
=[ ]: Deletion (insert nothing) with slicing
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L[1:2] = []
\end_layout

\begin_layout Plain Layout

>>> L 
\end_layout

\begin_layout Plain Layout

[1, 7, 4, 5, 3]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> L = ['spam', 'eggs', 'ham', 'toast']
\end_layout

\begin_layout Plain Layout

>>> del L[0] 
\end_layout

\begin_layout Plain Layout

>>> L 
\end_layout

\begin_layout Plain Layout

['eggs', 'ham', 'toast']
\end_layout

\begin_layout Plain Layout

>>> del L[1:]
\end_layout

\begin_layout Plain Layout

 >>> L 
\end_layout

\begin_layout Plain Layout

['eggs']
\end_layout

\end_inset


\end_layout

\begin_layout Section
force copy
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from copy import deepcopy
\end_layout

\begin_layout Plain Layout

B = deepcopy(A)
\end_layout

\end_inset


\end_layout

\begin_layout Section
iterable terms
\end_layout

\begin_layout Standard
We use for statement for looping over a list.
 If we use it with a string, it loops over its characters.If we use it with
 a dictionary, it loops over its keys.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> for line in open("a.txt"):
\end_layout

\begin_layout Plain Layout

...
     print line,
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

first line
\end_layout

\begin_layout Plain Layout

second line
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So there are many types of objects which can be used with a for loop.
 These are called iterable objects.
\end_layout

\begin_layout Standard
There are many functions which consume these iterables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> ",".join(["a", "b", "c"])
\end_layout

\begin_layout Plain Layout

'a,b,c'
\end_layout

\begin_layout Plain Layout

>>> ",".join({"x": 1, "y": 2})
\end_layout

\begin_layout Plain Layout

'y,x'
\end_layout

\begin_layout Plain Layout

>>> list("python")
\end_layout

\begin_layout Plain Layout

['p', 'y', 't', 'h', 'o', 'n']
\end_layout

\begin_layout Plain Layout

>>> list({"x": 1, "y": 2})
\end_layout

\begin_layout Plain Layout

['y', 'x']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection

\series bold
iterable,
\series default
iterator and next (__next__)
\end_layout

\begin_layout Itemize
The built-in function 
\family typewriter
iter()
\family default
 takes an
\series bold
 iterable
\series default
 object and returns an
\series bold
 iterator
\series default
.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

iter (iterable) 
\end_layout

\begin_layout Plain Layout

# returns an iterator.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
What is an iterator()
\end_layout

\begin_deeper
\begin_layout Itemize
It’s essentially a
\series bold
 generalization of the notion of sequences
\series default
—an object is considered iterable if it is either a physically stored sequence,
 or an object that produces one result at a time in the context of an iterationt
ool like a for loop.operators and precedence.
\end_layout

\begin_layout Itemize
it has a
\begin_inset ERT
status open

\begin_layout Plain Layout

__next__
\end_layout

\end_inset

method to advance to a next result, which raises StopIteration at the end
 of the series of results.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L = [1, 2, 3] 
\end_layout

\begin_layout Plain Layout

>>> I = iter(L) # Obtain an iterator object from an iterable
\end_layout

\begin_layout Plain Layout

>>> I.__next__() # Call iterator's next to advance to next item
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

>>> I.__next__()
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
# But raises an exception at end-of-file due to StopIteration
\end_layout

\begin_layout Standard
All iteration tools, for example,
\series bold
'loop'
\series default
, normally work internally by calling __next__ on eachiteration and catching
 the StopIt eration exception to determine when toexit.
\end_layout

\begin_layout Subsection
Generators
\end_layout

\begin_layout Standard
Generators simplifies creation of iterators.
 A generator is a function that produces a sequence of results instead of
 a single value.
\end_layout

\begin_layout Standard
生成器是可以迭代的，但是你 只可以读取它一次 ，因为它并不把所有的值放在内存中，它是实时地生成数据:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

mygenerator = (x for x in range(3))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mygenerator
\end_layout

\begin_layout Plain Layout

Out[95]: <generator object <genexpr> at 0x11a9edeb0>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

mygenerator.next()
\end_layout

\begin_layout Plain Layout

Out[96]: 0
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# note that not start from 0, but start from the second element 1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for i in mygenerator :
\end_layout

\begin_layout Plain Layout

    print(i)
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
看起来除了把 [] 换成 () 外没什么不同。但是，你不可以再次使用 for i in mygenerator , 因为生成器只能被迭代一次：先计算出0，然后继
续计算1，然后计算4，一个跟一个的…
\end_layout

\begin_layout Itemize
# use [] to get a list from list comprehensions
\end_layout

\begin_layout Itemize
# use () to get a list from list comprehensions
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[32]: M = [6, 15, 24]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[33]: [row + 1 for row in M] 
\end_layout

\begin_layout Plain Layout

Out[33]: [7, 16, 25]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[34]: (row + 1 for row in M)
\end_layout

\begin_layout Plain Layout

Out[34]: <generator object <genexpr> at 0x112a747d0>
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
yiled statement in function
\end_layout

\begin_layout Itemize
can only be used inside the loop of a function
\end_layout

\begin_layout Itemize
let the function return a generator
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> def createGenerator() :
\end_layout

\begin_layout Plain Layout

...
    mylist = range(3)
\end_layout

\begin_layout Plain Layout

...
    for i in mylist :
\end_layout

\begin_layout Plain Layout

...
        yield i*i
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout

>>> mygenerator = createGenerator() # create a generator
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> print(mygenerator) # mygenerator is an object!
\end_layout

\begin_layout Plain Layout

<generator object createGenerator at 0xb7555c34>
\end_layout

\begin_layout Plain Layout

>>> for i in mygenerator:
\end_layout

\begin_layout Plain Layout

...
     print(i)
\end_layout

\begin_layout Plain Layout

0
\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

4
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
xrange
\end_layout

\begin_layout Itemize
xrange(stop) -> xrange object
\end_layout

\begin_layout Itemize
xrange(start, stop[, step]) -> xrange object
\end_layout

\begin_layout Standard
Like range(), but instead of returning a list, returns an object that generates
 the numbers in the range on demand.
 For looping, this is slightly faster than range() and more memory efficient.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

for i in xrange(1,3):
\end_layout

\begin_layout Plain Layout

    print(i)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

1
\end_layout

\begin_layout Plain Layout

2
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

list(xrange(1,3))
\end_layout

\begin_layout Plain Layout

Out[69]: [1, 2]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Problem 1
\end_layout

\begin_layout Standard
Problem 1: Write an iterator class reverse_iter, that takes a list and iterates
 it from the reverse direction.
 ::
\end_layout

\begin_layout Standard
>>> it = reverse_iter([1, 2, 3, 4])
\end_layout

\begin_layout Standard
>>> it.next()
\end_layout

\begin_layout Standard
4
\end_layout

\begin_layout Standard
>>> it.next()
\end_layout

\begin_layout Standard
3
\end_layout

\begin_layout Standard
>>> it.next()
\end_layout

\begin_layout Standard
2
\end_layout

\begin_layout Standard
>>> it.next()
\end_layout

\begin_layout Standard
1
\end_layout

\begin_layout Standard
>>> it.next()
\end_layout

\begin_layout Standard
Traceback (most recent call last):
\end_layout

\begin_layout Standard
File "<stdin>", line 1, in <module>
\end_layout

\begin_layout Standard
StopIteration
\end_layout

\begin_layout Part
data types
\end_layout

\begin_layout Standard
The main types stored in pandas objects are float, int, bool, datetime64[ns]
 and datetime64[ns, tz] (in >= 0.17.0), timedelta[ns], category (in >= 0.15.0),
 and object.
 In addition these dtypes have item sizes, e.g.
 int64 and int32.
 See Series with TZ for more detail on datetime64[ns, tz] dtypes.
\end_layout

\begin_layout Standard
A convenient dtypes attribute for DataFrames returns a Series with the data
 type of each column.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

dft = pd.DataFrame(
\end_layout

\begin_layout Plain Layout

    dict(
\end_layout

\begin_layout Plain Layout

        A = np.random.rand(3),
\end_layout

\begin_layout Plain Layout

        B = 1,
\end_layout

\begin_layout Plain Layout

        C = 'foo',
\end_layout

\begin_layout Plain Layout

        D = pd.Timestamp('20010102'),
\end_layout

\begin_layout Plain Layout

        E = pd.Series([1.0]*3).astype('float32'),
\end_layout

\begin_layout Plain Layout

        F = False,
\end_layout

\begin_layout Plain Layout

        G = pd.Series([1]*3,dtype='int8')
\end_layout

\begin_layout Plain Layout

    )
\end_layout

\begin_layout Plain Layout

)
\end_layout

\begin_layout Plain Layout

In [282]: dft
\end_layout

\begin_layout Plain Layout

Out[282]: 
\end_layout

\begin_layout Plain Layout

          A  B    C          D    E      F  G
\end_layout

\begin_layout Plain Layout

0  0.954940  1  foo 2001-01-02  1.0  False  1
\end_layout

\begin_layout Plain Layout

1  0.318163  1  foo 2001-01-02  1.0  False  1
\end_layout

\begin_layout Plain Layout

2  0.985803  1  foo 2001-01-02  1.0  False  1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In [283]: dft.dtypes
\end_layout

\begin_layout Plain Layout

Out[283]: 
\end_layout

\begin_layout Plain Layout

A           float64
\end_layout

\begin_layout Plain Layout

B             int64
\end_layout

\begin_layout Plain Layout

C            object
\end_layout

\begin_layout Plain Layout

D    datetime64[ns]
\end_layout

\begin_layout Plain Layout

E           float32
\end_layout

\begin_layout Plain Layout

F              bool
\end_layout

\begin_layout Plain Layout

G              int8
\end_layout

\begin_layout Plain Layout

dtype: object
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
types in numpy and pandas
\end_layout

\begin_layout Subsection
subdtypes: return deep structure of all subclasses
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In [339]: def subdtypes(dtype):
\end_layout

\begin_layout Plain Layout

   .....:     subs = dtype.__subclasses__()
\end_layout

\begin_layout Plain Layout

   .....:     if not subs:
\end_layout

\begin_layout Plain Layout

   .....:         return dtype
\end_layout

\begin_layout Plain Layout

   .....:     return [dtype, [subdtypes(dt) for dt in subs]]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In [340]: subdtypes(np.generic)
\end_layout

\begin_layout Plain Layout

Out[340]: 
\end_layout

\begin_layout Plain Layout

[numpy.generic,
\end_layout

\begin_layout Plain Layout

 [[numpy.number,
\end_layout

\begin_layout Plain Layout

   [[numpy.integer,
\end_layout

\begin_layout Plain Layout

     [[numpy.signedinteger,
\end_layout

\begin_layout Plain Layout

       [numpy.int8,
\end_layout

\begin_layout Plain Layout

        numpy.int16,
\end_layout

\begin_layout Plain Layout

        numpy.int32,
\end_layout

\begin_layout Plain Layout

        numpy.int64,
\end_layout

\begin_layout Plain Layout

        numpy.int64,
\end_layout

\begin_layout Plain Layout

        numpy.timedelta64]],
\end_layout

\begin_layout Plain Layout

      [numpy.unsignedinteger,
\end_layout

\begin_layout Plain Layout

       [numpy.uint8,
\end_layout

\begin_layout Plain Layout

        numpy.uint16,
\end_layout

\begin_layout Plain Layout

        numpy.uint32,
\end_layout

\begin_layout Plain Layout

        numpy.uint64,
\end_layout

\begin_layout Plain Layout

        numpy.uint64]]]],
\end_layout

\begin_layout Plain Layout

    [numpy.inexact,
\end_layout

\begin_layout Plain Layout

     [[numpy.floating,
\end_layout

\begin_layout Plain Layout

       [numpy.float16, numpy.float32, numpy.float64, numpy.float128]],
\end_layout

\begin_layout Plain Layout

      [numpy.complexfloating,
\end_layout

\begin_layout Plain Layout

       [numpy.complex64, numpy.complex128, numpy.complex256]]]]]],
\end_layout

\begin_layout Plain Layout

  [numpy.flexible,
\end_layout

\begin_layout Plain Layout

   [[numpy.character, [numpy.string_, numpy.unicode_]],
\end_layout

\begin_layout Plain Layout

    [numpy.void, [numpy.record]]]],
\end_layout

\begin_layout Plain Layout

  numpy.bool_,
\end_layout

\begin_layout Plain Layout

  numpy.datetime64,
\end_layout

\begin_layout Plain Layout

  numpy.object_]]
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
multiple types in one column: dytpe: object
\end_layout

\begin_layout Standard
If a pandas object contains data multiple dtypes IN A SINGLE COLUMN, the
 dtype of the column will be chosen to accommodate all of the data types
 (object is the most general).
\end_layout

\begin_layout Subsection
change the dtypeL df.astype(); pandas.to_numeric; pd.to_datetime; pd.to_timedelta.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In [303]: df3.dtypes
\end_layout

\begin_layout Plain Layout

Out[303]: 
\end_layout

\begin_layout Plain Layout

A    float32
\end_layout

\begin_layout Plain Layout

B    float64
\end_layout

\begin_layout Plain Layout

C    float64
\end_layout

\begin_layout Plain Layout

dtype: object
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# conversion of dtypes
\end_layout

\begin_layout Plain Layout

In [304]: df3.astype(np.float).dtypes
\end_layout

\begin_layout Plain Layout

Out[304]: 
\end_layout

\begin_layout Plain Layout

A    float32
\end_layout

\begin_layout Plain Layout

B    float32
\end_layout

\begin_layout Plain Layout

C    float32
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
pandas.to_numeric(arg, errors='raise'): Convert argument to a numeric type.
\end_layout

\begin_deeper
\begin_layout Standard
Parameters: 
\end_layout

\begin_layout Itemize
arg : list, tuple, 1-d array, or Series
\end_layout

\begin_layout Itemize
errors : {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’
\end_layout

\begin_layout Itemize
If ‘raise’, then invalid parsing will raise an exception
\end_layout

\begin_layout Itemize
If ‘coerce’, then invalid parsing will be set as NaN
\end_layout

\begin_layout Itemize
If ‘ignore’, then invalid parsing will return the input
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[128]: pd.to_numeric(pd.Series(['12.',12,'12.03','AA']))
\end_layout

\begin_layout Plain Layout

# ERROR
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[128]: pd.to_numeric(pd.Series(['12.',12,'12.03','AA']),'ignore')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[123]: 
\end_layout

\begin_layout Plain Layout

0      12.
\end_layout

\begin_layout Plain Layout

1       12
\end_layout

\begin_layout Plain Layout

2    12.03
\end_layout

\begin_layout Plain Layout

3       AA
\end_layout

\begin_layout Plain Layout

dtype: object
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[129]: pd.to_numeric(pd.Series(['12.',12,'12.03','AA']),'coerce')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[124]: 
\end_layout

\begin_layout Plain Layout

0    12.00
\end_layout

\begin_layout Plain Layout

1    12.00
\end_layout

\begin_layout Plain Layout

2    12.03
\end_layout

\begin_layout Plain Layout

3      NaN
\end_layout

\begin_layout Plain Layout

dtype: float64
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
pd.to_datetime
\end_layout

\begin_layout Itemize
pd.to_timedelta
\end_layout

\begin_layout Itemize
change to character
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

Series.astype(np.character)
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
user-defined dtyps in arrary: structured arrays
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

import numpy as np
\end_layout

\begin_layout Plain Layout

studentgrades = np.zeros(5, dtype = [('First Name','a20'),
\end_layout

\begin_layout Plain Layout

                                         ('Last Name', 'a20'),
\end_layout

\begin_layout Plain Layout

                                         ('Score', 'f4')]
\end_layout

\begin_layout Plain Layout

                           )
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

studentgrades[0] = ('Dave', 'Thomas', 89.4)
\end_layout

\begin_layout Plain Layout

studentgrades[1] = ('Tasha', 'Han', 76.6)
\end_layout

\begin_layout Plain Layout

studentgrades[2] = ('Cool', 'Python', 100)
\end_layout

\begin_layout Plain Layout

studentgrades[3] = ('Stack', 'Overflow', 95.32)
\end_layout

\begin_layout Plain Layout

studentgrades[4] = ('Py', 'Py', 75)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[497]: type(studentgrades[0])
\end_layout

\begin_layout Plain Layout

Out[496]: numpy.void
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The beauty of structured arrays is that we can access data by field names.
 For example:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

firstnames = studentgrades['First Name'] 
\end_layout

\begin_layout Plain Layout

print firstnames will return
\end_layout

\begin_layout Plain Layout

['Dave' 'Tasha' 'Cool' 'Stack' 'Py'] 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
numpy.void types are defined as flexible data types.
\end_layout

\begin_layout Standard
Basically, these are data types where there is no pre-defined type associated
 to the variable(s) you're looking at.
\end_layout

\begin_layout Standard
If you look at numpy, you have data types such as float, uint8, bool, string,
 etc.
\end_layout

\begin_layout Standard
void is to accommodate for more generic and flexible types and are for those
 data types that don't necessary fall into any one of these pre-defined
 data types.
\end_layout

\begin_layout Part
Dictionaries { }
\end_layout

\begin_layout Standard

\series bold
Dictionary is like named list in R
\end_layout

\begin_layout Standard
Whenever you print a data and it has {\SpecialChar \ldots{}
}, then it is an inherent of dictionary
 class
\end_layout

\begin_layout Standard
Dictionaries are coded in
\series bold
curly braces
\series default
 and consist of a series of
\begin_inset Quotes eld
\end_inset

key: value
\begin_inset Quotes erd
\end_inset

 pairs.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
entry is a pair of key and its value: Keys must be strings.
 Thus they are hashable
\end_layout

\begin_layout Itemize
Mappings: They are not sequences at all, but are instead known as mappings.
 Mappings are also collections of other objects, but they store objects
 by key instead of by relative position.
 
\end_layout

\begin_layout Itemize
Mutable: Dictionaries, the only mapping type in Python's core objects set,
 are also mutable: like lists, they may be changed in place and can grow
 and shrink on demand.
 
\end_layout

\begin_layout Itemize

\series bold
Mnemonic keys:
\series default
 Also like lists, they are a flexible tool for representing collections,
 but their more mnemonic keys are better suited when a collection's items
 are named or labeled---fields of a database record, for example.
 
\end_layout

\begin_layout Section
Basics
\end_layout

\begin_layout Subsection
Why dictionary is fast and useful
\end_layout

\begin_layout Standard
Internally, dictionaries are implemented as hash tables (data structures
 that support very fast retrieval), which start small and grow on demand.
\end_layout

\begin_layout Standard
Moreover, Python employs optimized hashing algorithms to find keys, so retrieval
 is quick.
 Like lists, dictionaries store object references (not copies, unless you
 ask for them explicitly).
 To implement fast key lookup (a.k.a.
 hashing), keys need to be reordered in memory that is why dictionary is
 unorderd.
\end_layout

\begin_layout Standard
In practice, dictionaries tend to be best for data with labeled components,
 as well as structures that can benefit from quick, direct lookups by name,
 instead of slower linear searches.
\end_layout

\begin_layout Subsection
Create and look like
\end_layout

\begin_layout Standard
no matter which way, the key name must be a string
\end_layout

\begin_layout Itemize
Way 1
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D = {}
\end_layout

\begin_layout Plain Layout

>>> D['name'] = 'Bob' # Create keys by assignment
\end_layout

\begin_layout Plain Layout

>>> D['job'] = 'dev' 
\end_layout

\begin_layout Plain Layout

>>> D['age'] = 40
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Way 2
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

D = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Way of
\emph on
dict
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> bob1 = dict(name='Bob', job='dev', age=40)
\end_layout

\begin_layout Plain Layout

>>> bob1
\end_layout

\begin_layout Plain Layout

 {'age': 40, 'name': 'Bob', 'job': 'dev'}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Way of dict # zip()
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> bob2 = dict(zip([' array name', 'job', 'age'], ['Bob', 'dev', 40]))
 # Zipping
\end_layout

\begin_layout Plain Layout

>>> bob2
\end_layout

\begin_layout Plain Layout

 {'job': 'dev', 'name': 'Bob', 'age': 40}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Provided all the key's values are the same initially, you can also create
 a dictionary with this special form---simply pass in a list of keys and
 an initial value for all of the values (the default is None):
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> dict.fromkeys(['a', 'b'], 0)
\end_layout

\begin_layout Plain Layout

{'a': 0, 'b': 0}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
create a dictionary when first item assigned
\end_layout

\begin_layout Standard
Its often useful if a dictionary can automatically create an entry for this
 new key and give it a default value, such as zero or the empty list.
 For this reason, a special kind of dictionary called a defaultdict is available.
 In order to use it, we have to supply a parameter which can be used to
 create the default value, e.g.
 int, float, str, list, dict, tuple.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

In[155]: frequency = defaultdict(int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[156]: frequency
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[152]: defaultdict(int, {})
\end_layout

\begin_layout Plain Layout

In[157]: frequency['colorless'] = 4
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[158]: frequency
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[154]: defaultdict(int, {'colorless': 4})
\end_layout

\begin_layout Plain Layout

In[159]: 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In[159]: frequency['ideas']
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[155]: 0
\end_layout

\begin_layout Plain Layout

In[160]: frequency
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Out[156]: defaultdict(int, {'colorless': 4, 'ideas': 0})
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
reference by name
\end_layout

\begin_layout Standard
In other applications, dictionaries can also be used to replace searching
 operations---indexing a dictionary by key is often the fastest way to code
 a search in Python.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D['food'] # Fetch value of key 'food'
\end_layout

\begin_layout Plain Layout

 'Spam'
\end_layout

\begin_layout Plain Layout

>>> D['quantity'] += 1
\end_layout

\begin_layout Plain Layout

# Add 1 to 'quantity' value
\end_layout

\begin_layout Plain Layout

 >>> D 
\end_layout

\begin_layout Plain Layout

{'color': 'pink', 'food': 'Spam', 'quantity': 5}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.keys() / .values() / .items(): extract names/values
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D = {'spam': 2, 'ham': 1, 'eggs': 3}
\end_layout

\begin_layout Plain Layout

>>> list(D.values())
\end_layout

\begin_layout Plain Layout

 [3, 2, 1]
\end_layout

\begin_layout Plain Layout

 >>> list(D.items())
\end_layout

\begin_layout Plain Layout

[('eggs', 3), ('spam', 2), ('ham', 1)]
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Get the value corresponding to key spam
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D.get('spam')
\end_layout

\begin_layout Plain Layout

 2
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
key views
\end_layout

\begin_deeper
\begin_layout Itemize
Also unlike 2.X’s list results, 3.X’s view objects returned by the keys method
 are set- like and support common set operations such as intersection and
 union;
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>> K | {'x': 4} # Keys (and some items) views are set-like
\end_layout

\begin_layout Plain Layout

{'c', 'x', 'a'}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
because keys does not return a list in 3.X, the traditional coding pattern
 for scanning a dictionary by sorted keys in 2.X won’t work in 3.X:
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> Ks = D.keys() # Sorting a view object doesn't work!
\end_layout

\begin_layout Plain Layout

>>> Ks.sort()
\end_layout

\begin_layout Plain Layout

 AttributeError: 'dict_keys' object has no attribute 'sort'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Value views
\end_layout

\begin_deeper
\begin_layout Itemize
Values views are not set-like, so do not support the operation like above
 (will return errors)
\end_layout

\end_deeper
\begin_layout Itemize
Items views
\end_layout

\begin_deeper
\begin_layout Itemize
Items views are set-like too if they are hashable (that is, if they contain
 only immutable objects).
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D.items() | D.keys()
\end_layout

\begin_layout Plain Layout

{('a', 1), 'a'}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
Nesting in Dictionary
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> rec = {'name': {'first': 'Bob', 'last': 'Smith'},
\end_layout

\begin_layout Plain Layout

         'jobs': ['dev', 'mgr'],
\end_layout

\begin_layout Plain Layout

         'age': 40.5}
\end_layout

\begin_layout Plain Layout

>>> rec['name']['last']
\end_layout

\begin_layout Plain Layout

'Smith'
\end_layout

\begin_layout Plain Layout

>>> rec['jobs']
\end_layout

\begin_layout Plain Layout

['dev', 'mgr']
\end_layout

\begin_layout Plain Layout

 >>> rec['jobs'][-1]
\end_layout

\begin_layout Plain Layout

'mgr'
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Integer keys: Using dictionaries like lists
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>> D = {} 
\end_layout

\begin_layout Plain Layout

>>> D[99] = 'spam'
\end_layout

\begin_layout Plain Layout

>>> D[99] 
\end_layout

\begin_layout Plain Layout

'spam'
\end_layout

\begin_layout Plain Layout

 >>> D 
\end_layout

\begin_layout Plain Layout

{99: 'spam'}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can access this structure with offsets much like a list, catching nonexisten
t keys with get or in tests if required, but you don't have to allocate
 space for all the positions you might ever need to assign values to in
 the future.
 When used like this, dictionaries are like more flexible equivalents of
 lists.
\end_layout

\begin_layout Subsection
namedtuple: accessed by both position and key
\end_layout

\begin_layout Standard
see that section in tuple.
\end_layout

\begin_layout Subsection
Sparse data structures: Tuple keys
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>>  Matrix = {}
\end_layout

\begin_layout Plain Layout

>>>  Matrix[(2, 3, 4)] = 88
\end_layout

\begin_layout Plain Layout

>>>  Matrix[(7, 8, 9)] = 99
\end_layout

\begin_layout Plain Layout

>>>  Matrix 
\end_layout

\begin_layout Plain Layout

{(2, 3, 4): 88, (7, 8, 9): 99}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here, we've used a dictionary to represent a three-dimensional array that
 is empty except for the two positions (2,3,4) and (7,8,9).
 The keys are tuples that record the coordinates of nonempty slots.
 Rather than allocating a large and mostly empty three- dimensional matrix
 to hold these values, we can use a simple two-item dictionary.
\end_layout

\begin_layout Subsection
As a multiway if statement
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

choice = 'ham'
\end_layout

\begin_layout Plain Layout

print({'spam': 1.25,
\end_layout

\begin_layout Plain Layout

		'ham': 1.99,
\end_layout

\begin_layout Plain Layout

		'eggs':0.99}[choice]
\end_layout

\begin_layout Plain Layout

	 )
\end_layout

\begin_layout Plain Layout

1.99
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Iter items
\end_layout

\begin_layout Subsection
dict.iteritems: Returns an iterator over the dictionary’s (key, value) pairs.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> d = {'a': 1, 'b': 2}
\end_layout

\begin_layout Plain Layout

>>> di = d.iteritems()
\end_layout

\begin_layout Plain Layout

>>> di.next()
\end_layout

\begin_layout Plain Layout

('a', 1)
\end_layout

\begin_layout Plain Layout

>>> di.next()
\end_layout

\begin_layout Plain Layout

('b', 2)
\end_layout

\begin_layout Plain Layout

>>> di.next()
\end_layout

\begin_layout Plain Layout

Traceback (most recent call last):
\end_layout

\begin_layout Plain Layout

File "interactive input>", line 1, in module>
\end_layout

\begin_layout Plain Layout

StopIteration
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type(di)
\end_layout

\begin_layout Plain Layout

Out[36]: dictionary-itemiterator
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Expressions (genetic)
\end_layout

\begin_layout Itemize
in: check whether dictionary contains that key
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D = {'a': 1, 'b': 2, 'c': 3}
\end_layout

\begin_layout Plain Layout

>>> 'f' in D
\end_layout

\begin_layout Plain Layout

False
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
append(): Add a new element under the first-layer element
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> rec['jobs'].append('janitor')
\end_layout

\begin_layout Plain Layout

>>> rec 
\end_layout

\begin_layout Plain Layout

{'age': 40.5, 'jobs': ['dev', 'mgr', 'janitor'], 'name': {'last': 'Smith',
 'first': 'Bob'}}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
.sort()
\end_layout

\begin_layout Itemize
len() : number of entries
\end_layout

\begin_layout Section
Changing Dictionaries in Place
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D 
\end_layout

\begin_layout Plain Layout

{'eggs': 3, 'spam': 2, 'ham': 1}
\end_layout

\begin_layout Plain Layout

>>> D['ham'] = ['grill', 'bake', 'fry'] # Change entry (value=list)
\end_layout

\begin_layout Plain Layout

>>> D 
\end_layout

\begin_layout Plain Layout

{'eggs': 3, 'spam': 2, 'ham': ['grill', 'bake', 'fry']}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
del / .pop() :Delete entry
\end_layout

\begin_layout Itemize
del
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

>>> del D['eggs']
\end_layout

\begin_layout Plain Layout

>>> D
\end_layout

\begin_layout Plain Layout

 {'spam': 2, 'ham': ['grill', 'bake', 'fry']}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
pop method deletes a key from a dictionary and re- turns the value it had.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D {'eggs': 3, 'muffin': 5, 'toast': 4, 'spam': 2, 'ham': 1}
\end_layout

\begin_layout Plain Layout

>>> D.pop('muffin')
\end_layout

\begin_layout Plain Layout

 5
\end_layout

\begin_layout Plain Layout

 >>> D.pop('toast') 
\end_layout

\begin_layout Plain Layout

4
\end_layout

\begin_layout Plain Layout

 >>> D 
\end_layout

\begin_layout Plain Layout

{'eggs': 3, 'spam': 2, 'ham': 1}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
# pop() : Delete from a specific position
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> L.pop() # Delete and return from the end
\end_layout

\begin_layout Plain Layout

'dd'
\end_layout

\begin_layout Plain Layout

>>> L.pop(1)
\end_layout

\begin_layout Plain Layout

 'bb'
\end_layout

\begin_layout Plain Layout

 >>> L 
\end_layout

\begin_layout Plain Layout

['aa', 'cc']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Add new entry
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D['brunch'] = 'Bacon'
\end_layout

\begin_layout Plain Layout

>>> D
\end_layout

\begin_layout Plain Layout

 {'brunch': 'Bacon', 'spam': 2, 'ham': ['grill', 'bake', 'fry']}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
.update() :merge with other items
\end_layout

\begin_layout Standard
It merges the keys and values of one dictionary into another, blindly overwritin
g values of the same key if there's a clash:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> D 
\end_layout

\begin_layout Plain Layout

{'eggs': 3, 'spam': 2, 'ham': 1} 
\end_layout

\begin_layout Plain Layout

>>> D2 = {'toast':4, 'muffin':5} # Lots of delicious scrambled order here
 
\end_layout

\begin_layout Plain Layout

>>> D.update(D2) 
\end_layout

\begin_layout Plain Layout

>>> D 
\end_layout

\begin_layout Plain Layout

{'eggs': 3, 'muffin': 5, 'toast': 4, 'spam': 2, 'ham': 1}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Dictionary comprehensions
\end_layout

\begin_layout Standard
P317
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> for key in D: .
\end_layout

\begin_layout Plain Layout

..
 print(key, D[key])
\end_layout

\end_inset


\end_layout

\begin_layout Standard
no need to write D.keys
\end_layout

\begin_layout Part
Immutability
\end_layout

\begin_layout Section
Immutability
\end_layout

\begin_layout Description
Object type Category Mutable?
\end_layout

\begin_layout Description
Numbers (all) Numeric No
\end_layout

\begin_layout Description
Strings (all) Sequence No
\end_layout

\begin_layout Description
Lists Sequence Yes
\end_layout

\begin_layout Description
Dictionaries Mapping Yes
\end_layout

\begin_layout Description
Tuples Sequence No
\end_layout

\begin_layout Description
Files Extension N/A
\end_layout

\begin_layout Description
Sets Set Yes
\end_layout

\begin_layout Description
Frozenset Set No
\end_layout

\begin_layout Description
bytearray Sequence Yes
\end_layout

\begin_layout Standard
Immutability: 不可以局部的in place 更改，但可以reassign。
\end_layout

\begin_layout Standard
Immutability can be used to guarantee that an object remains constant throughout
your program
\end_layout

\begin_layout Itemize
Immutables (numbers, strings, tuples, frozensets)
\end_layout

\begin_layout Standard
None of the object types in the immutable category support in-place changes,thou
gh we can always run expressions to make new objects and assign theirresults
 to variables as needed.
\end_layout

\begin_layout Itemize
Mutables (lists, dictionaries, sets, bytearray)
\end_layout

\begin_layout Standard
Conversely, the mutable types can always be changed in place with operationsthat
 do not create new objects.Although such objects can be copied, in-place
 changes support direct modification.
\end_layout

\begin_layout Standard
Generally, immutable types give some degree of integrity by guaranteeingthat
 an object won't be changed by another part of a program.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> S
\end_layout

\begin_layout Plain Layout

'Spam'
\end_layout

\begin_layout Plain Layout

>>> S[0] = 'z' # Immutable objects cannot be changed
\end_layout

\begin_layout Plain Layout

...error text omitted...
\end_layout

\begin_layout Plain Layout

TypeError: 'str' object does not support item assignment
\end_layout

\begin_layout Plain Layout

>>> S = 'z' + S[1:] # But we can run expressions to make new objects
\end_layout

\begin_layout Plain Layout

>>> S
\end_layout

\begin_layout Plain Layout

'zpam'
\end_layout

\end_inset


\end_layout

\begin_layout Section
Shallow and Deep Copy
\end_layout

\begin_layout Standard
Python has a strange behaviour - in comparison with other programming languages
 - when assigning and copying simple data types like integers and strings.
 The difference between shallow and deep copying is only relevant for
\series bold
compound objects, which are objects containing other objects, like lists
 or class instances.
 
\end_layout

\begin_layout Itemize
compound/mutable objects: list, dict, set
\end_layout

\begin_layout Itemize
immutable: string, numbers, tuple.
\end_layout

\begin_layout Subsection
Changing the view in place will also change the original.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> colours1 = ["red", "green"]
\end_layout

\begin_layout Plain Layout

>>> colours2 = colours1
\end_layout

\begin_layout Plain Layout

>>> colours2[1] = "blue"
\end_layout

\begin_layout Plain Layout

>>> colours1
\end_layout

\begin_layout Plain Layout

['red', 'blue']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Reassigning the view will NOT change the original
\end_layout

\begin_layout Standard
Reassigning the view to a new instance will break the reference link between
 view and origin, which will not affect the original.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> colours1 = ["red", "green"]
\end_layout

\begin_layout Plain Layout

>>> colours2 = colours1
\end_layout

\begin_layout Plain Layout

>>> colours2 = ["rouge", "vert"]
\end_layout

\begin_layout Plain Layout

>>> print colours1
\end_layout

\begin_layout Plain Layout

['red', 'green']
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Force Copy by slicing: a shallow copy
\end_layout

\begin_layout Itemize
It's possible to completely copy shallow list structures with the slice
 operator without having any of the side effects, which we have described
 above:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> list1 = ['a','b','c','d']
\end_layout

\begin_layout Plain Layout

>>> list2 = list1[:]
\end_layout

\begin_layout Plain Layout

>>> list2[1] = 'x'
\end_layout

\begin_layout Plain Layout

>>> print list2
\end_layout

\begin_layout Plain Layout

['a', 'x', 'c', 'd']
\end_layout

\begin_layout Plain Layout

>>> print list1
\end_layout

\begin_layout Plain Layout

['a', 'b', 'c', 'd']
\end_layout

\begin_layout Plain Layout

>>>
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
But as soon as a list contains sublists, we have the same difficulty, i.e.
 just pointers to the sublists.
 If you assign a new value to the 0th Element of one of the two lists, there
 will be no side effect.
 Problems arise, if you change one of the elements of the sublist.
\end_layout

\begin_deeper
\begin_layout Itemize
This is because copying by slicing all rows is a shallow copy: Shallow copies
 duplicate as little as possible.
 A shallow copy of a collection is a copy of the collection structure, not
 the elements.
 With a shallow copy, two collections now share the individual elements.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

>>> lst1 = ['a','b',['ab','ba']]
\end_layout

\begin_layout Plain Layout

>>> lst2 = lst1[:]
\end_layout

\begin_layout Plain Layout

>>> lst2[0] = 'c'
\end_layout

\begin_layout Plain Layout

>>> lst2[2][1] = 'd'
\end_layout

\begin_layout Plain Layout

>>> print(lst1)
\end_layout

\begin_layout Plain Layout

['a', 'b', ['ab', 'd']]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Subsection
shallow copy from the Module copy
\end_layout

\begin_layout Itemize
Shallow copies duplicate as little as possible.
 A shallow copy of a collection is a copy of the collection structure, not
 the elements.
 With a shallow copy, two collections now share the individual elements.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

lst1 = ['a','b',['ab','ba']]
\end_layout

\begin_layout Plain Layout

lst2 = copy(lst1)
\end_layout

\begin_layout Plain Layout

lst2[0] = 'c'
\end_layout

\begin_layout Plain Layout

lst2[2][1] = 'd'
\end_layout

\begin_layout Plain Layout

print(lst1) # lst1 has been changed!
\end_layout

\begin_layout Plain Layout

['a', 'b', ['ab', 'd']]
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
deepcopy from the Module copy: a real copy
\end_layout

\begin_layout Standard
Deep copies duplicate everything.
 A deep copy of a collection is two collections with all of the elements
 in the original collection duplicated.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

from copy import deepcopy
\end_layout

\begin_layout Plain Layout

lst1 = ['a','b',['ab','ba']]
\end_layout

\begin_layout Plain Layout

lst2 = deepcopy(lst1)
\end_layout

\begin_layout Plain Layout

lst2[2][1] = "d"
\end_layout

\begin_layout Plain Layout

lst2[0] = "c";
\end_layout

\begin_layout Plain Layout

print lst2
\end_layout

\begin_layout Plain Layout

print lst1
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

['c', 'b', ['ab', 'd']]
\end_layout

\begin_layout Plain Layout

['a', 'b', ['ab', 'ba']]
\end_layout

\end_inset


\end_layout

\end_body
\end_document
